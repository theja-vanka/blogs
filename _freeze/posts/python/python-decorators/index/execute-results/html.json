{
  "hash": "24b1c3ad08c7abb0dff939e600aa900b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python Decorators: A Complete Guide with Useful Examples\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-06-22\"\ncategories: [code, beginner]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# Python Decorators: A Complete Guide with Useful Examples\n![](deco.png)\n\nPython decorators are one of the most powerful and elegant features of the language. They allow you to modify or enhance the behavior of functions, methods, or classes without permanently altering their structure. This article explores decorators from the ground up and presents several useful decorators you can implement in your projects.\n\n## Understanding Decorators\n\nAt its core, a decorator is a function that takes another function as an argument and returns a modified version of that function. Decorators leverage Python's first-class functions, where functions can be assigned to variables, passed as arguments, and returned from other functions.\n\n### Basic Decorator Structure\n\n```python\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        # Code to execute before the original function\n        result = func(*args, **kwargs)\n        # Code to execute after the original function\n        return result\n    return wrapper\n\n# Using the decorator\n@my_decorator\ndef my_function():\n    print(\"Hello, World!\")\n```\n\nThe `@my_decorator` syntax is equivalent to writing `my_function = my_decorator(my_function)`.\n\n## Essential Decorator Patterns\n\n### 1. Timing Decorator\n\nThis decorator measures how long a function takes to execute, perfect for performance monitoring.\n\n```python\nimport time\nimport functools\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} took {end_time - start_time:.4f} seconds\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(1)\n    return \"Done!\"\n\n# Usage\nslow_function()  # Output: slow_function took 1.0041 seconds\n```\n\n### 2. Retry Decorator\n\nAutomatically retries a function if it fails, useful for network requests or unreliable operations.\n\n```python\nimport functools\nimport time\nimport random\n\ndef retry(max_attempts=3, delay=1):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    if attempt == max_attempts - 1:\n                        raise e\n                    print(f\"Attempt {attempt + 1} failed: {e}. Retrying in {delay} seconds...\")\n                    time.sleep(delay)\n        return wrapper\n    return decorator\n\n@retry(max_attempts=3, delay=0.5)\ndef unreliable_function():\n    if random.random() < 0.7:  # 70% chance of failure\n        raise Exception(\"Random failure\")\n    return \"Success!\"\n\n# Usage\nresult = unreliable_function()\nprint(result)\n```\n\n### 3. Cache/Memoization Decorator\n\nCaches function results to avoid expensive recalculations for the same inputs.\n\n```python\nimport functools\n\ndef memoize(func):\n    cache = {}\n    \n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # Create a key from arguments\n        key = str(args) + str(sorted(kwargs.items()))\n        \n        if key not in cache:\n            cache[key] = func(*args, **kwargs)\n            print(f\"Cached result for {func.__name__}{args}\")\n        else:\n            print(f\"Retrieved from cache for {func.__name__}{args}\")\n        \n        return cache[key]\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Usage\nprint(fibonacci(10))  # Calculates and caches intermediate results\nprint(fibonacci(10))  # Retrieved from cache\n```\n\n### 4. Logging Decorator\n\nAutomatically logs function calls with their arguments and return values.\n\n```python\nimport functools\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')\n\ndef log_calls(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        args_str = ', '.join([repr(arg) for arg in args])\n        kwargs_str = ', '.join([f\"{k}={v!r}\" for k, v in kwargs.items()])\n        all_args = ', '.join(filter(None, [args_str, kwargs_str]))\n        \n        logging.info(f\"Calling {func.__name__}({all_args})\")\n        \n        try:\n            result = func(*args, **kwargs)\n            logging.info(f\"{func.__name__} returned {result!r}\")\n            return result\n        except Exception as e:\n            logging.error(f\"{func.__name__} raised {type(e).__name__}: {e}\")\n            raise\n    return wrapper\n\n@log_calls\ndef divide(a, b):\n    return a / b\n\n# Usage\ndivide(10, 2)    # Logs the call and result\ndivide(10, 0)    # Logs the call and exception\n```\n\n### 5. Rate Limiting Decorator\n\nPrevents a function from being called too frequently, useful for API rate limiting.\n\n```python\nimport functools\nimport time\nfrom collections import defaultdict\n\ndef rate_limit(max_calls=5, window=60):\n    call_times = defaultdict(list)\n    \n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            now = time.time()\n            func_name = func.__name__\n            \n            # Remove old calls outside the window\n            call_times[func_name] = [\n                call_time for call_time in call_times[func_name]\n                if now - call_time < window\n            ]\n            \n            if len(call_times[func_name]) >= max_calls:\n                raise Exception(f\"Rate limit exceeded for {func_name}. Max {max_calls} calls per {window} seconds.\")\n            \n            call_times[func_name].append(now)\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@rate_limit(max_calls=3, window=10)\ndef api_call():\n    return \"API response\"\n\n# Usage\nfor i in range(5):\n    try:\n        print(api_call())\n        time.sleep(2)\n    except Exception as e:\n        print(f\"Error: {e}\")\n```\n\n### 6. Validation Decorator\n\nValidates function arguments before execution.\n\n```python\nimport functools\n\ndef validate_types(**expected_types):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            # Get function parameter names\n            import inspect\n            sig = inspect.signature(func)\n            bound_args = sig.bind(*args, **kwargs)\n            bound_args.apply_defaults()\n            \n            # Validate types\n            for param_name, expected_type in expected_types.items():\n                if param_name in bound_args.arguments:\n                    value = bound_args.arguments[param_name]\n                    if not isinstance(value, expected_type):\n                        raise TypeError(\n                            f\"Parameter '{param_name}' must be of type {expected_type.__name__}, \"\n                            f\"got {type(value).__name__}\"\n                        )\n            \n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@validate_types(name=str, age=int, height=float)\ndef create_person(name, age, height=0.0):\n    return f\"Person: {name}, {age} years old, {height}m tall\"\n\n# Usage\nprint(create_person(\"Alice\", 30, 1.75))  # Works fine\ntry:\n    create_person(\"Bob\", \"thirty\", 1.80)  # Raises TypeError\nexcept TypeError as e:\n    print(f\"Validation error: {e}\")\n```\n\n### 7. Deprecated Decorator\n\nWarns users when they call deprecated functions.\n\n```python\nimport functools\nimport warnings\n\ndef deprecated(reason=\"This function is deprecated\"):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            warnings.warn(\n                f\"{func.__name__} is deprecated: {reason}\",\n                category=DeprecationWarning,\n                stacklevel=2\n            )\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@deprecated(\"Use new_function() instead\")\ndef old_function():\n    return \"This is the old way\"\n\ndef new_function():\n    return \"This is the new way\"\n\n# Usage\nresult = old_function()  # Prints deprecation warning\n```\n\n## Advanced Decorator Concepts\n\n### Class-Based Decorators\n\nYou can also create decorators using classes by implementing the `__call__` method:\n\n```python\nclass CountCalls:\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n        functools.update_wrapper(self, func)\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"{self.func.__name__} has been called {self.count} times\")\n        return self.func(*args, **kwargs)\n\n@CountCalls\ndef say_hello():\n    print(\"Hello!\")\n\n# Usage\nsay_hello()  # say_hello has been called 1 times\nsay_hello()  # say_hello has been called 2 times\n```\n\n### Stacking Decorators\n\nMultiple decorators can be applied to a single function:\n\n```python\n@timer\n@log_calls\n@retry(max_attempts=2)\ndef complex_function(x, y):\n    if random.random() < 0.5:\n        raise Exception(\"Random failure\")\n    return x + y\n\n# The decorators are applied from bottom to top:\n# complex_function = timer(log_calls(retry(complex_function)))\n```\n\n## Best Practices\n\n1. **Always use `functools.wraps`**: This preserves the original function's metadata (name, docstring, etc.).\n\n2. **Handle arguments properly**: Use `*args` and `**kwargs` to ensure your decorator works with any function signature.\n\n3. **Consider performance**: Be mindful of the overhead your decorators add, especially in performance-critical code.\n\n4. **Make decorators configurable**: Use decorator factories (decorators that return decorators) to make them more flexible.\n\n5. **Document your decorators**: Clear documentation helps other developers understand what your decorators do and how to use them.\n\n## Conclusion\n\nDecorators are a powerful tool for writing clean, maintainable code. They allow you to separate concerns, reduce code duplication, and add functionality to existing functions without modifying their core logic. The decorators presented in this article provide a solid foundation for common programming tasks like logging, caching, validation, and error handling.\n\nStart by incorporating simple decorators like the timer and logging decorators into your projects, then gradually explore more advanced patterns as your needs grow. Remember that the key to effective decorator use is keeping them focused on a single responsibility and making them as reusable as possible.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}