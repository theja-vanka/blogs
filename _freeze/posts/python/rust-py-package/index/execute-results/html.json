{
  "hash": "6936b018d6173d4f8d066130843b83db",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python Package Development with Rust - Complete Guide\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-06-15\"\ncategories: [tutorial, advanced]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# Python Package Development with Rust - Complete Guide\n\n![](rust.png)\n\n## Overview\n\nThis guide covers creating Python packages with Rust backends using PyO3 and maturin. This approach combines Rust's performance and safety with Python's ecosystem accessibility.\n\n::: {.callout-tip}\n## Why Rust + Python?\n- **Performance**: Rust provides near C-level performance\n- **Safety**: Memory safety without garbage collection\n- **Ecosystem**: Access to Python's vast library ecosystem\n- **Maintainability**: Rust's type system catches many bugs at compile time\n:::\n\n## Prerequisites\n\nBefore starting, ensure you have:\n\n- Python 3.7+ installed\n- Rust toolchain installed (rustup recommended)  \n- Basic knowledge of both Python and Rust\n\n::: {.callout-note}\nYou can install Rust from [rustup.rs](https://rustup.rs/) if you haven't already.\n:::\n\n## Installation\n\nFirst, install the required tools:\n\n```bash\n# Install maturin (build tool for Rust-based Python extensions)\npip install maturin\n\n# Install PyO3 CLI (optional but helpful)\npip install pyo3-pack\n```\n\n## Project Setup\n\n### Initialize the Project\n\n```bash\n# Create a new directory\nmkdir my-rust-python-package\ncd my-rust-python-package\n\n# Initialize with maturin\nmaturin init --bindings pyo3\n```\n\nThis creates the basic structure:\n\n```{.default filename=\"Project Structure\"}\nmy-rust-python-package/\n├── Cargo.toml\n├── pyproject.toml\n├── src/\n│   └── lib.rs\n└── python/\n    └── my_rust_python_package/\n        └── __init__.py\n```\n\n### Configure Cargo.toml\n\n```{.toml filename=\"Cargo.toml\"}\n[package]\nname = \"my-rust-python-package\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\nname = \"my_rust_python_package\"\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npyo3 = { version = \"0.20\", features = [\"extension-module\"] }\n\n[build-system]\nrequires = [\"maturin>=1.0,<2.0\"]\nbuild-backend = \"maturin\"\n\n[project]\nname = \"my-rust-python-package\"\nrequires-python = \">=3.7\"\nclassifiers = [\n    \"Programming Language :: Rust\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n]\n```\n\n### Configure pyproject.toml\n\n```{.toml filename=\"pyproject.toml\"}\n[build-system]\nrequires = [\"maturin>=1.0,<2.0\"]\nbuild-backend = \"maturin\"\n\n[project]\nname = \"my-rust-python-package\"\nversion = \"0.1.0\"\ndescription = \"A Python package written in Rust\"\nauthors = [\"Your Name <your.email@example.com>\"]\nrequires-python = \">=3.7\"\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Rust\",\n]\n\n[tool.maturin]\nfeatures = [\"pyo3/extension-module\"]\n```\n\n## Writing Rust Code\n\n### Basic Function Example\n\nEdit `src/lib.rs`:\n\n```{.rust filename=\"src/lib.rs\"}\nuse pyo3::prelude::*;\n\n/// Formats the sum of two numbers as string.\n#[pyfunction]\nfn sum_as_string(a: usize, b: usize) -> PyResult<String> {\n    Ok((a + b).to_string())\n}\n\n/// A simple example function that multiplies two numbers\n#[pyfunction]\nfn multiply(a: f64, b: f64) -> f64 {\n    a * b\n}\n\n/// Fast Fibonacci calculation\n#[pyfunction]\nfn fibonacci(n: u64) -> u64 {\n    match n {\n        0 => 0,\n        1 => 1,\n        _ => {\n            let mut a = 0;\n            let mut b = 1;\n            for _ in 2..=n {\n                let temp = a + b;\n                a = b;\n                b = temp;\n            }\n            b\n        }\n    }\n}\n\n/// A Python module implemented in Rust.\n#[pymodule]\nfn my_rust_python_package(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;\n    m.add_function(wrap_pyfunction!(multiply, m)?)?;\n    m.add_function(wrap_pyfunction!(fibonacci, m)?)?;\n    Ok(())\n}\n```\n\n::: {.callout-important}\n## PyO3 Attributes\n- `#[pyfunction]`: Exposes a Rust function to Python\n- `#[pymodule]`: Creates a Python module from Rust code\n- `PyResult<T>`: Standard return type for functions that can fail\n:::\n\n### Working with Python Objects\n\n```{.rust filename=\"Working with Python Objects\"}\nuse pyo3::prelude::*;\nuse pyo3::types::{PyDict, PyList};\n\n/// Process a Python list of numbers\n#[pyfunction]\nfn process_list(py: Python, list: &PyList) -> PyResult<Vec<f64>> {\n    let mut result = Vec::new();\n    for item in list {\n        let num: f64 = item.extract()?;\n        result.push(num * 2.0);\n    }\n    Ok(result)\n}\n\n/// Work with Python dictionaries\n#[pyfunction]\nfn process_dict(dict: &PyDict) -> PyResult<f64> {\n    let mut sum = 0.0;\n    for (key, value) in dict {\n        let key_str: String = key.extract()?;\n        if key_str.starts_with(\"num_\") {\n            let val: f64 = value.extract()?;\n            sum += val;\n        }\n    }\n    Ok(sum)\n}\n```\n\n### Creating Python Classes\n\n```{.rust filename=\"Python Classes in Rust\"}\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct Counter {\n    value: i64,\n}\n\n#[pymethods]\nimpl Counter {\n    #[new]\n    fn new(initial_value: Option<i64>) -> Self {\n        Counter {\n            value: initial_value.unwrap_or(0),\n        }\n    }\n\n    fn increment(&mut self) {\n        self.value += 1;\n    }\n\n    fn decrement(&mut self) {\n        self.value -= 1;\n    }\n\n    #[getter]\n    fn value(&self) -> i64 {\n        self.value\n    }\n\n    #[setter]\n    fn set_value(&mut self, value: i64) {\n        self.value = value;\n    }\n\n    fn __str__(&self) -> String {\n        format!(\"Counter({})\", self.value)\n    }\n}\n\n// Add to your module function:\n// m.add_class::<Counter>()?;\n```\n\n::: {.callout-tip}\n## Class Attributes\n- `#[pyclass]`: Makes a Rust struct available as a Python class\n- `#[pymethods]`: Groups methods for a Python class\n- `#[new]`: Constructor method\n- `#[getter]`/`#[setter]`: Property accessors\n:::\n\n### Error Handling\n\n```{.rust filename=\"Error Handling\"}\nuse pyo3::prelude::*;\nuse pyo3::exceptions::PyValueError;\n\n#[pyfunction]\nfn divide(a: f64, b: f64) -> PyResult<f64> {\n    if b == 0.0 {\n        Err(PyValueError::new_err(\"Cannot divide by zero\"))\n    } else {\n        Ok(a / b)\n    }\n}\n\n// Custom exception\nuse pyo3::create_exception;\n\ncreate_exception!(my_rust_python_package, CustomError, pyo3::exceptions::PyException);\n\n#[pyfunction]\nfn might_fail(should_fail: bool) -> PyResult<String> {\n    if should_fail {\n        Err(CustomError::new_err(\"Something went wrong!\"))\n    } else {\n        Ok(\"Success!\".to_string())\n    }\n}\n```\n\n## Building and Testing\n\n### Development Build \n\n```bash\n# Build the package in development mode\nmaturin develop\n\n# Or with debug symbols\nmaturin develop --release\n```\n\n::: {.callout-note}\n## Development vs Release\n- Development builds are faster to compile but slower to run\n- Release builds are optimized for performance\n- Use development builds during iteration, release builds for benchmarking\n:::\n\n### Production Build\n\n```bash\n# Build wheel for current platform\nmaturin build --release\n\n# Build for multiple platforms (requires cross-compilation setup)\nmaturin build --release --target x86_64-unknown-linux-gnu\n```\n\n### Testing the Package\n\nCreate a test script `test_package.py`:\n\n```{.python filename=\"test_package.py\"}\nimport my_rust_python_package as pkg\n\n# Test basic functions\nprint(pkg.sum_as_string(5, 20))  # \"25\"\nprint(pkg.multiply(3.5, 2.0))    # 7.0\nprint(pkg.fibonacci(10))         # 55\n\n# Test class\ncounter = pkg.Counter(10)\ncounter.increment()\nprint(counter.value)  # 11\nprint(str(counter))   # \"Counter(11)\"\n\n# Test error handling\ntry:\n    pkg.divide(10, 0)\nexcept ValueError as e:\n    print(f\"Caught error: {e}\")\n```\n\n## Python Integration\n\n### Package Initialization\n\nEdit `python/my_rust_python_package/__init__.py`:\n\n```{.python filename=\"python/my_rust_python_package/__init__.py\"}\nfrom .my_rust_python_package import *\n\n__version__ = \"0.1.0\"\n__author__ = \"Your Name\"\n\n# You can add pure Python code here too\ndef python_helper_function(data):\n    \"\"\"A helper function written in Python.\"\"\"\n    return [fibonacci(x) for x in data if x > 0]\n```\n\n### Type Hints\n\nCreate `python/my_rust_python_package/__init__.pyi`:\n\n```{.python filename=\"python/my_rust_python_package/__init__.pyi\"}\nfrom typing import List, Dict, Any, Optional\n\ndef sum_as_string(a: int, b: int) -> str: ...\ndef multiply(a: float, b: float) -> float: ...\ndef fibonacci(n: int) -> int: ...\ndef process_list(lst: List[float]) -> List[float]: ...\ndef process_dict(d: Dict[str, Any]) -> float: ...\ndef divide(a: float, b: float) -> float: ...\n\nclass Counter:\n    def __init__(self, initial_value: Optional[int] = None) -> None: ...\n    def increment(self) -> None: ...\n    def decrement(self) -> None: ...\n    @property\n    def value(self) -> int: ...\n    @value.setter\n    def value(self, value: int) -> None: ...\n    def __str__(self) -> str: ...\n\nclass CustomError(Exception): ...\n```\n\n::: {.callout-important}\n## Type Stub Files\nType stub files (`.pyi`) provide type information for Python tooling like mypy, IDEs, and static analysis tools. They're crucial for a good developer experience.\n:::\n\n## Performance Optimization\n\n### Using Rust's Parallel Processing\n\nAdd to `Cargo.toml`:\n\n```{.toml filename=\"Cargo.toml - Add Rayon\"}\n[dependencies]\nrayon = \"1.7\"\n```\n\n```{.rust filename=\"Parallel Processing\"}\nuse rayon::prelude::*;\n\n#[pyfunction]\nfn parallel_sum(numbers: Vec<f64>) -> f64 {\n    numbers.par_iter().sum()\n}\n\n#[pyfunction]\nfn parallel_fibonacci(numbers: Vec<u64>) -> Vec<u64> {\n    numbers.par_iter().map(|&n| fibonacci(n)).collect()\n}\n```\n\n### Memory-Efficient Operations\n\n```{.rust filename=\"NumPy Integration\"}\nuse pyo3::prelude::*;\nuse numpy::{PyArray1, PyReadonlyArray1};\n\n// Add numpy to Cargo.toml: numpy = \"0.20\"\n#[pyfunction]\nfn numpy_operation<'py>(\n    py: Python<'py>,\n    array: PyReadonlyArray1<f64>,\n) -> &'py PyArray1<f64> {\n    let input = array.as_array();\n    let result: Vec<f64> = input.iter().map(|&x| x * x).collect();\n    PyArray1::from_vec(py, result)\n}\n```\n\n## Distribution and Publishing\n\n### Building Wheels\n\n```bash\n# Build for current platform\nmaturin build --release\n\n# Build for multiple platforms using cibuildwheel\npip install cibuildwheel\ncibuildwheel --platform linux\n```\n\n### GitHub Actions CI/CD\n\nCreate `.github/workflows/ci.yml`:\n\n```{.yaml filename=\".github/workflows/ci.yml\"}\nname: CI\n\non:\n  push:\n  pull_request:\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: ['3.8', '3.9', '3.10', '3.11']\n    \n    steps:\n    - uses: actions/checkout@v4\n    - uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - uses: dtolnay/rust-toolchain@stable\n    - name: Install maturin\n      run: pip install maturin pytest\n    - name: Build and test\n      run: |\n        maturin develop\n        pytest tests/\n  \n  build:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n    \n    steps:\n    - uses: actions/checkout@v4\n    - uses: dtolnay/rust-toolchain@stable\n    - uses: actions/setup-python@v4\n      with:\n        python-version: '3.x'\n    - name: Build wheels\n      run: |\n        pip install maturin\n        maturin build --release\n    - uses: actions/upload-artifact@v3\n      with:\n        name: wheels\n        path: target/wheels\n```\n\n### Publishing to PyPI\n\n```{.bash}\n# Install twine\npip install twine\n\n# Build the package\nmaturin build --release\n\n# Upload to PyPI\ntwine upload target/wheels/*\n```\n\n::: {.callout-warning}\n## Publishing Checklist\n- Test your package thoroughly before publishing\n- Use semantic versioning\n- Include comprehensive documentation\n- Test installation on clean environments\n:::\n\n## Best Practices\n\n### 1. Error Handling\n- Always use `PyResult<T>` for functions that might fail\n- Create custom exceptions for domain-specific errors\n- Provide clear error messages\n\n### 2. Memory Management\n- Leverage Rust's ownership system\n- Use `PyReadonlyArray` for NumPy arrays when possible\n- Be mindful of GIL (Global Interpreter Lock) implications\n\n### 3. API Design\n- Keep the Rust/Python boundary simple\n- Use appropriate Python types (lists, dicts, etc.)\n- Provide comprehensive type hints\n\n### 4. Testing\n- Write tests for both Rust and Python code\n- Use property-based testing with hypothesis\n- Test error conditions thoroughly\n\n### 5. Documentation\n- Document all public functions and classes\n- Provide usage examples\n- Include performance benchmarks when relevant\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Import Errors**: Ensure module name in `Cargo.toml` matches the `#[pymodule]` name\n2. **Build Failures**: Check that all dependencies are properly specified\n3. **Type Conversion Errors**: Use appropriate PyO3 types for data exchange\n4. **Performance Issues**: Profile both Rust and Python code to identify bottlenecks\n\n### Debugging\n\n```bash\n# Build with debug symbols\nmaturin develop\n\n# Use Python debugger\npython -m pdb your_test_script.py\n\n# Rust debugging (with debug build)\nRUST_BACKTRACE=1 python your_test_script.py\n```\n\n::: {.callout-tip}\n## Debugging Tips\n- Use `println!` macros in Rust for simple debugging\n- Python's `breakpoint()` function works well with Rust extensions\n- Consider using `gdb` or `lldb` for complex debugging scenarios\n:::\n\n## Conclusion\n\nThis guide provides a solid foundation for creating Python packages with Rust backends. The combination offers excellent performance while maintaining Python's ease of use and ecosystem compatibility.\n\nKey takeaways:\n\n- **Setup**: Use maturin for seamless Rust-Python integration\n- **Development**: Leverage PyO3's powerful binding capabilities  \n- **Performance**: Utilize Rust's speed and Python's ecosystem\n- **Distribution**: Standard Python packaging tools work seamlessly\n\nThe Rust-Python ecosystem continues to evolve rapidly, making it an excellent choice for performance-critical Python applications.\n\n---\n\n## Further Reading\n\n- [PyO3 User Guide](https://pyo3.rs/)\n- [Maturin Documentation](https://github.com/PyO3/maturin)\n- [Rust Book](https://doc.rust-lang.org/book/)\n- [Python Packaging User Guide](https://packaging.python.org/)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}