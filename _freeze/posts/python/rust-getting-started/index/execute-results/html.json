{
  "hash": "2db0b829111fc54305f6d776e3aa6d00",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Getting Started with Rust: A Complete Guide\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-06-14\"\ncategories: [code, tutorial, intermediate]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# Getting Started with Rust: A Complete Guide\n\n![](rust.png)\n\n## What is Rust?\n\nRust is a systems programming language that focuses on safety, speed, and concurrency. It prevents common programming errors like null pointer dereferences and buffer overflows at compile time, while delivering performance comparable to C and C++. Rust is ideal for system programming, web backends, command-line tools, network services, and anywhere you need both performance and reliability.\n\n## Installation\n\n### Installing Rust via Rustup\n\nThe easiest way to install Rust is through `rustup`, the official Rust installer and version manager:\n\n**On Linux/macOS:**\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n**On Windows:**\nDownload and run the installer from [rustup.rs](https://rustup.rs/)\n\nAfter installation, restart your terminal and verify the installation:\n```bash\nrustc --version\ncargo --version\n```\n\n### What Gets Installed\n\n- `rustc`: The Rust compiler\n- `cargo`: Rust's package manager and build tool\n- `rustup`: Tool for managing Rust versions\n- Standard library documentation\n\n## Your First Rust Program\n\n### Hello World\n\nCreate a new file called `main.rs`:\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\nCompile and run:\n```bash\nrustc main.rs\n./main  # On Windows: main.exe\n```\n\n### Using Cargo (Recommended)\n\nCargo is Rust's build system and package manager. Create a new project:\n\n```bash\ncargo new hello_rust\ncd hello_rust\n```\n\nThis creates a project structure:\n```\nhello_rust/\n├── Cargo.toml\n└── src/\n    └── main.rs\n```\n\nRun your project:\n```bash\ncargo run\n```\n\nBuild without running:\n```bash\ncargo build\n```\n\n## Core Concepts\n\n### Variables and Mutability\n\nVariables are immutable by default in Rust:\n\n```rust\nfn main() {\n    let x = 5;\n    // x = 6; // This would cause a compile error\n    \n    let mut y = 5;\n    y = 6; // This is fine because y is mutable\n    \n    println!(\"x = {}, y = {}\", x, y);\n}\n```\n\n### Data Types\n\nRust has several built-in data types:\n\n```rust\nfn main() {\n    // Integers\n    let integer: i32 = 42;\n    let unsigned: u32 = 42;\n    \n    // Floating point\n    let float: f64 = 3.14;\n    \n    // Boolean\n    let is_rust_fun: bool = true;\n    \n    // Character\n    let letter: char = 'R';\n    \n    // String\n    let greeting: String = String::from(\"Hello\");\n    let string_slice: &str = \"World\";\n    \n    println!(\"{} {} from Rust!\", greeting, string_slice);\n}\n```\n\n### Functions\n\nFunctions are declared with the `fn` keyword:\n\n```rust\nfn main() {\n    let result = add_numbers(5, 3);\n    println!(\"5 + 3 = {}\", result);\n}\n\nfn add_numbers(a: i32, b: i32) -> i32 {\n    a + b // No semicolon means this is the return value\n}\n```\n\n### Control Flow\n\n```rust\nfn main() {\n    let number = 6;\n    \n    // If expressions\n    if number % 2 == 0 {\n        println!(\"{} is even\", number);\n    } else {\n        println!(\"{} is odd\", number);\n    }\n    \n    // Loops\n    for i in 1..=5 {\n        println!(\"Count: {}\", i);\n    }\n    \n    let mut counter = 0;\n    while counter < 3 {\n        println!(\"Counter: {}\", counter);\n        counter += 1;\n    }\n    \n    // Infinite loop with break\n    loop {\n        println!(\"This runs once\");\n        break;\n    }\n}\n```\n\n## Ownership System\n\nRust's ownership system is what makes it memory-safe without a garbage collector:\n\n### Basic Ownership Rules\n\n1. Each value has a single owner\n2. When the owner goes out of scope, the value is dropped\n3. There can only be one owner at a time\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1; // s1 is moved to s2, s1 is no longer valid\n    \n    // println!(\"{}\", s1); // This would cause a compile error\n    println!(\"{}\", s2); // This works\n    \n    let s3 = s2.clone(); // Explicitly clone the data\n    println!(\"{} and {}\", s2, s3); // Both work now\n}\n```\n\n### Borrowing and References\n\nInstead of moving ownership, you can borrow references:\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    \n    let len = calculate_length(&s); // Borrow s\n    println!(\"Length of '{}' is {}\", s, len); // s is still valid\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n} // s goes out of scope but doesn't drop the data (it doesn't own it)\n```\n\n## Error Handling\n\nRust uses `Result<T, E>` and `Option<T>` for error handling:\n\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    // Option example\n    let numbers = vec![1, 2, 3, 4, 5];\n    match numbers.get(10) {\n        Some(value) => println!(\"Found: {}\", value),\n        None => println!(\"No value at index 10\"),\n    }\n    \n    // Result example\n    let file_result = File::open(\"hello.txt\");\n    match file_result {\n        Ok(file) => println!(\"File opened successfully\"),\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => println!(\"File not found\"),\n            _ => println!(\"Error opening file: {:?}\", error),\n        },\n    }\n}\n```\n\n## Working with Collections\n\n### Vectors\n\n```rust\nfn main() {\n    let mut numbers = vec![1, 2, 3];\n    numbers.push(4);\n    \n    for number in &numbers {\n        println!(\"{}\", number);\n    }\n    \n    println!(\"Third element: {}\", numbers[2]);\n}\n```\n\n### HashMaps\n\n```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n    scores.insert(\"Blue\", 10);\n    scores.insert(\"Red\", 50);\n    \n    for (team, score) in &scores {\n        println!(\"{}: {}\", team, score);\n    }\n}\n```\n\n## Structs and Enums\n\n### Structs\n\n```rust\nstruct Person {\n    name: String,\n    age: u32,\n    email: String,\n}\n\nimpl Person {\n    fn new(name: String, age: u32, email: String) -> Person {\n        Person { name, age, email }\n    }\n    \n    fn greet(&self) {\n        println!(\"Hello, my name is {}\", self.name);\n    }\n}\n\nfn main() {\n    let person = Person::new(\n        String::from(\"Alice\"),\n        30,\n        String::from(\"alice@example.com\")\n    );\n    \n    person.greet();\n}\n```\n\n### Enums\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nimpl Message {\n    fn call(&self) {\n        match self {\n            Message::Quit => println!(\"Quitting\"),\n            Message::Move { x, y } => println!(\"Moving to ({}, {})\", x, y),\n            Message::Write(text) => println!(\"Writing: {}\", text),\n            Message::ChangeColor(r, g, b) => println!(\"Changing color to ({}, {}, {})\", r, g, b),\n        }\n    }\n}\n\nfn main() {\n    let msg = Message::Write(String::from(\"Hello\"));\n    msg.call();\n}\n```\n\n## Package Management with Cargo\n\n### Adding Dependencies\n\nEdit your `Cargo.toml` file to add dependencies:\n\n```toml\n[dependencies]\nserde = \"1.0\"\ntokio = { version = \"1.0\", features = [\"full\"] }\n```\n\nThen run:\n```bash\ncargo build\n```\n\n### Common Cargo Commands\n\n- `cargo new project_name` - Create a new project\n- `cargo build` - Compile the project\n- `cargo run` - Compile and run the project\n- `cargo test` - Run tests\n- `cargo doc --open` - Generate and open documentation\n- `cargo update` - Update dependencies\n- `cargo clean` - Remove build artifacts\n\n## Development Tools\n\n### Formatting\n\nFormat your code automatically:\n```bash\ncargo fmt\n```\n\n### Linting\n\nCheck for common mistakes and style issues:\n```bash\ncargo clippy\n```\n\n### Testing\n\nWrite tests in the same file or separate test modules:\n\n```rust\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }\n}\n```\n\nRun tests with:\n```bash\ncargo test\n```\n\n## Next Steps\n\n### Learning Resources\n\n1. **The Rust Programming Language Book** - The official book, available online for free\n2. **Rust by Example** - Learn Rust through practical examples\n3. **Rustlings** - Small exercises to get you used to Rust syntax\n4. **The Rust Reference** - Detailed language reference\n5. **Rust Standard Library Documentation** - Comprehensive API documentation\n\n### Practice Projects\n\n1. **Command-line calculator** - Practice basic syntax and user input\n2. **File organizer** - Learn file I/O and error handling\n3. **Web scraper** - Work with HTTP requests and HTML parsing\n4. **Simple web server** - Understand concurrency and networking\n5. **Game of Life** - Practice with 2D arrays and algorithms\n\n### Join the Community\n\n- **Rust Users Forum** - Ask questions and share knowledge\n- **Reddit r/rust** - Community discussions and news\n- **Discord/IRC** - Real-time chat with other Rust developers\n- **Local Rust meetups** - Find Rust developers in your area\n\n## Tips for Success\n\n1. **Embrace the compiler** - Rust's compiler provides excellent error messages. Read them carefully\n2. **Start small** - Begin with simple programs and gradually increase complexity\n3. **Practice ownership** - The ownership system is unique to Rust, so it takes time to internalize\n4. **Use the standard library** - Rust has a rich standard library with excellent documentation\n5. **Don't fight the borrow checker** - Learn to work with Rust's safety guarantees rather than against them\n\nThe Rust compiler is your friend and will help you write safe, fast code. Take time to understand the error messages, and don't hesitate to refer to the official documentation when you're stuck. Happy coding!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}