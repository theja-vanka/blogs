{
  "hash": "ef01bc5743555609b80c87f97305b9b5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Complete Guide to Python's itertools Module\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-07-06\"\ncategories: [code, tutorial, beginner]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# Complete Guide to Python's itertools Module\n![](iter.png)\n\n## Introduction\n\nThe `itertools` module is one of Python's most powerful standard library modules for creating iterators and performing functional programming operations. It provides a collection of tools for creating iterators that are building blocks for efficient loops and data processing pipelines.\n\nThe `itertools` module provides three categories of iterators:\n\n- **Infinite iterators**: Generate infinite sequences\n- **Finite iterators**: Work with finite sequences\n- **Combinatorial iterators**: Generate combinations and permutations\n\n::: {#2ddb35bc .cell execution_count=1}\n``` {.python .cell-code}\nimport itertools\n```\n:::\n\n\n### Other necessary imports\n\n::: {#23afdf0e .cell execution_count=2}\n``` {.python .cell-code}\nimport math\n```\n:::\n\n\n## Why Use itertools?\n\n- **Memory Efficient**: Creates iterators that generate values on-demand\n- **Functional Programming**: Enables elegant functional programming patterns\n- **Performance**: Many operations are implemented in C for speed\n- **Composability**: Functions can be easily combined to create complex iterations\n\n## Categories of itertools Functions\n\nThe itertools module is organized into three main categories:\n\n1. **Infinite Iterators**: Generate infinite sequences\n2. **Finite Iterators**: Terminate based on input sequences\n3. **Combinatorial Iterators**: Generate combinations and permutations\n\n---\n\n## 1. Infinite Iterators\n\n### count(start=0, step=1)\n\nCreates an infinite arithmetic sequence starting from `start` with increments of `step`.\n\n::: {#161c4139 .cell execution_count=3}\n``` {.python .cell-code}\nimport itertools\n\n# Basic counting\ncounter = itertools.count(1)\nprint(list(itertools.islice(counter, 5)))  # [1, 2, 3, 4, 5]\n\n# Counting with step\ncounter = itertools.count(0, 2)\nprint(list(itertools.islice(counter, 5)))  # [0, 2, 4, 6, 8]\n\n# Counting with floats\ncounter = itertools.count(0.5, 0.1)\nprint(list(itertools.islice(counter, 3)))  # [0.5, 0.6, 0.7]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5]\n[0, 2, 4, 6, 8]\n[0.5, 0.6, 0.7]\n```\n:::\n:::\n\n\n**Use Case**: Generating IDs, pagination, or any sequence that needs infinite counting.\n\n### cycle(iterable)\n\nInfinitely repeats the elements of an iterable.\n\n::: {#593c4e10 .cell execution_count=4}\n``` {.python .cell-code}\ncolors = itertools.cycle(['red', 'green', 'blue'])\nprint(list(itertools.islice(colors, 8)))\n# ['red', 'green', 'blue', 'red', 'green', 'blue', 'red', 'green']\n\n# Practical example: Round-robin assignment\ntasks = ['task1', 'task2', 'task3', 'task4']\nworkers = itertools.cycle(['Alice', 'Bob', 'Charlie'])\n\nassignments = list(zip(tasks, workers))\nprint(assignments)\n# [('task1', 'Alice'), ('task2', 'Bob'), ('task3', 'Charlie'), ('task4', 'Alice')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['red', 'green', 'blue', 'red', 'green', 'blue', 'red', 'green']\n[('task1', 'Alice'), ('task2', 'Bob'), ('task3', 'Charlie'), ('task4', 'Alice')]\n```\n:::\n:::\n\n\n### repeat(object, times=None)\n\nRepeats an object either infinitely or a specified number of times.\n\n::: {#4f16d7bc .cell execution_count=5}\n``` {.python .cell-code}\n# Infinite repeat\nones = itertools.repeat(1)\nprint(list(itertools.islice(ones, 5)))  # [1, 1, 1, 1, 1]\n\n# Finite repeat\nzeros = itertools.repeat(0, 3)\nprint(list(zeros))  # [0, 0, 0]\n\n# Practical example: Creating default values\ndefault_config = {'debug': False, 'timeout': 30}\nconfigs = list(itertools.repeat(default_config, 5))\nprint(len(configs))  # 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 1, 1, 1, 1]\n[0, 0, 0]\n5\n```\n:::\n:::\n\n\n---\n\n## 2. Finite Iterators\n\n### accumulate(iterable, func=operator.add, initial=None)\n\nReturns running totals or results of binary functions.\n\n::: {#5fcd167d .cell execution_count=6}\n``` {.python .cell-code}\nimport operator\n\n# Running sum (default)\nnumbers = [1, 2, 3, 4, 5]\nprint(list(itertools.accumulate(numbers)))  # [1, 3, 6, 10, 15]\n\n# Running product\nprint(list(itertools.accumulate(numbers, operator.mul)))  # [1, 2, 6, 24, 120]\n\n# Running maximum\nprint(list(itertools.accumulate([3, 1, 4, 1, 5], max)))  # [3, 3, 4, 4, 5]\n\n# With initial value (Python 3.8+)\nprint(list(itertools.accumulate([1, 2, 3], initial=100)))  # [100, 101, 103, 106]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 3, 6, 10, 15]\n[1, 2, 6, 24, 120]\n[3, 3, 4, 4, 5]\n[100, 101, 103, 106]\n```\n:::\n:::\n\n\n### chain(*iterables)\n\nFlattens multiple iterables into a single sequence.\n\n::: {#1f576729 .cell execution_count=7}\n``` {.python .cell-code}\n# Basic chaining\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nlist3 = [7, 8, 9]\n\nchained = itertools.chain(list1, list2, list3)\nprint(list(chained))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Chain from iterable\nnested_lists = [[1, 2], [3, 4], [5, 6]]\nflattened = itertools.chain.from_iterable(nested_lists)\nprint(list(flattened))  # [1, 2, 3, 4, 5, 6]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6]\n```\n:::\n:::\n\n\n### compress(data, selectors)\n\nFilters data based on corresponding boolean values in selectors.\n\n::: {#6b403a23 .cell execution_count=8}\n``` {.python .cell-code}\ndata = ['A', 'B', 'C', 'D', 'E']\nselectors = [1, 0, 1, 0, 1]\n\nfiltered = itertools.compress(data, selectors)\nprint(list(filtered))  # ['A', 'C', 'E']\n\n# Practical example: Filtering based on conditions\nnames = ['Alice', 'Bob', 'Charlie', 'David']\nages = [25, 17, 30, 16]\nadults = [age >= 18 for age in ages]\n\nadult_names = itertools.compress(names, adults)\nprint(list(adult_names))  # ['Alice', 'Charlie']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['A', 'C', 'E']\n['Alice', 'Charlie']\n```\n:::\n:::\n\n\n### dropwhile(predicate, iterable)\n\nDrops elements from the beginning while predicate is true.\n\n::: {#d406906a .cell execution_count=9}\n``` {.python .cell-code}\nnumbers = [1, 3, 5, 8, 9, 10, 12]\nresult = itertools.dropwhile(lambda x: x < 8, numbers)\nprint(list(result))  # [8, 9, 10, 12]\n\n# Practical example: Skip header lines\nlines = ['# Comment', '# Another comment', 'data1', 'data2', '# inline comment']\ndata_lines = itertools.dropwhile(lambda line: line.startswith('#'), lines)\nprint(list(data_lines))  # ['data1', 'data2', '# inline comment']\n\n# Practical example: Processing log entries\nlog_entries = [\n    \"INFO: Starting application\",\n    \"DEBUG: Loading config\",\n    \"ERROR: Database connection failed\",\n    \"INFO: Retrying connection\",\n    \"INFO: Connection successful\"\n]\n\n# Skip INFO messages at the beginning\nimportant_logs = itertools.dropwhile(\n    lambda x: x.startswith(\"INFO\"), log_entries\n)\nprint(list(important_logs))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[8, 9, 10, 12]\n['data1', 'data2', '# inline comment']\n['DEBUG: Loading config', 'ERROR: Database connection failed', 'INFO: Retrying connection', 'INFO: Connection successful']\n```\n:::\n:::\n\n\n### takewhile(predicate, iterable)\n\nReturns elements from the beginning while predicate is true.\n\n::: {#3e12b4c9 .cell execution_count=10}\n``` {.python .cell-code}\nnumbers = [1, 3, 5, 8, 9, 10, 12]\nresult = itertools.takewhile(lambda x: x < 8, numbers)\nprint(list(result))  # [1, 3, 5]\n\n# Practical example: Read until delimiter\ndata = ['apple', 'banana', 'STOP', 'cherry', 'date']\nbefore_stop = itertools.takewhile(lambda x: x != 'STOP', data)\nprint(list(before_stop))  # ['apple', 'banana']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 3, 5]\n['apple', 'banana']\n```\n:::\n:::\n\n\n### filterfalse(predicate, iterable)\n\nReturns elements where predicate is false (opposite of filter).\n\n::: {#b7b27b83 .cell execution_count=11}\n``` {.python .cell-code}\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nodds = itertools.filterfalse(lambda x: x % 2 == 0, numbers)\nprint(list(odds))  # [1, 3, 5, 7, 9]\n\n# Compare with regular filter\nevens = filter(lambda x: x % 2 == 0, numbers)\nprint(list(evens))  # [2, 4, 6, 8, 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 3, 5, 7, 9]\n[2, 4, 6, 8, 10]\n```\n:::\n:::\n\n\n### groupby(iterable, key=None)\n\nGroups consecutive elements by a key function.\n\n::: {#dabca415 .cell execution_count=12}\n``` {.python .cell-code}\n# Basic grouping\ndata = [1, 1, 2, 2, 2, 3, 1, 1]\ngrouped = itertools.groupby(data)\n\nfor key, group in grouped:\n    print(f\"{key}: {list(group)}\")\n# 1: [1, 1]\n# 2: [2, 2, 2]\n# 3: [3]\n# 1: [1, 1]\n\n# Grouping with key function\nwords = ['apple', 'banana', 'apricot', 'blueberry', 'cherry']\n# First sort by first letter, then group\nsorted_words = sorted(words, key=lambda x: x[0])\ngrouped_words = itertools.groupby(sorted_words, key=lambda x: x[0])\n\nfor letter, group in grouped_words:\n    print(f\"{letter}: {list(group)}\")\n# a: ['apple', 'apricot']\n# b: ['banana', 'blueberry']\n# c: ['cherry']\n\n# Grouping sorted data\nstudents = [\n    ('Alice', 'A'),\n    ('Bob', 'B'),\n    ('Charlie', 'A'),\n    ('David', 'B'),\n    ('Eve', 'A')\n]\n# Sort first, then group\nstudents_sorted = sorted(students, key=lambda x: x[1])\nby_grade = itertools.groupby(students_sorted, key=lambda x: x[1])\nfor grade, group in by_grade:\n    names = [student[0] for student in group]\n    print(f\"Grade {grade}: {names}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1: [1, 1]\n2: [2, 2, 2]\n3: [3]\n1: [1, 1]\na: ['apple', 'apricot']\nb: ['banana', 'blueberry']\nc: ['cherry']\nGrade A: ['Alice', 'Charlie', 'Eve']\nGrade B: ['Bob', 'David']\n```\n:::\n:::\n\n\n### islice(iterable, start, stop, step)\n\nReturns selected elements from the iterable (like list slicing but for iterators).\n\n::: {#8191ea97 .cell execution_count=13}\n``` {.python .cell-code}\nnumbers = range(20)\n\n# islice(iterable, stop)\nprint(list(itertools.islice(numbers, 5)))  # [0, 1, 2, 3, 4]\n\n# islice(iterable, start, stop)\nprint(list(itertools.islice(numbers, 5, 10)))  # [5, 6, 7, 8, 9]\n\n# islice(iterable, start, stop, step)\nprint(list(itertools.islice(numbers, 0, 10, 2)))  # [0, 2, 4, 6, 8]\n\n# Practical example: Pagination\ndef paginate(iterable, page_size):\n    iterator = iter(iterable)\n    while True:\n        page = list(itertools.islice(iterator, page_size))\n        if not page:\n            break\n        yield page\n\ndata = range(25)\nfor page_num, page in enumerate(paginate(data, 10), 1):\n    print(f\"Page {page_num}: {page}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 2, 3, 4]\n[5, 6, 7, 8, 9]\n[0, 2, 4, 6, 8]\nPage 1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nPage 2: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\nPage 3: [20, 21, 22, 23, 24]\n```\n:::\n:::\n\n\n### starmap(function, iterable)\n\nApplies function to arguments unpacked from each item in iterable.\n\n::: {#e3a0b93a .cell execution_count=14}\n``` {.python .cell-code}\n# Basic usage\npoints = [(1, 2), (3, 4), (5, 6)]\ndistances = itertools.starmap(lambda x, y: (x**2 + y**2)**0.5, points)\nprint(list(distances))  # [2.236..., 5.0, 7.810...]\n\n# Practical example: Multiple argument functions\nimport operator\npairs = [(2, 3), (4, 5), (6, 7)]\nproducts = itertools.starmap(operator.mul, pairs)\nprint(list(products))  # [6, 20, 42]\n\n# Compare with map\nregular_map = map(operator.mul, [2, 4, 6], [3, 5, 7])\nprint(list(regular_map))  # [6, 20, 42]\n\n# Compare with map\n# map passes each tuple as a single argument\n# starmap unpacks each tuple as separate arguments\ndef add(x, y):\n    return x + y\n\npairs = [(1, 2), (3, 4), (5, 6)]\nresult = list(itertools.starmap(add, pairs))\nprint(result)  # [3, 7, 11]\n\n# Practical example: Applying operations to coordinate pairs\ncoordinates = [(1, 2), (3, 4), (5, 6)]\ndistances_from_origin = list(itertools.starmap(\n    lambda x, y: math.sqrt(x**2 + y**2), coordinates\n))\nprint(distances_from_origin)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2.23606797749979, 5.0, 7.810249675906654]\n[6, 20, 42]\n[6, 20, 42]\n[3, 7, 11]\n[2.23606797749979, 5.0, 7.810249675906654]\n```\n:::\n:::\n\n\n### tee(iterable, n=2)\n\nSplits an iterable into n independent iterators.\n\n::: {#f7de7210 .cell execution_count=15}\n``` {.python .cell-code}\ndata = [1, 2, 3, 4, 5]\niter1, iter2 = itertools.tee(data)\n\nprint(list(iter1))  # [1, 2, 3, 4, 5]\nprint(list(iter2))  # [1, 2, 3, 4, 5]\n\n# Practical example: Processing data in multiple ways\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nevens_iter, odds_iter = itertools.tee(numbers)\n\nevens = filter(lambda x: x % 2 == 0, evens_iter)\nodds = filter(lambda x: x % 2 == 1, odds_iter)\n\nprint(f\"Evens: {list(evens)}\")  # [2, 4, 6, 8, 10]\nprint(f\"Odds: {list(odds)}\")    # [1, 3, 5, 7, 9]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5]\nEvens: [2, 4, 6, 8, 10]\nOdds: [1, 3, 5, 7, 9]\n```\n:::\n:::\n\n\n### zip_longest(*iterables, fillvalue=None)\n\nZips iterables but continues until the longest is exhausted.\n\n::: {#11b98166 .cell execution_count=16}\n``` {.python .cell-code}\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b', 'c', 'd', 'e']\n\n# Regular zip stops at shortest\nprint(list(zip(list1, list2)))  # [(1, 'a'), (2, 'b'), (3, 'c')]\n\n# zip_longest continues to longest\nprint(list(itertools.zip_longest(list1, list2)))\n# [(1, 'a'), (2, 'b'), (3, 'c'), (None, 'd'), (None, 'e')]\n\n# With custom fillvalue\nprint(list(itertools.zip_longest(list1, list2, fillvalue='X')))\n# [(1, 'a'), (2, 'b'), (3, 'c'), ('X', 'd'), ('X', 'e')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(1, 'a'), (2, 'b'), (3, 'c')]\n[(1, 'a'), (2, 'b'), (3, 'c'), (None, 'd'), (None, 'e')]\n[(1, 'a'), (2, 'b'), (3, 'c'), ('X', 'd'), ('X', 'e')]\n```\n:::\n:::\n\n\n---\n\n## 3. Combinatorial Iterators\n\n### product(*iterables, repeat=1)\n\nCartesian product of input iterables.\n\n::: {#b9e96a86 .cell execution_count=17}\n``` {.python .cell-code}\n# Basic product\ncolors = ['red', 'blue']\nsizes = ['S', 'M', 'L']\n\ncombinations = itertools.product(colors, sizes)\nprint(list(combinations))\n# [('red', 'S'), ('red', 'M'), ('red', 'L'), ('blue', 'S'), ('blue', 'M'), ('blue', 'L')]\n\n# With repeat\ndice_rolls = itertools.product(range(1, 7), repeat=2)\nprint(list(itertools.islice(dice_rolls, 10)))\n# [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4)]\n\n# Practical example: Grid coordinates\ngrid = itertools.product(range(3), range(3))\nprint(list(grid))\n# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[('red', 'S'), ('red', 'M'), ('red', 'L'), ('blue', 'S'), ('blue', 'M'), ('blue', 'L')]\n[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4)]\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n```\n:::\n:::\n\n\n### permutations(iterable, r=None)\n\nReturns r-length permutations of elements.\n\n::: {#3b4b528f .cell execution_count=18}\n``` {.python .cell-code}\n# All permutations\nletters = ['A', 'B', 'C']\nperms = itertools.permutations(letters)\nprint(list(perms))\n# [('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')]\n\n# r-length permutations\nperms_2 = itertools.permutations(letters, 2)\nprint(list(perms_2))\n# [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]\n\n# Practical example: Anagrams\ndef find_anagrams(word, length=None):\n    if length is None:\n        length = len(word)\n    return [''.join(p) for p in itertools.permutations(word, length)]\n\nprint(find_anagrams('CAT', 2))  # ['CA', 'CT', 'AC', 'AT', 'TC', 'TA']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')]\n[('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]\n['CA', 'CT', 'AC', 'AT', 'TC', 'TA']\n```\n:::\n:::\n\n\n### combinations(iterable, r)\n\nReturns r-length combinations without replacement.\n\n::: {#32061c9c .cell execution_count=19}\n``` {.python .cell-code}\n# Basic combinations\nnumbers = [1, 2, 3, 4]\ncombos = itertools.combinations(numbers, 2)\nprint(list(combos))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n\n# Practical example: Team selection\nplayers = ['Alice', 'Bob', 'Charlie', 'David', 'Eve']\nteams = itertools.combinations(players, 3)\nprint(list(itertools.islice(teams, 5)))\n# [('Alice', 'Bob', 'Charlie'), ('Alice', 'Bob', 'David'), ('Alice', 'Bob', 'Eve'), ('Alice', 'Charlie', 'David'), ('Alice', 'Charlie', 'Eve')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n[('Alice', 'Bob', 'Charlie'), ('Alice', 'Bob', 'David'), ('Alice', 'Bob', 'Eve'), ('Alice', 'Charlie', 'David'), ('Alice', 'Charlie', 'Eve')]\n```\n:::\n:::\n\n\n### combinations_with_replacement(iterable, r)\n\nReturns r-length combinations with replacement allowed.\n\n::: {#54d82c8d .cell execution_count=20}\n``` {.python .cell-code}\n# Basic combinations with replacement\nnumbers = [1, 2, 3]\ncombos = itertools.combinations_with_replacement(numbers, 2)\nprint(list(combos))\n# [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]\n\n# Practical example: Coin flips allowing same outcome\noutcomes = ['H', 'T']\ntwo_flips = itertools.combinations_with_replacement(outcomes, 2)\nprint(list(two_flips))\n# [('H', 'H'), ('H', 'T'), ('T', 'T')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]\n[('H', 'H'), ('H', 'T'), ('T', 'T')]\n```\n:::\n:::\n\n\n---\n\n## Grouping and Filtering\n\n### Advanced groupby() Examples\n\n::: {#f232dc9c .cell execution_count=21}\n``` {.python .cell-code}\n# Group by multiple criteria\ndata = [\n    {'name': 'Alice', 'age': 25, 'city': 'New York'},\n    {'name': 'Bob', 'age': 25, 'city': 'New York'},\n    {'name': 'Charlie', 'age': 30, 'city': 'Boston'},\n    {'name': 'David', 'age': 30, 'city': 'Boston'},\n    {'name': 'Eve', 'age': 25, 'city': 'Boston'}\n]\n\n# Group by age and city\nkey_func = lambda x: (x['age'], x['city'])\nsorted_data = sorted(data, key=key_func)\nfor key, group in itertools.groupby(sorted_data, key=key_func):\n    age, city = key\n    names = [person['name'] for person in group]\n    print(f\"Age {age}, City {city}: {names}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAge 25, City Boston: ['Eve']\nAge 25, City New York: ['Alice', 'Bob']\nAge 30, City Boston: ['Charlie', 'David']\n```\n:::\n:::\n\n\n### Custom Filtering Patterns\n\n::: {#d4f0691d .cell execution_count=22}\n``` {.python .cell-code}\n# Filter consecutive duplicates\ndef remove_consecutive_duplicates(iterable):\n    return [key for key, _ in itertools.groupby(iterable)]\n\ndata = [1, 1, 2, 2, 2, 3, 1, 1, 1, 4]\nresult = remove_consecutive_duplicates(data)\nprint(result)  # [1, 2, 3, 1, 4]\n\n# Filter with multiple conditions\nnumbers = range(1, 21)\n# Even numbers not divisible by 4\nfiltered = itertools.filterfalse(\n    lambda x: x % 2 != 0 or x % 4 == 0, numbers\n)\nprint(list(filtered))  # [2, 6, 10, 14, 18]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 1, 4]\n[2, 6, 10, 14, 18]\n```\n:::\n:::\n\n\n## Advanced Patterns and Recipes\n\n### Recipe: Flatten Nested Iterables\n\n::: {#a977f180 .cell execution_count=23}\n``` {.python .cell-code}\ndef flatten(nested_iterable):\n    \"\"\"Flatten one level of nesting.\"\"\"\n    return itertools.chain.from_iterable(nested_iterable)\n\n# Usage\nnested = [[1, 2], [3, 4], [5, 6]]\nflat = list(flatten(nested))\nprint(flat)  # [1, 2, 3, 4, 5, 6]\n\ndef deep_flatten(nested_iterable):\n    \"\"\"Recursively flatten deeply nested iterables.\"\"\"\n    for item in nested_iterable:\n        if hasattr(item, '__iter__') and not isinstance(item, (str, bytes)):\n            yield from deep_flatten(item)\n        else:\n            yield item\n\n# Usage\ndeeply_nested = [1, [2, [3, 4]], 5, [6, [7, [8, 9]]]]\nflat = list(deep_flatten(deeply_nested))\nprint(flat)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\n### Recipe: Sliding Window\n\n::: {#9803599b .cell execution_count=24}\n``` {.python .cell-code}\ndef sliding_window(iterable, n):\n    \"\"\"Create a sliding window of size n.\"\"\"\n    iterators = itertools.tee(iterable, n)\n    for i, it in enumerate(iterators):\n        # Advance each iterator by i positions\n        for _ in range(i):\n            next(it, None)\n    return zip(*iterators)\n\n# Usage\ndata = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nwindows = list(sliding_window(data, 3))\nprint(windows)  # [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, 7), (6, 7, 8), (7, 8, 9), (8, 9, 10)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, 7), (6, 7, 8), (7, 8, 9), (8, 9, 10)]\n```\n:::\n:::\n\n\n### Recipe: Roundrobin\n\n::: {#c6f79066 .cell execution_count=25}\n``` {.python .cell-code}\ndef roundrobin(*iterables):\n    \"\"\"Take elements from iterables in round-robin fashion.\"\"\"\n    iterators = [iter(it) for it in iterables]\n    while iterators:\n        for it in iterators[:]:\n            try:\n                yield next(it)\n            except StopIteration:\n                iterators.remove(it)\n\n# Usage\nresult = list(roundrobin('ABC', '12345', 'xyz'))\nprint(result)  # ['A', '1', 'x', 'B', '2', 'y', 'C', '3', 'z', '4', '5']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['A', '1', 'x', 'B', '2', 'y', 'C', '3', 'z', '4', '5']\n```\n:::\n:::\n\n\n### Recipe: Unique Elements (Preserving Order)\n\n::: {#0d19a2a9 .cell execution_count=26}\n``` {.python .cell-code}\ndef unique_everseen(iterable, key=None):\n    \"\"\"List unique elements, preserving order.\"\"\"\n    seen = set()\n    seen_add = seen.add\n    if key is None:\n        for element in itertools.filterfalse(seen.__contains__, iterable):\n            seen_add(element)\n            yield element\n    else:\n        for element in iterable:\n            k = key(element)\n            if k not in seen:\n                seen_add(k)\n                yield element\n\n# Usage\ndata = [1, 2, 3, 2, 4, 1, 5, 3, 6]\nunique = list(unique_everseen(data))\nprint(unique)  # [1, 2, 3, 4, 5, 6]\n\n# With key function\nwords = ['apple', 'Banana', 'cherry', 'Apple', 'banana']\nunique_words = list(unique_everseen(words, key=str.lower))\nprint(unique_words)  # ['apple', 'Banana', 'cherry']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6]\n['apple', 'Banana', 'cherry']\n```\n:::\n:::\n\n\n---\n\n## Practical Examples and Use Cases\n\n### 1. Data Processing Pipeline\n\n::: {#2c21e6ed .cell execution_count=27}\n``` {.python .cell-code}\nimport itertools\nimport operator\n\n# Sample data\nsales_data = [\n    ('Q1', 'Product A', 100),\n    ('Q1', 'Product B', 150),\n    ('Q2', 'Product A', 120),\n    ('Q2', 'Product B', 180),\n    ('Q3', 'Product A', 110),\n    ('Q3', 'Product B', 160),\n]\n\n# Group by quarter and calculate totals\nsales_by_quarter = itertools.groupby(sales_data, key=lambda x: x[0])\n\nfor quarter, sales in sales_by_quarter:\n    total = sum(sale[2] for sale in sales)\n    print(f\"{quarter}: {total}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nQ1: 250\nQ2: 300\nQ3: 270\n```\n:::\n:::\n\n\n### 2. Batch Processing\n\n::: {#31cd6867 .cell execution_count=28}\n``` {.python .cell-code}\ndef batch_process(iterable, batch_size):\n    \"\"\"Process items in batches\"\"\"\n    iterator = iter(iterable)\n    while True:\n        batch = list(itertools.islice(iterator, batch_size))\n        if not batch:\n            break\n        yield batch\n\n# Example usage\ndata = range(25)\nfor batch in batch_process(data, 10):\n    print(f\"Processing batch: {batch}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProcessing batch: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nProcessing batch: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\nProcessing batch: [20, 21, 22, 23, 24]\n```\n:::\n:::\n\n\n### 3. Round-Robin Scheduler\n\n::: {#94ee84d0 .cell execution_count=29}\n``` {.python .cell-code}\ndef round_robin_scheduler(tasks, workers):\n    \"\"\"Distribute tasks among workers in round-robin fashion\"\"\"\n    worker_cycle = itertools.cycle(workers)\n    return list(zip(tasks, worker_cycle))\n\ntasks = ['task1', 'task2', 'task3', 'task4', 'task5']\nworkers = ['Alice', 'Bob', 'Charlie']\n\nschedule = round_robin_scheduler(tasks, workers)\nfor task, worker in schedule:\n    print(f\"{task} -> {worker}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntask1 -> Alice\ntask2 -> Bob\ntask3 -> Charlie\ntask4 -> Alice\ntask5 -> Bob\n```\n:::\n:::\n\n\n### 4. Sliding Window\n\n::: {#fed1029e .cell execution_count=30}\n``` {.python .cell-code}\ndef sliding_window(iterable, window_size):\n    \"\"\"Create sliding window of specified size\"\"\"\n    iterators = itertools.tee(iterable, window_size)\n    iterators = [itertools.islice(iterator, i, None) \n                for i, iterator in enumerate(iterators)]\n    return zip(*iterators)\n\n# Example usage\ndata = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nwindows = sliding_window(data, 3)\nfor window in windows:\n    print(window)\n# (1, 2, 3)\n# (2, 3, 4)\n# (3, 4, 5)\n# ...\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, 2, 3)\n(2, 3, 4)\n(3, 4, 5)\n(4, 5, 6)\n(5, 6, 7)\n(6, 7, 8)\n(7, 8, 9)\n(8, 9, 10)\n```\n:::\n:::\n\n\n### 5. Pairwise Iteration\n\n::: {#5d54c14c .cell execution_count=31}\n``` {.python .cell-code}\ndef pairwise(iterable):\n    \"\"\"Return successive overlapping pairs\"\"\"\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return zip(a, b)\n\n# Example usage\nnumbers = [1, 2, 3, 4, 5]\npairs = pairwise(numbers)\nfor pair in pairs:\n    print(pair)\n# (1, 2)\n# (2, 3)\n# (3, 4)\n# (4, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, 2)\n(2, 3)\n(3, 4)\n(4, 5)\n```\n:::\n:::\n\n\n---\n\n## Performance Tips\n\n### 1. Memory Efficiency\n\n::: {#4741ecba .cell execution_count=32}\n``` {.python .cell-code}\n# Bad: Creates entire list in memory\nlarge_range = list(range(1000000))\nsquared = [x**2 for x in large_range]\n\n# Good: Uses iterators\nlarge_range = range(1000000)\nsquared = map(lambda x: x**2, large_range)\n```\n:::\n\n\n### 2. Lazy Evaluation\n\n::: {#c161b33d .cell execution_count=33}\n``` {.python .cell-code}\n# Itertools functions are lazy - they don't compute until needed\ndata = range(1000000)\nfiltered = itertools.filterfalse(lambda x: x % 2 == 0, data)\n# No computation happens here yet\n\n# Only compute what you need\nfirst_10_odds = list(itertools.islice(filtered, 10))\n```\n:::\n\n\n### 3. Chaining Operations\n\n::: {#46bdd5a4 .cell execution_count=34}\n``` {.python .cell-code}\n# Chain multiple itertools operations for complex processing\ndata = range(100)\nresult = itertools.takewhile(\n    lambda x: x < 50,\n    itertools.filterfalse(\n        lambda x: x % 3 == 0,\n        itertools.accumulate(data)\n    )\n)\n```\n:::\n\n\n---\n\n## Common Patterns and Recipes\n\n### 1. Flatten Nested Iterables\n\n::: {#d7c7bf16 .cell execution_count=35}\n``` {.python .cell-code}\ndef flatten(nested_iterable):\n    \"\"\"Completely flatten a nested iterable\"\"\"\n    for item in nested_iterable:\n        if hasattr(item, '__iter__') and not isinstance(item, (str, bytes)):\n            yield from flatten(item)\n        else:\n            yield item\n\n# Example\nnested = [1, [2, 3], [4, [5, 6]], 7]\nprint(list(flatten(nested)))  # [1, 2, 3, 4, 5, 6, 7]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, 7]\n```\n:::\n:::\n\n\n### 2. Unique Elements (Preserving Order)\n\n::: {#8b64cfb1 .cell execution_count=36}\n``` {.python .cell-code}\ndef unique_everseen(iterable, key=None):\n    \"\"\"List unique elements, preserving order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    if key is None:\n        for element in itertools.filterfalse(seen.__contains__, iterable):\n            seen_add(element)\n            yield element\n    else:\n        for element in iterable:\n            k = key(element)\n            if k not in seen:\n                seen_add(k)\n                yield element\n\n# Example\ndata = [1, 2, 3, 2, 1, 4, 3, 5]\nprint(list(unique_everseen(data)))  # [1, 2, 3, 4, 5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5]\n```\n:::\n:::\n\n\n### 3. Consume Iterator\n\n::: {#3f2d211a .cell execution_count=37}\n``` {.python .cell-code}\ndef consume(iterator, n=None):\n    \"\"\"Advance the iterator n-steps ahead. If n is None, consume entirely.\"\"\"\n    if n is None:\n        # feed the entire iterator into a zero-length deque\n        collections.deque(iterator, maxlen=0)\n    else:\n        # advance to the empty slice starting at position n\n        next(itertools.islice(iterator, n, n), None)\n```\n:::\n\n\n---\n\n## Real-World Examples\n\n### Example 1: Data Processing Pipeline\n\n```python\n# Processing CSV-like data\ndef process_sales_data(data):\n    \"\"\"Process sales data with itertools.\"\"\"\n    # Filter out header and empty lines\n    clean_data = itertools.filterfalse(\n        lambda x: x.startswith('Date') or not x.strip(), \n        data\n    )\n    \n    # Parse each line\n    parsed = (line.split(',') for line in clean_data)\n    \n    # Group by month\n    by_month = itertools.groupby(\n        sorted(parsed, key=lambda x: x[0][:7]),  # Sort by year-month\n        key=lambda x: x[0][:7]\n    )\n    \n    # Calculate monthly totals\n    monthly_totals = {}\n    for month, sales in by_month:\n        total = sum(float(sale[2]) for sale in sales)\n        monthly_totals[month] = total\n    \n    return monthly_totals\n\n# Sample data\nsales_data = [\n    \"Date,Product,Amount\",\n    \"2023-01-15,Widget,100.50\",\n    \"2023-01-20,Gadget,75.25\",\n    \"2023-02-10,Widget,120.00\",\n    \"2023-02-15,Gadget,85.75\",\n    \"\",\n    \"2023-01-25,Widget,95.00\"\n]\n\nresult = process_sales_data(sales_data)\nprint(result)\n```\n\n### Example 2: Configuration Generator\n\n```python\n# Generate all possible configurations\ndef generate_configurations(options):\n    \"\"\"Generate all possible configuration combinations.\"\"\"\n    keys = list(options.keys())\n    values = list(options.values())\n    \n    for combo in itertools.product(*values):\n        yield dict(zip(keys, combo))\n\n# Usage\nserver_options = {\n    'cpu': ['2-core', '4-core', '8-core'],\n    'memory': ['4GB', '8GB', '16GB'],\n    'storage': ['SSD', 'HDD'],\n    'os': ['Linux', 'Windows']\n}\n\nconfigs = list(generate_configurations(server_options))\nprint(f\"Total configurations: {len(configs)}\")\nfor config in configs[:3]:  # Show first 3\n    print(config)\n```\n\n### Example 3: Batch Processing\n\n```python\ndef batch_process(items, batch_size, process_func):\n    \"\"\"Process items in batches.\"\"\"\n    iterator = iter(items)\n    while True:\n        batch = list(itertools.islice(iterator, batch_size))\n        if not batch:\n            break\n        yield process_func(batch)\n\ndef sum_batch(batch):\n    return sum(batch)\n\n# Usage\nlarge_numbers = range(1000)\nbatch_sums = list(batch_process(large_numbers, 100, sum_batch))\nprint(f\"Batch sums: {batch_sums[:5]}...\")  # Show first 5 batch sums\n```\n\n---\n\n## Best Practices\n\n1. **Use itertools for memory-efficient processing**: When working with large datasets, itertools can help avoid loading everything into memory.\n2. **Combine with other functional programming tools**: itertools works well with `map()`, `filter()`, and `functools.reduce()`.\n3. **Remember lazy evaluation**: Most itertools functions return iterators, not lists. Use `list()` when you need to materialize the results.\n4. **Profile your code**: While itertools is generally efficient, measure performance for your specific use case.\n5. **Consider readability**: Sometimes a simple loop is clearer than a complex itertools chain.\n6. **Use type hints**: When writing functions that use itertools, consider adding type hints for better code documentation.\n7. **Sort before grouping**: `groupby()` only groups consecutive identical elements, so sort your data first if needed.\n8. **Use `tee()` carefully**: Each iterator from `tee()` maintains its own internal buffer, which can consume significant memory if iterators advance at different rates.\n9. **Profile your code**: For performance-critical applications, measure whether itertools or other approaches (like NumPy) are faster for your specific use case.\n\n---\n\n## Conclusion\n\nThe itertools module provides powerful tools for creating efficient, memory-friendly iterators. By mastering these functions, you can write more elegant and performant Python code, especially when dealing with large datasets or complex iteration patterns. The key is understanding when and how to use each function effectively in your specific use cases.\n\nRemember that itertools excels at functional programming patterns and can often replace complex loops with more readable and efficient iterator chains. Practice with these examples and experiment with combining different itertools functions to solve your specific problems.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}