{
  "hash": "a4782e6fc0001166f529e63acff580ce",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Complete Guide to Python's functools Module\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-07-06\"\ncategories: [code, tutorial, beginner]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# Complete Guide to Python's functools Module\n![](func.png)\n\nThe `functools` module in Python provides utilities for working with higher-order functions and operations on callable objects. It's a powerful toolkit for functional programming patterns, performance optimization, and code organization.\n\n\n## Introduction\n\nThe `functools` module is part of Python's standard library and provides essential tools for functional programming. It helps you create more efficient, reusable, and maintainable code by offering utilities for function manipulation, caching, and composition. It's particularly useful for:\n\n- Creating decorators\n- Implementing caching mechanisms\n- Partial function application\n- Functional programming patterns\n- Performance optimization\n\n::: {#fbb8a071 .cell execution_count=1}\n``` {.python .cell-code}\nimport functools\n```\n:::\n\n\n## Core Decorators\n\n### @functools.wraps\n\nThe `@functools.wraps` decorator is fundamental for creating proper decorators. It copies metadata from the original function to the wrapper function, preserving important attributes like `__name__`, `__doc__`, and `__module__`.\n\n::: {#1d181870 .cell execution_count=2}\n``` {.python .cell-code}\nimport functools\n\ndef my_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@my_decorator\ndef greet(name):\n    \"\"\"Greet someone by name.\"\"\"\n    return f\"Hello, {name}!\"\n\nprint(greet.__name__)  # Output: greet\nprint(greet.__doc__)   # Output: Greet someone by name.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngreet\nGreet someone by name.\n```\n:::\n:::\n\n\nWithout `@functools.wraps`, the wrapper function would lose the original function's metadata:\n\n::: {#0991224a .cell execution_count=3}\n``` {.python .cell-code}\ndef bad_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(f\"Calling function\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@bad_decorator\ndef say_hello(name):\n    \"\"\"Say hello to someone.\"\"\"\n    return f\"Hello, {name}!\"\n\nprint(say_hello.__name__)  # Output: wrapper (not say_hello!)\nprint(say_hello.__doc__)   # Output: None\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwrapper\nNone\n```\n:::\n:::\n\n\n### @functools.lru_cache\n\nThe `@functools.lru_cache` decorator implements a Least Recently Used (LRU) cache for function results. It's excellent for optimizing recursive functions and expensive computations.\n\n::: {#2311efaa .cell execution_count=4}\n``` {.python .cell-code}\nimport functools\n\n@functools.lru_cache(maxsize=128)\ndef fibonacci(n):\n    \"\"\"Calculate Fibonacci number with memoization.\"\"\"\n    if n < 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\n# Performance comparison\nimport time\n\ndef fibonacci_slow(n):\n    \"\"\"Fibonacci without caching.\"\"\"\n    if n < 2:\n        return n\n    return fibonacci_slow(n - 1) + fibonacci_slow(n - 2)\n\n# Cached version\nstart = time.time()\nresult_fast = fibonacci(35)\nfast_time = time.time() - start\n\n# Clear cache and test uncached version\nfibonacci.cache_clear()\nstart = time.time()\nresult_slow = fibonacci_slow(35)\nslow_time = time.time() - start\n\nprint(f\"Cached result: {result_fast} (Time: {fast_time:.4f}s)\")\nprint(f\"Uncached result: {result_slow} (Time: {slow_time:.4f}s)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCached result: 9227465 (Time: 0.0000s)\nUncached result: 9227465 (Time: 0.6494s)\n```\n:::\n:::\n\n\n#### Cache Management\n\nThe `lru_cache` decorator provides methods for cache management:\n\n::: {#7cd1a617 .cell execution_count=5}\n``` {.python .cell-code}\n@functools.lru_cache(maxsize=128)\ndef expensive_function(x, y):\n    \"\"\"Simulate an expensive computation.\"\"\"\n    time.sleep(0.1)  # Simulate work\n    return x * y + x ** y\n\n# Use the function\nresult1 = expensive_function(2, 3)\nresult2 = expensive_function(2, 3)  # This will be cached\n\n# Check cache statistics\nprint(expensive_function.cache_info())\n# Output: CacheInfo(hits=1, misses=1, maxsize=128, currsize=1)\n\n# Clear the cache\nexpensive_function.cache_clear()\nprint(expensive_function.cache_info())\n# Output: CacheInfo(hits=0, misses=0, maxsize=128, currsize=0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCacheInfo(hits=1, misses=1, maxsize=128, currsize=1)\nCacheInfo(hits=0, misses=0, maxsize=128, currsize=0)\n```\n:::\n:::\n\n\n### @functools.cache (Python 3.9+)\n\nThe `@functools.cache` decorator is a simplified version of `lru_cache` with no size limit:\n\n::: {#6e76dd7c .cell execution_count=6}\n``` {.python .cell-code}\nimport functools\n\n@functools.cache\ndef factorial(n):\n    \"\"\"Calculate factorial with unlimited caching.\"\"\"\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(10))  # 3628800\nprint(factorial.cache_info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3628800\nCacheInfo(hits=0, misses=10, maxsize=None, currsize=10)\n```\n:::\n:::\n\n\n### @functools.cached_property\n\nTransforms a method into a property that caches its result after the first call.\n\n::: {#5462cc80 .cell execution_count=7}\n``` {.python .cell-code}\nimport functools\nimport time\n\nclass DataProcessor:\n    def __init__(self, data):\n        self.data = data\n    \n    @functools.cached_property\n    def processed_data(self):\n        \"\"\"Expensive data processing that should only run once\"\"\"\n        print(\"Processing data...\")\n        time.sleep(1)  # Simulate expensive operation\n        return [x * 2 for x in self.data]\n\nprocessor = DataProcessor([1, 2, 3, 4, 5])\nprint(processor.processed_data)  # Takes 1 second\nprint(processor.processed_data)  # Instant, uses cached result\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProcessing data...\n[2, 4, 6, 8, 10]\n[2, 4, 6, 8, 10]\n```\n:::\n:::\n\n\n## Partial Function Application\n\n### functools.partial\n\nThe `functools.partial` function creates partial function applications, allowing you to fix certain arguments of a function and create a new callable.\n\n::: {#bea1b9ad .cell execution_count=8}\n``` {.python .cell-code}\nimport functools\n\ndef multiply(x, y, z):\n    \"\"\"Multiply three numbers.\"\"\"\n    return x * y * z\n\n# Create a partial function that always multiplies by 2 and 3\ndouble_triple = functools.partial(multiply, 2, 3)\n\nprint(double_triple(4))  # Output: 24 (2 * 3 * 4)\n\n# You can also fix keyword arguments\ndef greet(greeting, name, punctuation=\"!\"):\n    return f\"{greeting}, {name}{punctuation}\"\n\n# Create a partial for casual greetings\ncasual_greet = functools.partial(greet, \"Hey\", punctuation=\".\")\n\nprint(casual_greet(\"Alice\"))  # Output: Hey, Alice.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n24\nHey, Alice.\n```\n:::\n:::\n\n\n### Practical Example: Event Handling\n\n::: {#b3a3549f .cell execution_count=9}\n``` {.python .cell-code}\nimport functools\n\ndef handle_event(event_type, handler_name, data):\n    \"\"\"Generic event handler.\"\"\"\n    print(f\"[{event_type}] {handler_name}: {data}\")\n\n# Create specific event handlers\nhandle_click = functools.partial(handle_event, \"CLICK\")\nhandle_keypress = functools.partial(handle_event, \"KEYPRESS\")\n\n# Use the handlers\nbutton_click = functools.partial(handle_click, \"button_handler\")\ninput_keypress = functools.partial(handle_keypress, \"input_handler\")\n\nbutton_click(\"Button was clicked\")\ninput_keypress(\"Enter key pressed\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[CLICK] button_handler: Button was clicked\n[KEYPRESS] input_handler: Enter key pressed\n```\n:::\n:::\n\n\n### functools.partialmethod\n\nThe `functools.partialmethod` is designed for creating partial methods in classes:\n\n::: {#00b03c8a .cell execution_count=10}\n``` {.python .cell-code}\nimport functools\n\nclass Calculator:\n    def __init__(self):\n        self.result = 0\n    \n    def operation(self, op, value):\n        if op == \"add\":\n            self.result += value\n        elif op == \"multiply\":\n            self.result *= value\n        elif op == \"subtract\":\n            self.result -= value\n        return self.result\n    \n    # Create partial methods\n    add = functools.partialmethod(operation, \"add\")\n    multiply = functools.partialmethod(operation, \"multiply\")\n    subtract = functools.partialmethod(operation, \"subtract\")\n\ncalc = Calculator()\ncalc.add(5)        # result = 5\ncalc.multiply(3)   # result = 15\ncalc.subtract(2)   # result = 13\nprint(calc.result) # Output: 13\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13\n```\n:::\n:::\n\n\n## Comparison and Ordering\n\n### functools.total_ordering\n\nThe `@functools.total_ordering` decorator automatically generates comparison methods based on `__eq__` and one ordering method:\n\n::: {#780ab607 .cell execution_count=11}\n``` {.python .cell-code}\nimport functools\n\n@functools.total_ordering\nclass Student:\n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade\n    \n    def __eq__(self, other):\n        if not isinstance(other, Student):\n            return NotImplemented\n        return self.grade == other.grade\n    \n    def __lt__(self, other):\n        if not isinstance(other, Student):\n            return NotImplemented\n        return self.grade < other.grade\n    \n    def __repr__(self):\n        return f\"Student('{self.name}', {self.grade})\"\n\n# Now all comparison operators work\nalice = Student(\"Alice\", 85)\nbob = Student(\"Bob\", 92)\ncharlie = Student(\"Charlie\", 85)\n\nprint(alice < bob)      # True\nprint(alice > bob)      # False\nprint(alice <= bob)     # True\nprint(alice >= bob)     # False\nprint(alice == charlie) # True\nprint(alice != bob)     # True\n\n# Sorting works too\nstudents = [bob, alice, charlie]\nstudents.sort()\nprint(students)  # [Student('Alice', 85), Student('Charlie', 85), Student('Bob', 92)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\n[Student('Alice', 85), Student('Charlie', 85), Student('Bob', 92)]\n```\n:::\n:::\n\n\n### functools.cmp_to_key\n\nThe `functools.cmp_to_key` function converts old-style comparison functions to key functions for use with sorting:\n\n::: {#268d045e .cell execution_count=12}\n``` {.python .cell-code}\nimport functools\n\ndef compare_strings(a, b):\n    \"\"\"Old-style comparison function.\"\"\"\n    # Compare by length first, then alphabetically\n    if len(a) != len(b):\n        return len(a) - len(b)\n    if a < b:\n        return -1\n    elif a > b:\n        return 1\n    return 0\n\n# Convert to key function\nkey_func = functools.cmp_to_key(compare_strings)\n\nwords = [\"apple\", \"pie\", \"banana\", \"cat\", \"elephant\"]\nsorted_words = sorted(words, key=key_func)\nprint(sorted_words)  # ['cat', 'pie', 'apple', 'banana', 'elephant']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['cat', 'pie', 'apple', 'banana', 'elephant']\n```\n:::\n:::\n\n\n## Caching and Memoization\n\n### Advanced Caching Strategies\n\n::: {#55f25ae8 .cell execution_count=13}\n``` {.python .cell-code}\nimport functools\nimport time\nfrom typing import Any, Callable\n\ndef timed_cache(seconds: int):\n    \"\"\"Custom decorator for time-based caching.\"\"\"\n    def decorator(func: Callable) -> Callable:\n        cache = {}\n        \n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            # Create a key from arguments\n            key = str(args) + str(sorted(kwargs.items()))\n            current_time = time.time()\n            \n            # Check if result is cached and still valid\n            if key in cache:\n                result, timestamp = cache[key]\n                if current_time - timestamp < seconds:\n                    return result\n            \n            # Calculate new result and cache it\n            result = func(*args, **kwargs)\n            cache[key] = (result, current_time)\n            return result\n        \n        return wrapper\n    return decorator\n\n@timed_cache(seconds=5)\ndef get_current_time():\n    \"\"\"Get current time (cached for 5 seconds).\"\"\"\n    return time.time()\n\n# Test the timed cache\nprint(get_current_time())  # Fresh calculation\ntime.sleep(2)\nprint(get_current_time())  # Cached result (same as above)\ntime.sleep(4)\nprint(get_current_time())  # Fresh calculation (cache expired)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1751944700.021502\n1751944700.021502\n1751944706.03497\n```\n:::\n:::\n\n\n### Cache with Custom Key Function\n\n::: {#1e0b9da9 .cell execution_count=14}\n``` {.python .cell-code}\nimport functools\n\ndef custom_cache(key_func=None):\n    \"\"\"Cache decorator with custom key function.\"\"\"\n    def decorator(func):\n        cache = {}\n        \n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            if key_func:\n                key = key_func(*args, **kwargs)\n            else:\n                key = str(args) + str(sorted(kwargs.items()))\n            \n            if key in cache:\n                return cache[key]\n            \n            result = func(*args, **kwargs)\n            cache[key] = result\n            return result\n        \n        wrapper.cache_clear = cache.clear\n        wrapper.cache_info = lambda: f\"Cache size: {len(cache)}\"\n        return wrapper\n    return decorator\n\n# Example: Cache based on first argument only\n@custom_cache(key_func=lambda x, y: x)\ndef expensive_computation(x, y):\n    \"\"\"Expensive computation cached by first argument only.\"\"\"\n    print(f\"Computing for {x}, {y}\")\n    return x ** y\n\nprint(expensive_computation(2, 3))  # Computing for 2, 3 -> 8\nprint(expensive_computation(2, 5))  # Uses cached result -> 8 (wrong but demonstrates key function)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nComputing for 2, 3\n8\n8\n```\n:::\n:::\n\n\n## Function Composition\n\n### functools.reduce\n\nThe `functools.reduce` function applies a function cumulatively to items in a sequence:\n\n::: {#22c835e0 .cell execution_count=15}\n``` {.python .cell-code}\nimport functools\nimport operator\n\n# Sum all numbers\nnumbers = [1, 2, 3, 4, 5]\ntotal = functools.reduce(operator.add, numbers)\nprint(total)  # Output: 15\n\n# Find maximum\nmaximum = functools.reduce(lambda x, y: x if x > y else y, numbers)\nprint(maximum)  # Output: 5\n\n# Multiply all numbers\nproduct = functools.reduce(operator.mul, numbers)\nprint(product)  # Output: 120\n\n# Flatten nested lists\nnested_lists = [[1, 2], [3, 4], [5, 6]]\nflattened = functools.reduce(operator.add, nested_lists)\nprint(flattened)  # Output: [1, 2, 3, 4, 5, 6]\n\n# With initial value\nresult = functools.reduce(operator.add, numbers, 100)\nprint(result)  # Output: 115 (100 + 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n15\n5\n120\n[1, 2, 3, 4, 5, 6]\n115\n```\n:::\n:::\n\n\n### Building Complex Operations\n\n::: {#34ce93fb .cell execution_count=16}\n``` {.python .cell-code}\nimport functools\nimport operator\n\ndef compose(*functions):\n    \"\"\"Compose multiple functions into a single function.\"\"\"\n    return functools.reduce(lambda f, g: lambda x: f(g(x)), functions, lambda x: x)\n\n# Example functions\ndef add_one(x):\n    return x + 1\n\ndef multiply_by_two(x):\n    return x * 2\n\ndef square(x):\n    return x ** 2\n\n# Compose functions\ncomposed = compose(square, multiply_by_two, add_one)\nprint(composed(3))  # ((3 + 1) * 2) ** 2 = 64\n\n# Dictionary operations with reduce\ndef merge_dicts(*dicts):\n    \"\"\"Merge multiple dictionaries.\"\"\"\n    return functools.reduce(\n        lambda acc, d: {**acc, **d}, \n        dicts, \n        {}\n    )\n\ndict1 = {\"a\": 1, \"b\": 2}\ndict2 = {\"c\": 3, \"d\": 4}\ndict3 = {\"e\": 5, \"f\": 6}\n\nmerged = merge_dicts(dict1, dict2, dict3)\nprint(merged)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n64\n{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}\n```\n:::\n:::\n\n\n## Advanced Usage Patterns\n\n### Decorator Factories\n\n::: {#e2734763 .cell execution_count=17}\n``` {.python .cell-code}\nimport functools\nimport time\n\ndef retry(max_attempts=3, delay=1):\n    \"\"\"Decorator factory for retrying failed operations.\"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    if attempt == max_attempts - 1:\n                        raise e\n                    print(f\"Attempt {attempt + 1} failed: {e}. Retrying in {delay}s...\")\n                    time.sleep(delay)\n            return None\n        return wrapper\n    return decorator\n\n@retry(max_attempts=3, delay=0.5)\ndef unreliable_function():\n    \"\"\"Function that fails randomly.\"\"\"\n    import random\n    if random.random() < 0.7:\n        raise Exception(\"Random failure\")\n    return \"Success!\"\n\n# Test the retry decorator\n# result = unreliable_function()  # May retry up to 3 times\n```\n:::\n\n\n### Method Decorators\n\n::: {#f533d71e .cell execution_count=18}\n``` {.python .cell-code}\nimport functools\n\nclass ValidationError(Exception):\n    pass\n\ndef validate_positive(func):\n    \"\"\"Decorator to validate that arguments are positive.\"\"\"\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        for arg in args:\n            if isinstance(arg, (int, float)) and arg <= 0:\n                raise ValidationError(f\"Argument {arg} must be positive\")\n        return func(self, *args, **kwargs)\n    return wrapper\n\nclass Calculator:\n    @validate_positive\n    def divide(self, a, b):\n        \"\"\"Divide two positive numbers.\"\"\"\n        return a / b\n    \n    @validate_positive\n    def sqrt(self, x):\n        \"\"\"Calculate square root of a positive number.\"\"\"\n        return x ** 0.5\n\ncalc = Calculator()\nprint(calc.divide(10, 2))  # 5.0\nprint(calc.sqrt(16))       # 4.0\n\n# This will raise ValidationError\n# calc.divide(-5, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.0\n4.0\n```\n:::\n:::\n\n\n### Contextual Decorators\n\n::: {#19bdcf69 .cell execution_count=19}\n``` {.python .cell-code}\nimport functools\nimport logging\n\ndef log_calls(logger=None, level=logging.INFO):\n    \"\"\"Decorator to log function calls.\"\"\"\n    if logger is None:\n        logger = logging.getLogger(__name__)\n    \n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            logger.log(level, f\"Calling {func.__name__} with args={args}, kwargs={kwargs}\")\n            try:\n                result = func(*args, **kwargs)\n                logger.log(level, f\"{func.__name__} returned {result}\")\n                return result\n            except Exception as e:\n                logger.log(logging.ERROR, f\"{func.__name__} raised {type(e).__name__}: {e}\")\n                raise\n        return wrapper\n    return decorator\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO)\n\n@log_calls()\ndef calculate_area(width, height):\n    \"\"\"Calculate area of a rectangle.\"\"\"\n    return width * height\n\n@log_calls(level=logging.DEBUG)\ndef divide_numbers(a, b):\n    \"\"\"Divide two numbers.\"\"\"\n    return a / b\n\n# Test the logged functions\nresult = calculate_area(5, 3)\n# result = divide_numbers(10, 0)  # This will log an error\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nINFO:__main__:Calling calculate_area with args=(5, 3), kwargs={}\nINFO:__main__:calculate_area returned 15\n```\n:::\n:::\n\n\n## Advanced Features\n\n### functools.singledispatch\n\nCreates generic functions that behave differently based on the type of their first argument.\n\n::: {#88edf44e .cell execution_count=20}\n``` {.python .cell-code}\nimport functools\n\n@functools.singledispatch\ndef process_data(data):\n    \"\"\"Default implementation for unknown types\"\"\"\n    return f\"Processing unknown type: {type(data)}\"\n\n@process_data.register(str)\ndef _(data):\n    return f\"Processing string: '{data}'\"\n\n@process_data.register(list)\ndef _(data):\n    return f\"Processing list of {len(data)} items\"\n\n@process_data.register(dict)\ndef _(data):\n    return f\"Processing dict with keys: {list(data.keys())}\"\n\n@process_data.register(int)\n@process_data.register(float)\ndef _(data):\n    return f\"Processing number: {data}\"\n\n# Usage\nprint(process_data(\"hello\"))           # Processing string: 'hello'\nprint(process_data([1, 2, 3]))         # Processing list of 3 items\nprint(process_data({\"a\": 1, \"b\": 2}))  # Processing dict with keys: ['a', 'b']\nprint(process_data(42))                # Processing number: 42\nprint(process_data(3.14))              # Processing number: 3.14\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProcessing string: 'hello'\nProcessing list of 3 items\nProcessing dict with keys: ['a', 'b']\nProcessing number: 42\nProcessing number: 3.14\n```\n:::\n:::\n\n\n### functools.singledispatchmethod\n\nSimilar to singledispatch but for methods in classes.\n\n::: {#973e6256 .cell execution_count=21}\n``` {.python .cell-code}\nimport functools\n\nclass DataProcessor:\n    @functools.singledispatchmethod\n    def process(self, data):\n        return f\"Default processing for {type(data)}\"\n    \n    @process.register\n    def _(self, data: str):\n        return f\"String processing: {data.upper()}\"\n    \n    @process.register\n    def _(self, data: list):\n        return f\"List processing: {sum(data) if all(isinstance(x, (int, float)) for x in data) else 'mixed types'}\"\n    \n    @process.register\n    def _(self, data: dict):\n        return f\"Dict processing: {len(data)} items\"\n\nprocessor = DataProcessor()\nprint(processor.process(\"hello\"))      # String processing: HELLO\nprint(processor.process([1, 2, 3, 4])) # List processing: 10\nprint(processor.process({\"a\": 1}))     # Dict processing: 1 items\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nString processing: HELLO\nList processing: 10\nDict processing: 1 items\n```\n:::\n:::\n\n\n## Best Practices\n\n### 1. Use @functools.wraps in Custom Decorators\n\nAlways use `@functools.wraps` when creating decorators to preserve function metadata:\n\n::: {#ab5e7152 .cell execution_count=22}\n``` {.python .cell-code}\nimport functools\n\n# Good\ndef my_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # decorator logic here\n        return func(*args, **kwargs)\n    return wrapper\n\n# Bad - loses function metadata\ndef bad_decorator(func):\n    def wrapper(*args, **kwargs):\n        # decorator logic here\n        return func(*args, **kwargs)\n    return wrapper\n```\n:::\n\n\n### 2. Choose Appropriate Cache Sizes\n\nFor `lru_cache`, choose cache sizes based on your use case:\n\n::: {#d08b847e .cell execution_count=23}\n``` {.python .cell-code}\nimport functools\n\n# For small, frequently accessed data\n@functools.lru_cache(maxsize=32)\ndef get_user_preferences(user_id):\n    # Small cache for user data\n    pass\n\n# For larger datasets or expensive computations\n@functools.lru_cache(maxsize=1024)\ndef complex_calculation(x, y, z):\n    # Larger cache for expensive operations\n    pass\n\n# For unlimited caching (use with caution)\n@functools.cache\ndef constant_computation(x):\n    # Only for truly constant results\n    pass\n```\n:::\n\n\n### 3. Choose the Right Caching Strategy\n\n::: {#fdfa93e0 .cell execution_count=24}\n``` {.python .cell-code}\n# For simple cases without arguments\n@functools.cache\ndef simple_function():\n    pass\n\n# For functions with arguments and limited cache size\n@functools.lru_cache(maxsize=128)\ndef complex_function(x, y):\n    pass\n\n# For properties in classes\nclass MyClass:\n    @functools.cached_property\n    def expensive_property(self):\n        pass\n```\n:::\n\n\n### 4. Use Partial Functions for Configuration\n\n::: {#d636df27 .cell execution_count=25}\n``` {.python .cell-code}\nimport functools\nimport json\n\ndef make_api_call(base_url, endpoint, headers=None, timeout=30):\n    \"\"\"Make an API call with configurable parameters.\"\"\"\n    # Implementation here\n    pass\n\n# Create configured API callers\napi_v1 = functools.partial(\n    make_api_call,\n    base_url=\"https://api.example.com/v1\",\n    headers={\"Authorization\": \"Bearer token123\"}\n)\n\napi_v2 = functools.partial(\n    make_api_call,\n    base_url=\"https://api.example.com/v2\",\n    headers={\"Authorization\": \"Bearer token456\"},\n    timeout=60\n)\n\n# Use the configured functions\n# result1 = api_v1(\"/users\")\n# result2 = api_v2(\"/products\")\n```\n:::\n\n\n### 5. Performance Considerations\n\n::: {#a4318e99 .cell execution_count=26}\n``` {.python .cell-code}\nimport functools\nimport time\n\n# Measure cache performance\n@functools.lru_cache(maxsize=1000)\ndef expensive_function(n):\n    time.sleep(0.01)  # Simulate expensive operation\n    return n ** 2\n\n# Time uncached vs cached calls\nstart = time.time()\nfor i in range(100):\n    expensive_function(i % 10)  # Only 10 unique values\nend = time.time()\n\nprint(f\"Time taken: {end - start:.4f} seconds\")\nprint(f\"Cache info: {expensive_function.cache_info()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime taken: 0.1240 seconds\nCache info: CacheInfo(hits=90, misses=10, maxsize=1000, currsize=10)\n```\n:::\n:::\n\n\n### 6. Combine Multiple functools Features\n\n::: {#8b743258 .cell execution_count=27}\n``` {.python .cell-code}\nimport functools\nimport time\n\n@functools.lru_cache(maxsize=128)\ndef fibonacci_cached(n):\n    \"\"\"Fibonacci with caching.\"\"\"\n    if n < 2:\n        return n\n    return fibonacci_cached(n - 1) + fibonacci_cached(n - 2)\n\n# Create a partial function for specific range\nfibonacci_small = functools.partial(fibonacci_cached)\n\n# Use total_ordering for comparison\n@functools.total_ordering\nclass FibonacciNumber:\n    def __init__(self, n):\n        self.n = n\n        self.value = fibonacci_cached(n)\n    \n    def __eq__(self, other):\n        return self.value == other.value\n    \n    def __lt__(self, other):\n        return self.value < other.value\n    \n    def __repr__(self):\n        return f\"Fib({self.n}) = {self.value}\"\n\n# Example usage\nfib_numbers = [FibonacciNumber(i) for i in [8, 5, 10, 3]]\nfib_numbers.sort()\nprint(fib_numbers)  # Sorted by Fibonacci value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[Fib(3) = 2, Fib(5) = 5, Fib(8) = 21, Fib(10) = 55]\n```\n:::\n:::\n\n\n### 7. Error Handling with functools\n\n::: {#257c38de .cell execution_count=28}\n``` {.python .cell-code}\nimport functools\n\ndef safe_divide(func):\n    \"\"\"Decorator to handle division by zero.\"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except ZeroDivisionError:\n            print(f\"Warning: Division by zero in {func.__name__}\")\n            return float('inf')\n    return wrapper\n\n@safe_divide\ndef calculate_ratio(a, b):\n    \"\"\"Calculate the ratio of two numbers.\"\"\"\n    return a / b\n\nprint(calculate_ratio(10, 2))  # 5.0\nprint(calculate_ratio(10, 0))  # inf (with warning)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.0\nWarning: Division by zero in calculate_ratio\ninf\n```\n:::\n:::\n\n\n### 8. Debugging Cached Functions\n\n::: {#0f4b6c22 .cell execution_count=29}\n``` {.python .cell-code}\nimport functools\n\n@functools.lru_cache(maxsize=128)\ndef debug_function(x):\n    print(f\"Computing for {x}\")\n    return x * 2\n\n# Monitor cache usage\ndef print_cache_stats(func):\n    info = func.cache_info()\n    print(f\"Cache stats for {func.__name__}: {info}\")\n    hit_rate = info.hits / (info.hits + info.misses) if (info.hits + info.misses) > 0 else 0\n    print(f\"Hit rate: {hit_rate:.2%}\")\n\n# Usage\ndebug_function(5)\ndebug_function(5)  # Uses cache\ndebug_function(10)\nprint_cache_stats(debug_function)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nComputing for 5\nComputing for 10\nCache stats for debug_function: CacheInfo(hits=1, misses=2, maxsize=128, currsize=2)\nHit rate: 33.33%\n```\n:::\n:::\n\n\n## Conclusion\n\nThe `functools` module is an essential tool for Python developers who want to write more efficient, maintainable, and functional code. Key takeaways include:\n\n- Use `@functools.wraps` in all custom decorators\n- Leverage `@functools.lru_cache` for expensive function calls\n- Apply `functools.partial` for function configuration and specialization\n- Utilize `@functools.total_ordering` to reduce boilerplate in comparison classes\n- Employ `functools.reduce` for complex data transformations\n- Combine multiple functools features for powerful programming patterns\n- Apply `@cached_property` for expensive class properties\n- Use `partial` for function specialization\n- Implement `@singledispatch` for type-based function overloading\n\nBy mastering these tools, you'll be able to write more elegant and efficient Python code that follows functional programming principles while maintaining readability and performance.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}