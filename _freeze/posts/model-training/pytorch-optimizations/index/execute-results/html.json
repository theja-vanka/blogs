{
  "hash": "1a9af1f6bfc17fab5a81aa2f8b82dc44",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"PyTorch Training and Inference Optimization Guide\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-06-01\"\ncategories: [code, tutorial, intermediate]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# PyTorch Training and Inference Optimization Guide\n![](pytorch_workflow.png)\n\nThe guide includes practical code examples you can directly use in your projects, along with best practices and common pitfalls to avoid. Each section builds upon the previous ones, so you can implement these optimizations incrementally based on your specific needs and performance requirements.\n\n## General Optimization Principles\n\n### 1. Use the Right Data Types\n\n```python\nimport torch\n\n# Use half precision when possible (reduces memory and increases speed)\nmodel = model.half()  # Convert to float16\n# Or use mixed precision training\nfrom torch.cuda.amp import autocast, GradScaler\n\n# Use appropriate tensor types\nx = torch.tensor(data, dtype=torch.float32)  # Explicit dtype\n```\n\n### 2. Optimize Data Loading\n\n```python\nfrom torch.utils.data import DataLoader\nimport torch.multiprocessing as mp\n\n# Optimize DataLoader\ntrain_loader = DataLoader(\n    dataset,\n    batch_size=32,\n    shuffle=True,\n    num_workers=4,  # Use multiple workers\n    pin_memory=True,  # Faster GPU transfer\n    persistent_workers=True,  # Keep workers alive\n    prefetch_factor=2  # Prefetch batches\n)\n\n# Use non_blocking transfers\nfor batch in train_loader:\n    data = batch[0].to(device, non_blocking=True)\n    target = batch[1].to(device, non_blocking=True)\n```\n\n### 3. Tensor Operations Best Practices\n\n```python\n# Avoid unnecessary CPU-GPU transfers\nx = torch.randn(1000, 1000, device='cuda')  # Create directly on GPU\n\n# Use in-place operations when possible\nx.add_(y)  # Instead of x = x + y\nx.mul_(2)  # Instead of x = x * 2\n\n# Batch operations instead of loops\n# Bad\nfor i in range(batch_size):\n    result[i] = model(x[i])\n\n# Good\nresult = model(x)  # Process entire batch\n```\n\n## Training Optimizations\n\n### 1. Mixed Precision Training\n\n```python\nfrom torch.cuda.amp import autocast, GradScaler\n\nmodel = MyModel().cuda()\noptimizer = torch.optim.Adam(model.parameters())\nscaler = GradScaler()\n\nfor epoch in range(num_epochs):\n    for batch in train_loader:\n        optimizer.zero_grad()\n        \n        # Forward pass with autocast\n        with autocast():\n            outputs = model(inputs)\n            loss = criterion(outputs, targets)\n        \n        # Backward pass with gradient scaling\n        scaler.scale(loss).backward()\n        scaler.step(optimizer)\n        scaler.update()\n```\n\n### 2. Gradient Accumulation\n\n```python\naccumulation_steps = 4\noptimizer.zero_grad()\n\nfor i, batch in enumerate(train_loader):\n    with autocast():\n        outputs = model(inputs)\n        loss = criterion(outputs, targets) / accumulation_steps\n    \n    scaler.scale(loss).backward()\n    \n    if (i + 1) % accumulation_steps == 0:\n        scaler.step(optimizer)\n        scaler.update()\n        optimizer.zero_grad()\n```\n\n### 3. Efficient Learning Rate Scheduling\n\n```python\nfrom torch.optim.lr_scheduler import OneCycleLR\n\noptimizer = torch.optim.AdamW(model.parameters(), lr=0.001)\nscheduler = OneCycleLR(\n    optimizer,\n    max_lr=0.01,\n    epochs=num_epochs,\n    steps_per_epoch=len(train_loader)\n)\n\n# Use scheduler after each batch for OneCycleLR\nfor batch in train_loader:\n    # ... training step ...\n    scheduler.step()\n```\n\n### 4. Model Compilation (PyTorch 2.0+)\n\n```python\n# Compile model for faster training\nmodel = torch.compile(model)\n\n# Different modes for different use cases\nmodel = torch.compile(model, mode=\"reduce-overhead\")  # For large models\nmodel = torch.compile(model, mode=\"max-autotune\")     # For maximum performance\n```\n\n### 5. Checkpoint and Resume Training\n\n```python\ndef save_checkpoint(model, optimizer, epoch, loss, filename):\n    torch.save({\n        'epoch': epoch,\n        'model_state_dict': model.state_dict(),\n        'optimizer_state_dict': optimizer.state_dict(),\n        'loss': loss,\n    }, filename)\n\ndef load_checkpoint(model, optimizer, filename):\n    checkpoint = torch.load(filename)\n    model.load_state_dict(checkpoint['model_state_dict'])\n    optimizer.load_state_dict(checkpoint['optimizer_state_dict'])\n    return checkpoint['epoch'], checkpoint['loss']\n```\n\n## Inference Optimizations\n\n### 1. Model Optimization for Inference\n\n```python\n# Set model to evaluation mode\nmodel.eval()\n\n# Disable gradient computation\nwith torch.no_grad():\n    outputs = model(inputs)\n\n# Use torch.inference_mode() for even better performance\nwith torch.inference_mode():\n    outputs = model(inputs)\n```\n\n### 2. TorchScript Optimization\n\n```python\n# Trace the model\nexample_input = torch.randn(1, 3, 224, 224)\ntraced_model = torch.jit.trace(model, example_input)\n\n# Or script the model\nscripted_model = torch.jit.script(model)\n\n# Optimize the scripted model\noptimized_model = torch.jit.optimize_for_inference(scripted_model)\n\n# Save and load\ntorch.jit.save(optimized_model, \"optimized_model.pt\")\nloaded_model = torch.jit.load(\"optimized_model.pt\")\n```\n\n### 3. Quantization\n\n```python\nimport torch.quantization as quant\n\n# Post-training quantization\nmodel.eval()\nquantized_model = torch.quantization.quantize_dynamic(\n    model, {torch.nn.Linear}, dtype=torch.qint8\n)\n\n# Quantization-aware training\nmodel.train()\nmodel.qconfig = torch.quantization.get_default_qat_qconfig('fbgemm')\ntorch.quantization.prepare_qat(model, inplace=True)\n\n# Train the model...\n\n# Convert to quantized model\nquantized_model = torch.quantization.convert(model, inplace=False)\n```\n\n### 4. Batch Processing for Inference\n\n```python\ndef batch_inference(model, data_loader, device):\n    model.eval()\n    results = []\n    \n    with torch.inference_mode():\n        for batch in data_loader:\n            inputs = batch.to(device, non_blocking=True)\n            outputs = model(inputs)\n            results.append(outputs.cpu())\n    \n    return torch.cat(results, dim=0)\n```\n\n## Memory Management\n\n### 1. Memory Efficient Training\n\n```python\n# Clear unnecessary variables\ndel intermediate_results\ntorch.cuda.empty_cache()  # Free GPU memory\n\n# Use gradient checkpointing for large models\nfrom torch.utils.checkpoint import checkpoint\n\nclass MyModel(nn.Module):\n    def forward(self, x):\n        # Use checkpointing for memory-intensive layers\n        x = checkpoint(self.expensive_layer, x)\n        return x\n```\n\n### 2. Monitor Memory Usage\n\n```python\ndef print_memory_usage():\n    if torch.cuda.is_available():\n        print(f\"GPU memory allocated: {torch.cuda.memory_allocated() / 1e9:.2f} GB\")\n        print(f\"GPU memory cached: {torch.cuda.memory_reserved() / 1e9:.2f} GB\")\n\n# Monitor during training\nfor epoch in range(num_epochs):\n    for batch in train_loader:\n        # ... training code ...\n        if batch_idx % 100 == 0:\n            print_memory_usage()\n```\n\n### 3. Memory-Efficient Data Loading\n\n```python\nclass MemoryEfficientDataset(torch.utils.data.Dataset):\n    def __init__(self, data_paths):\n        self.data_paths = data_paths\n    \n    def __getitem__(self, idx):\n        # Load data on-demand instead of keeping in memory\n        data = self.load_data(self.data_paths[idx])\n        return data\n    \n    def __len__(self):\n        return len(self.data_paths)\n```\n\n## Hardware-Specific Optimizations\n\n### 1. GPU Optimizations\n\n```python\n# Set optimal GPU settings\ntorch.backends.cudnn.benchmark = True  # For fixed input sizes\ntorch.backends.cudnn.deterministic = False  # For reproducibility (slower)\n\n# Use multiple GPUs\nif torch.cuda.device_count() > 1:\n    model = nn.DataParallel(model)\n\n# Or use DistributedDataParallel for better performance\nfrom torch.nn.parallel import DistributedDataParallel as DDP\nmodel = DDP(model, device_ids=[local_rank])\n```\n\n### 2. CPU Optimizations\n\n```python\n# Set number of threads\ntorch.set_num_threads(4)\n\n# Use Intel MKL-DNN optimizations\ntorch.backends.mkldnn.enabled = True\n```\n\n### 3. Apple Silicon (MPS) Support\n\n```python\n# Use Metal Performance Shaders on Apple Silicon\nif torch.backends.mps.is_available():\n    device = torch.device(\"mps\")\n    model = model.to(device)\n```\n\n## Profiling and Debugging\n\n### 1. PyTorch Profiler\n\n```python\nfrom torch.profiler import profile, record_function, ProfilerActivity\n\nwith profile(\n    activities=[ProfilerActivity.CPU, ProfilerActivity.CUDA],\n    record_shapes=True,\n    profile_memory=True,\n    with_stack=True\n) as prof:\n    for batch in train_loader:\n        with record_function(\"forward\"):\n            outputs = model(inputs)\n        with record_function(\"backward\"):\n            loss.backward()\n        with record_function(\"optimizer\"):\n            optimizer.step()\n\n# Save trace for tensorboard\nprof.export_chrome_trace(\"trace.json\")\n```\n\n### 2. Memory Profiling\n\n```python\n# Profile memory usage\nwith profile(profile_memory=True) as prof:\n    model(inputs)\n\nprint(prof.key_averages().table(sort_by=\"self_cuda_memory_usage\", row_limit=10))\n```\n\n### 3. Speed Benchmarking\n\n```python\nimport time\n\ndef benchmark_model(model, input_tensor, num_runs=100):\n    model.eval()\n    \n    # Warmup\n    with torch.no_grad():\n        for _ in range(10):\n            _ = model(input_tensor)\n    \n    # Benchmark\n    torch.cuda.synchronize()\n    start_time = time.time()\n    \n    with torch.no_grad():\n        for _ in range(num_runs):\n            _ = model(input_tensor)\n    \n    torch.cuda.synchronize()\n    end_time = time.time()\n    \n    avg_time = (end_time - start_time) / num_runs\n    print(f\"Average inference time: {avg_time*1000:.2f} ms\")\n```\n\n## Best Practices Summary\n\n1. **Always profile first** - Identify bottlenecks before optimizing\n2. **Use mixed precision** - Significant speedup with minimal accuracy loss\n3. **Optimize data loading** - Use multiple workers and pin memory\n4. **Batch operations** - Avoid loops over individual samples\n5. **Model compilation** - Use `torch.compile()` for PyTorch 2.0+\n6. **Memory management** - Monitor and optimize memory usage\n7. **Hardware utilization** - Use all available compute resources\n8. **Quantization for inference** - Reduce model size and increase speed\n9. **TorchScript for production** - Better performance and deployment options\n10. **Regular checkpointing** - Save training progress and enable resumption\n\n## Common Pitfalls to Avoid\n\n- Moving tensors between CPU and GPU unnecessarily\n- Using small batch sizes that underutilize hardware\n- Not using `torch.no_grad()` during inference\n- Creating tensors in loops instead of batching\n- Not clearing variables and calling `torch.cuda.empty_cache()`\n- Using synchronous operations when asynchronous would work\n- Not leveraging built-in optimized functions\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}