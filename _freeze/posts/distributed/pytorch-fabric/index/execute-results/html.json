{
  "hash": "8456915d96e1ea2b8e32eac35d3165da",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"PyTorch Lightning Fabric Code Guide\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-06-03\"\ncategories: [code, tutorial, beginner]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# PyTorch Lightning Fabric Code Guide\n![](fabric.png)\n\nI've created a comprehensive code guide for PyTorch Lightning Fabric that covers everything from basic setup to advanced distributed training features\n\n## Introduction\n\nLightning Fabric is a lightweight PyTorch wrapper that provides essential training utilities without the overhead of the full Lightning framework. It's perfect when you want more control over your training loop while still benefiting from distributed training, mixed precision, and other optimizations.\n\n## Installation\n\n```{.bash}\npip install lightning\n# or\npip install pytorch-lightning\n```\n\n## Basic Setup\n\n### Minimal Example\n\n::: {#78273492 .cell execution_count=1}\n``` {.python .cell-code}\nimport torch\nimport torch.nn as nn\nfrom lightning.fabric import Fabric\n\n# Initialize Fabric\nfabric = Fabric()\n\n# Your model\nmodel = nn.Linear(10, 1)\noptimizer = torch.optim.SGD(model.parameters(), lr=0.01)\n\n# Setup model and optimizer with Fabric\nmodel, optimizer = fabric.setup(model, optimizer)\n\n# Training step\nfor batch in dataloader:\n    optimizer.zero_grad()\n    loss = model(batch).mean()\n    fabric.backward(loss)\n    optimizer.step()\n```\n:::\n\n\n## Core Components\n\n### Fabric Initialization\n\n::: {#4511f565 .cell execution_count=2}\n``` {.python .cell-code}\nfrom lightning.fabric import Fabric\n\n# Basic initialization\nfabric = Fabric()\n\n# With specific configuration\nfabric = Fabric(\n    accelerator=\"gpu\",           # \"cpu\", \"gpu\", \"tpu\", \"auto\"\n    strategy=\"ddp\",              # \"ddp\", \"fsdp\", \"deepspeed\", etc.\n    devices=2,                   # Number of devices\n    precision=\"16-mixed\",        # \"32\", \"16-mixed\", \"bf16-mixed\"\n    plugins=[],                  # Custom plugins\n)\n\n# Launch the fabric\nfabric.launch()\n```\n:::\n\n\n### Model and Optimizer Setup\n\n::: {#e2e35e8b .cell execution_count=3}\n``` {.python .cell-code}\nimport torch\nimport torch.nn as nn\n\nclass SimpleModel(nn.Module):\n    def __init__(self, input_size, hidden_size, output_size):\n        super().__init__()\n        self.fc1 = nn.Linear(input_size, hidden_size)\n        self.fc2 = nn.Linear(hidden_size, output_size)\n        self.relu = nn.ReLU()\n        self.dropout = nn.Dropout(0.1)\n    \n    def forward(self, x):\n        x = self.relu(self.fc1(x))\n        x = self.dropout(x)\n        return self.fc2(x)\n\n# Create model and optimizer\nmodel = SimpleModel(784, 128, 10)\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-3)\nscheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.1)\n\n# Setup with Fabric\nmodel, optimizer = fabric.setup(model, optimizer)\nscheduler = fabric.setup(scheduler)\n```\n:::\n\n\n### DataLoader Setup\n\n::: {#ba4ca4f5 .cell execution_count=4}\n``` {.python .cell-code}\nfrom torch.utils.data import DataLoader, TensorDataset\n\n# Create your dataset\ndataset = TensorDataset(torch.randn(1000, 784), torch.randint(0, 10, (1000,)))\ndataloader = DataLoader(dataset, batch_size=32, shuffle=True)\n\n# Setup with Fabric\ndataloader = fabric.setup_dataloaders(dataloader)\n```\n:::\n\n\n## Training Loop\n\n### Basic Training Loop\n\n::: {#e47ec426 .cell execution_count=5}\n``` {.python .cell-code}\ndef train_epoch(fabric, model, optimizer, dataloader, criterion):\n    model.train()\n    total_loss = 0\n    \n    for batch_idx, (data, target) in enumerate(dataloader):\n        # Zero gradients\n        optimizer.zero_grad()\n        \n        # Forward pass\n        output = model(data)\n        loss = criterion(output, target)\n        \n        # Backward pass with Fabric\n        fabric.backward(loss)\n        \n        # Optimizer step\n        optimizer.step()\n        \n        total_loss += loss.item()\n        \n        # Log every 100 batches\n        if batch_idx % 100 == 0:\n            fabric.print(f'Batch {batch_idx}, Loss: {loss.item():.4f}')\n    \n    return total_loss / len(dataloader)\n\n# Training loop\ncriterion = nn.CrossEntropyLoss()\n\nfor epoch in range(10):\n    avg_loss = train_epoch(fabric, model, optimizer, dataloader, criterion)\n    scheduler.step()\n    \n    fabric.print(f'Epoch {epoch}: Average Loss = {avg_loss:.4f}')\n```\n:::\n\n\n### Training with Validation\n\n::: {#e0679cc4 .cell execution_count=6}\n``` {.python .cell-code}\ndef validate(fabric, model, val_dataloader, criterion):\n    model.eval()\n    total_loss = 0\n    correct = 0\n    total = 0\n    \n    with torch.no_grad():\n        for data, target in val_dataloader:\n            output = model(data)\n            loss = criterion(output, target)\n            total_loss += loss.item()\n            \n            pred = output.argmax(dim=1)\n            correct += (pred == target).sum().item()\n            total += target.size(0)\n    \n    accuracy = correct / total\n    avg_loss = total_loss / len(val_dataloader)\n    \n    return avg_loss, accuracy\n\n# Complete training with validation\ntrain_loader = fabric.setup_dataloaders(train_dataloader)\nval_loader = fabric.setup_dataloaders(val_dataloader)\n\nfor epoch in range(num_epochs):\n    # Training\n    train_loss = train_epoch(fabric, model, optimizer, train_loader, criterion)\n    \n    # Validation\n    val_loss, val_acc = validate(fabric, model, val_loader, criterion)\n    \n    fabric.print(f'Epoch {epoch}:')\n    fabric.print(f'  Train Loss: {train_loss:.4f}')\n    fabric.print(f'  Val Loss: {val_loss:.4f}')\n    fabric.print(f'  Val Acc: {val_acc:.4f}')\n    \n    scheduler.step()\n```\n:::\n\n\n## Multi-GPU Training\n\n### Distributed Data Parallel (DDP)\n\n::: {#1b5d95e3 .cell execution_count=7}\n``` {.python .cell-code}\n# Initialize Fabric for multi-GPU\nfabric = Fabric(\n    accelerator=\"gpu\",\n    strategy=\"ddp\",\n    devices=4,  # Use 4 GPUs\n)\nfabric.launch()\n\n# All-reduce for metrics across processes\ndef all_reduce_mean(fabric, tensor):\n    \"\"\"Average tensor across all processes\"\"\"\n    fabric.all_reduce(tensor, reduce_op=\"mean\")\n    return tensor\n\n# Training with distributed metrics\ndef train_distributed(fabric, model, optimizer, dataloader, criterion):\n    model.train()\n    total_loss = torch.tensor(0.0, device=fabric.device)\n    num_batches = 0\n    \n    for data, target in dataloader:\n        optimizer.zero_grad()\n        output = model(data)\n        loss = criterion(output, target)\n        \n        fabric.backward(loss)\n        optimizer.step()\n        \n        total_loss += loss.detach()\n        num_batches += 1\n    \n    # Average loss across all processes\n    avg_loss = total_loss / num_batches\n    avg_loss = all_reduce_mean(fabric, avg_loss)\n    \n    return avg_loss.item()\n```\n:::\n\n\n### Fully Sharded Data Parallel (FSDP)\n\n::: {#bbc9a9dc .cell execution_count=8}\n``` {.python .cell-code}\n# For very large models\nfabric = Fabric(\n    accelerator=\"gpu\",\n    strategy=\"fsdp\",\n    devices=8,\n    precision=\"bf16-mixed\"\n)\nfabric.launch()\n\n# FSDP automatically shards model parameters\nmodel, optimizer = fabric.setup(model, optimizer)\n```\n:::\n\n\n## Mixed Precision\n\n### Automatic Mixed Precision\n\n::: {#7c2e7f1e .cell execution_count=9}\n``` {.python .cell-code}\n# Enable mixed precision\nfabric = Fabric(precision=\"16-mixed\")  # or \"bf16-mixed\"\nfabric.launch()\n\n# Training remains the same - Fabric handles precision automatically\ndef train_with_amp(fabric, model, optimizer, dataloader, criterion):\n    model.train()\n    \n    for data, target in dataloader:\n        optimizer.zero_grad()\n        \n        # Forward pass (automatically uses mixed precision)\n        output = model(data)\n        loss = criterion(output, target)\n        \n        # Backward pass (handles gradient scaling)\n        fabric.backward(loss)\n        \n        optimizer.step()\n```\n:::\n\n\n### Manual Precision Control\n\n::: {#ce075170 .cell execution_count=10}\n``` {.python .cell-code}\nfrom lightning.fabric.utilities import rank_zero_only\n\n@rank_zero_only\ndef log_model_precision(model):\n    \"\"\"Log model parameter precisions (only on rank 0)\"\"\"\n    for name, param in model.named_parameters():\n        print(f\"{name}: {param.dtype}\")\n\n# Check model precision after setup\nmodel, optimizer = fabric.setup(model, optimizer)\nlog_model_precision(model)\n```\n:::\n\n\n## Logging and Checkpointing\n\n### Checkpointing\n\n::: {#8c96ca81 .cell execution_count=11}\n``` {.python .cell-code}\nimport os\n\ndef save_checkpoint(fabric, model, optimizer, epoch, loss, path):\n    \"\"\"Save model checkpoint\"\"\"\n    checkpoint = {\n        \"model\": model,\n        \"optimizer\": optimizer,\n        \"epoch\": epoch,\n        \"loss\": loss\n    }\n    fabric.save(path, checkpoint)\n\ndef load_checkpoint(fabric, path):\n    \"\"\"Load model checkpoint\"\"\"\n    checkpoint = fabric.load(path)\n    return checkpoint\n\n# Save checkpoint\ncheckpoint_path = f\"checkpoint_epoch_{epoch}.ckpt\"\nsave_checkpoint(fabric, model, optimizer, epoch, train_loss, checkpoint_path)\n\n# Load checkpoint\nif os.path.exists(\"checkpoint_epoch_5.ckpt\"):\n    checkpoint = load_checkpoint(fabric, \"checkpoint_epoch_5.ckpt\")\n    model = checkpoint[\"model\"]\n    optimizer = checkpoint[\"optimizer\"]\n    start_epoch = checkpoint[\"epoch\"] + 1\n```\n:::\n\n\n### Logging with External Loggers\n\n::: {#71b34485 .cell execution_count=12}\n``` {.python .cell-code}\nfrom lightning.fabric.loggers import TensorBoardLogger, CSVLogger\n\n# Initialize logger\nlogger = TensorBoardLogger(\"logs\", name=\"my_experiment\")\n\n# Setup Fabric with logger\nfabric = Fabric(loggers=[logger])\nfabric.launch()\n\n# Log metrics\ndef log_metrics(fabric, metrics, step):\n    for logger in fabric.loggers:\n        logger.log_metrics(metrics, step)\n\n# Usage in training loop\nfor epoch in range(num_epochs):\n    train_loss = train_epoch(fabric, model, optimizer, train_loader, criterion)\n    val_loss, val_acc = validate(fabric, model, val_loader, criterion)\n    \n    # Log metrics\n    metrics = {\n        \"train_loss\": train_loss,\n        \"val_loss\": val_loss,\n        \"val_accuracy\": val_acc,\n        \"learning_rate\": optimizer.param_groups[0]['lr']\n    }\n    log_metrics(fabric, metrics, epoch)\n```\n:::\n\n\n## Advanced Features\n\n### Custom Precision Plugin\n\n::: {#7dc992b2 .cell execution_count=13}\n``` {.python .cell-code}\nfrom lightning.fabric.plugins import MixedPrecisionPlugin\n\n# Custom precision configuration\nprecision_plugin = MixedPrecisionPlugin(\n    precision=\"16-mixed\",\n    device=\"cuda\",\n    scaler_kwargs={\"init_scale\": 2**16}\n)\n\nfabric = Fabric(plugins=[precision_plugin])\n```\n:::\n\n\n### Gradient Clipping\n\n::: {#ffe75cf2 .cell execution_count=14}\n``` {.python .cell-code}\ndef train_with_grad_clipping(fabric, model, optimizer, dataloader, criterion, max_norm=1.0):\n    model.train()\n    \n    for data, target in dataloader:\n        optimizer.zero_grad()\n        output = model(data)\n        loss = criterion(output, target)\n        \n        fabric.backward(loss)\n        \n        # Gradient clipping\n        fabric.clip_gradients(model, optimizer, max_norm=max_norm)\n        \n        optimizer.step()\n```\n:::\n\n\n### Early Stopping\n\n::: {#cb2aa828 .cell execution_count=15}\n``` {.python .cell-code}\nclass EarlyStopping:\n    def __init__(self, patience=10, min_delta=0.001):\n        self.patience = patience\n        self.min_delta = min_delta\n        self.counter = 0\n        self.best_loss = float('inf')\n    \n    def __call__(self, val_loss):\n        if val_loss < self.best_loss - self.min_delta:\n            self.best_loss = val_loss\n            self.counter = 0\n        else:\n            self.counter += 1\n        \n        return self.counter >= self.patience\n\n# Usage\nearly_stopping = EarlyStopping(patience=5)\n\nfor epoch in range(num_epochs):\n    train_loss = train_epoch(fabric, model, optimizer, train_loader, criterion)\n    val_loss, val_acc = validate(fabric, model, val_loader, criterion)\n    \n    if early_stopping(val_loss):\n        fabric.print(f\"Early stopping at epoch {epoch}\")\n        break\n```\n:::\n\n\n## Best Practices\n\n### Proper Fabric Launch\n\n::: {#c13ca63f .cell execution_count=16}\n``` {.python .cell-code}\n# Always use fabric.launch() for proper initialization\ndef main():\n    fabric = Fabric(accelerator=\"gpu\", devices=2)\n    fabric.launch()\n    \n    # Your training code here\n    model = create_model()\n    # ... rest of training\n\nif __name__ == \"__main__\":\n    main()\n```\n:::\n\n\n### Rank-specific Operations\n\n::: {#4ab8bdd1 .cell execution_count=17}\n``` {.python .cell-code}\nfrom lightning.fabric.utilities import rank_zero_only\n\n@rank_zero_only\ndef save_model_artifacts(model, path):\n    \"\"\"Only save on rank 0 to avoid conflicts\"\"\"\n    torch.save(model.state_dict(), path)\n\n@rank_zero_only  \ndef print_training_info(epoch, loss):\n    \"\"\"Only print on rank 0 to avoid duplicate outputs\"\"\"\n    print(f\"Epoch {epoch}, Loss: {loss}\")\n```\n:::\n\n\n### Proper Device Management\n\n::: {#e19d6a5e .cell execution_count=18}\n``` {.python .cell-code}\n# Let Fabric handle device placement\nfabric = Fabric()\nfabric.launch()\n\n# Don't manually move to device - Fabric handles this\n# BAD: model.to(device), data.to(device)\n# GOOD: Let fabric.setup() handle device placement\n\nmodel, optimizer = fabric.setup(model, optimizer)\ndataloader = fabric.setup_dataloaders(dataloader)\n```\n:::\n\n\n### Memory Efficient Training\n\n::: {#d124e04a .cell execution_count=19}\n``` {.python .cell-code}\ndef memory_efficient_training(fabric, model, optimizer, dataloader, criterion):\n    model.train()\n    \n    for batch_idx, (data, target) in enumerate(dataloader):\n        optimizer.zero_grad()\n        \n        # Use gradient checkpointing for large models\n        if hasattr(model, 'gradient_checkpointing_enable'):\n            model.gradient_checkpointing_enable()\n        \n        output = model(data)\n        loss = criterion(output, target)\n        \n        fabric.backward(loss)\n        optimizer.step()\n        \n        # Clear cache periodically\n        if batch_idx % 100 == 0:\n            torch.cuda.empty_cache()\n```\n:::\n\n\n### Complete Training Script Template\n\n::: {#886b62e8 .cell execution_count=20}\n``` {.python .cell-code}\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader\nfrom lightning.fabric import Fabric\nfrom lightning.fabric.utilities import rank_zero_only\n\ndef create_model():\n    return nn.Sequential(\n        nn.Linear(784, 256),\n        nn.ReLU(),\n        nn.Linear(256, 128),\n        nn.ReLU(),\n        nn.Linear(128, 10)\n    )\n\ndef train_epoch(fabric, model, optimizer, dataloader, criterion):\n    model.train()\n    total_loss = 0\n    \n    for data, target in dataloader:\n        optimizer.zero_grad()\n        output = model(data)\n        loss = criterion(output, target)\n        fabric.backward(loss)\n        optimizer.step()\n        total_loss += loss.item()\n    \n    return total_loss / len(dataloader)\n\ndef main():\n    # Initialize Fabric\n    fabric = Fabric(\n        accelerator=\"auto\",\n        strategy=\"auto\",\n        devices=\"auto\",\n        precision=\"16-mixed\"\n    )\n    fabric.launch()\n    \n    # Create model, optimizer, data\n    model = create_model()\n    optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)\n    \n    # Setup with Fabric\n    model, optimizer = fabric.setup(model, optimizer)\n    \n    # Training loop\n    criterion = nn.CrossEntropyLoss()\n    for epoch in range(10):\n        avg_loss = train_epoch(fabric, model, optimizer, dataloader, criterion)\n        \n        if fabric.is_global_zero:\n            print(f\"Epoch {epoch}: Loss = {avg_loss:.4f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n:::\n\n\n## Conclusion\n\nThis guide covers the essential aspects of using Lightning Fabric for efficient PyTorch training. Fabric provides the perfect balance between control and convenience, making it ideal for researchers and practitioners who want distributed training capabilities without giving up flexibility in their training loops.\n\n## Key Takeaways\n\n- **Lightweight**: Fabric adds minimal overhead to your PyTorch code\n- **Flexible**: Maintain full control over your training loop\n- **Scalable**: Easy distributed training with DDP, FSDP, and other strategies\n- **Efficient**: Built-in mixed precision and optimization features\n- **Compatible**: Works with existing PyTorch code with minimal changes\n\nFor more advanced use cases and the latest features, refer to the [official Lightning Fabric documentation](https://lightning.ai/docs/fabric/stable/).\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}