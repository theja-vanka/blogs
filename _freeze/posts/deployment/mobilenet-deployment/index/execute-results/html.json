{
  "hash": "4c3a3b0256e7fffaa0e9d74e75c93cb7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"MobileNetV2 PyTorch Docker Deployment Guide\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-05-26\"\ncategories: [code, mlops, intermediate]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# MobileNetV2 PyTorch Docker Deployment Guide\n![](docker.png)\n\nThis guide walks you through deploying a pre-trained MobileNetV2 model using PyTorch and Docker, creating a REST API for image classification.\n\n## Project Structure\n\n```\nmobilenetv2-pytorch-docker/\n├── app/\n│   ├── __init__.py\n│   ├── main.py\n│   ├── model_handler.py\n│   └── utils.py\n├── requirements.txt\n├── Dockerfile\n├── docker-compose.yml\n├── .dockerignore\n└── README.md\n```\n\n## 1. Application Code\n\n### `app/main.py` - FastAPI Application\n\n```python\nfrom fastapi import FastAPI, File, UploadFile, HTTPException\nfrom fastapi.responses import JSONResponse\nimport uvicorn\nimport io\nfrom PIL import Image\nimport numpy as np\nfrom .model_handler import MobileNetV2Handler\nfrom .utils import preprocess_image, decode_predictions\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(\n    title=\"MobileNetV2 PyTorch Image Classification API\",\n    description=\"Deploy MobileNetV2 using PyTorch for image classification\",\n    version=\"1.0.0\"\n)\n\n# Initialize model handler\nmodel_handler = MobileNetV2Handler()\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Load model on startup\"\"\"\n    try:\n        model_handler.load_model()\n        logger.info(\"Model loaded successfully\")\n    except Exception as e:\n        logger.error(f\"Failed to load model: {e}\")\n        raise\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"MobileNetV2 PyTorch Classification API\", \"status\": \"running\"}\n\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\", \"model_loaded\": model_handler.is_loaded()}\n\n@app.post(\"/predict\")\nasync def predict(file: UploadFile = File(...)):\n    \"\"\"\n    Predict image class using MobileNetV2\n    \"\"\"\n    if not file.content_type.startswith(\"image/\"):\n        raise HTTPException(status_code=400, detail=\"File must be an image\")\n    \n    try:\n        # Read and preprocess image\n        image_data = await file.read()\n        image = Image.open(io.BytesIO(image_data))\n        \n        if image.mode != 'RGB':\n            image = image.convert('RGB')\n        \n        # Preprocess for MobileNetV2\n        processed_image = preprocess_image(image)\n        \n        # Make prediction\n        predictions = model_handler.predict(processed_image)\n        \n        # Decode predictions\n        decoded_predictions = decode_predictions(predictions, top=5)\n        \n        return JSONResponse(content={\n            \"predictions\": decoded_predictions,\n            \"success\": True\n        })\n        \n    except Exception as e:\n        logger.error(f\"Prediction error: {e}\")\n        raise HTTPException(status_code=500, detail=f\"Prediction failed: {str(e)}\")\n\n@app.post(\"/batch_predict\")\nasync def batch_predict(files: list[UploadFile] = File(...)):\n    \"\"\"\n    Batch prediction for multiple images\n    \"\"\"\n    if len(files) > 10:  # Limit batch size\n        raise HTTPException(status_code=400, detail=\"Maximum 10 images allowed per batch\")\n    \n    results = []\n    \n    for file in files:\n        if not file.content_type.startswith(\"image/\"):\n            results.append({\n                \"filename\": file.filename,\n                \"error\": \"File must be an image\"\n            })\n            continue\n        \n        try:\n            image_data = await file.read()\n            image = Image.open(io.BytesIO(image_data))\n            \n            if image.mode != 'RGB':\n                image = image.convert('RGB')\n            \n            processed_image = preprocess_image(image)\n            predictions = model_handler.predict(processed_image)\n            decoded_predictions = decode_predictions(predictions, top=3)\n            \n            results.append({\n                \"filename\": file.filename,\n                \"predictions\": decoded_predictions,\n                \"success\": True\n            })\n            \n        except Exception as e:\n            results.append({\n                \"filename\": file.filename,\n                \"error\": str(e),\n                \"success\": False\n            })\n    \n    return JSONResponse(content={\"results\": results})\n\n@app.get(\"/model_info\")\nasync def model_info():\n    \"\"\"Get model information\"\"\"\n    return {\n        \"model_name\": \"MobileNetV2\",\n        \"framework\": \"PyTorch\",\n        \"input_size\": [224, 224],\n        \"num_classes\": 1000,\n        \"pretrained\": True\n    }\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n### `app/model_handler.py` - PyTorch Model Management\n\n```python\nimport torch\nimport torch.nn as nn\nfrom torchvision import models\nimport numpy as np\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass MobileNetV2Handler:\n    def __init__(self):\n        self.model = None\n        self.device = None\n        self._loaded = False\n        \n    def load_model(self):\n        \"\"\"Load pre-trained MobileNetV2 model\"\"\"\n        try:\n            logger.info(\"Loading MobileNetV2 PyTorch model...\")\n            \n            # Determine device (CPU/GPU)\n            self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n            logger.info(f\"Using device: {self.device}\")\n            \n            # Load pre-trained MobileNetV2\n            self.model = models.mobilenet_v2(pretrained=True)\n            self.model.eval()  # Set to evaluation mode\n            self.model.to(self.device)\n            \n            # Warm up the model with a dummy prediction\n            dummy_input = torch.randn(1, 3, 224, 224).to(self.device)\n            with torch.no_grad():\n                _ = self.model(dummy_input)\n            \n            self._loaded = True\n            logger.info(\"Model loaded and warmed up successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to load model: {e}\")\n            raise\n    \n    def predict(self, image_tensor):\n        \"\"\"Make prediction on preprocessed image tensor\"\"\"\n        if not self._loaded:\n            raise RuntimeError(\"Model not loaded\")\n        \n        try:\n            # Ensure tensor is on correct device\n            if isinstance(image_tensor, np.ndarray):\n                image_tensor = torch.from_numpy(image_tensor)\n            \n            image_tensor = image_tensor.to(self.device)\n            \n            # Ensure batch dimension\n            if len(image_tensor.shape) == 3:\n                image_tensor = image_tensor.unsqueeze(0)\n            \n            # Make prediction\n            with torch.no_grad():\n                outputs = self.model(image_tensor)\n                # Apply softmax to get probabilities\n                probabilities = torch.nn.functional.softmax(outputs, dim=1)\n            \n            return probabilities.cpu().numpy()\n            \n        except Exception as e:\n            logger.error(f\"Prediction failed: {e}\")\n            raise\n    \n    def predict_batch(self, image_tensors):\n        \"\"\"Make batch predictions\"\"\"\n        if not self._loaded:\n            raise RuntimeError(\"Model not loaded\")\n        \n        try:\n            # Convert to tensor if numpy array\n            if isinstance(image_tensors, np.ndarray):\n                image_tensors = torch.from_numpy(image_tensors)\n            \n            image_tensors = image_tensors.to(self.device)\n            \n            # Make batch prediction\n            with torch.no_grad():\n                outputs = self.model(image_tensors)\n                probabilities = torch.nn.functional.softmax(outputs, dim=1)\n            \n            return probabilities.cpu().numpy()\n            \n        except Exception as e:\n            logger.error(f\"Batch prediction failed: {e}\")\n            raise\n    \n    def is_loaded(self):\n        \"\"\"Check if model is loaded\"\"\"\n        return self._loaded\n    \n    def get_device(self):\n        \"\"\"Get current device\"\"\"\n        return str(self.device) if self.device else \"not initialized\"\n```\n\n### `app/utils.py` - Utility Functions\n\n```python\nimport numpy as np\nimport torch\nfrom PIL import Image\nfrom torchvision import transforms\nimport json\nimport os\nimport requests\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# ImageNet class labels\nIMAGENET_CLASSES_URL = \"https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt\"\n\ndef get_imagenet_classes():\n    \"\"\"Download and cache ImageNet class labels\"\"\"\n    try:\n        if os.path.exists(\"imagenet_classes.txt\"):\n            with open(\"imagenet_classes.txt\", \"r\") as f:\n                classes = [line.strip() for line in f.readlines()]\n        else:\n            logger.info(\"Downloading ImageNet class labels...\")\n            response = requests.get(IMAGENET_CLASSES_URL)\n            classes = response.text.strip().split('\\n')\n            \n            # Cache the classes\n            with open(\"imagenet_classes.txt\", \"w\") as f:\n                for class_name in classes:\n                    f.write(f\"{class_name}\\n\")\n        \n        return classes\n    except Exception as e:\n        logger.warning(f\"Could not load ImageNet classes: {e}\")\n        return [f\"class_{i}\" for i in range(1000)]\n\n# Load ImageNet classes\nIMAGENET_CLASSES = get_imagenet_classes()\n\ndef preprocess_image(image: Image.Image, target_size=(224, 224)):\n    \"\"\"\n    Preprocess image for MobileNetV2 PyTorch model\n    \"\"\"\n    try:\n        # Define transforms\n        transform = transforms.Compose([\n            transforms.Resize(256),\n            transforms.CenterCrop(target_size),\n            transforms.ToTensor(),\n            transforms.Normalize(\n                mean=[0.485, 0.456, 0.406],  # ImageNet normalization\n                std=[0.229, 0.224, 0.225]\n            )\n        ])\n        \n        # Apply transforms\n        image_tensor = transform(image)\n        \n        return image_tensor\n        \n    except Exception as e:\n        raise ValueError(f\"Image preprocessing failed: {e}\")\n\ndef preprocess_batch(images: list, target_size=(224, 224)):\n    \"\"\"\n    Preprocess batch of images\n    \"\"\"\n    try:\n        transform = transforms.Compose([\n            transforms.Resize(256),\n            transforms.CenterCrop(target_size),\n            transforms.ToTensor(),\n            transforms.Normalize(\n                mean=[0.485, 0.456, 0.406],\n                std=[0.229, 0.224, 0.225]\n            )\n        ])\n        \n        batch_tensors = []\n        for image in images:\n            if isinstance(image, str):  # If path\n                image = Image.open(image).convert('RGB')\n            elif not isinstance(image, Image.Image):\n                raise ValueError(\"Invalid image type\")\n            \n            tensor = transform(image)\n            batch_tensors.append(tensor)\n        \n        return torch.stack(batch_tensors)\n        \n    except Exception as e:\n        raise ValueError(f\"Batch preprocessing failed: {e}\")\n\ndef decode_predictions(predictions, top=5):\n    \"\"\"\n    Decode model predictions to human-readable labels\n    \"\"\"\n    try:\n        # Get top predictions\n        if isinstance(predictions, torch.Tensor):\n            predictions = predictions.numpy()\n        \n        # Handle batch predictions (take first sample)\n        if len(predictions.shape) > 1:\n            predictions = predictions[0]\n        \n        # Get top k indices\n        top_indices = np.argsort(predictions)[-top:][::-1]\n        \n        # Format results\n        results = []\n        for idx in top_indices:\n            confidence = float(predictions[idx])\n            class_name = IMAGENET_CLASSES[idx] if idx < len(IMAGENET_CLASSES) else f\"class_{idx}\"\n            \n            results.append({\n                \"class_id\": int(idx),\n                \"class_name\": class_name,\n                \"confidence\": confidence\n            })\n        \n        return results\n        \n    except Exception as e:\n        raise ValueError(f\"Prediction decoding failed: {e}\")\n\ndef validate_image(image_data):\n    \"\"\"\n    Validate image data\n    \"\"\"\n    try:\n        image = Image.open(image_data)\n        return image.format in ['JPEG', 'PNG', 'BMP', 'TIFF', 'WEBP']\n    except:\n        return False\n\ndef tensor_to_numpy(tensor):\n    \"\"\"Convert PyTorch tensor to numpy array\"\"\"\n    if isinstance(tensor, torch.Tensor):\n        return tensor.detach().cpu().numpy()\n    return tensor\n\ndef numpy_to_tensor(array, device='cpu'):\n    \"\"\"Convert numpy array to PyTorch tensor\"\"\"\n    if isinstance(array, np.ndarray):\n        return torch.from_numpy(array).to(device)\n    return array\n\nclass ModelProfiler:\n    \"\"\"Simple profiler for model performance\"\"\"\n    \n    def __init__(self):\n        self.inference_times = []\n        self.preprocessing_times = []\n    \n    def record_inference_time(self, time_ms):\n        self.inference_times.append(time_ms)\n    \n    def record_preprocessing_time(self, time_ms):\n        self.preprocessing_times.append(time_ms)\n    \n    def get_stats(self):\n        if not self.inference_times:\n            return {\"message\": \"No inference data recorded\"}\n        \n        return {\n            \"avg_inference_time_ms\": np.mean(self.inference_times),\n            \"avg_preprocessing_time_ms\": np.mean(self.preprocessing_times) if self.preprocessing_times else 0,\n            \"total_inferences\": len(self.inference_times),\n            \"min_inference_time_ms\": np.min(self.inference_times),\n            \"max_inference_time_ms\": np.max(self.inference_times)\n        }\n\n# Global profiler instance\nprofiler = ModelProfiler()\n```\n\n### `app/__init__.py`\n\n```python\n# Empty file to make app a Python package\n```\n\n## 2. Configuration Files\n\n### `requirements.txt`\n\n```txt\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\ntorch==2.1.0\ntorchvision==0.16.0\nPillow==10.1.0\npython-multipart==0.0.6\nnumpy==1.24.3\nrequests==2.31.0\n```\n\n### `Dockerfile`\n\n```dockerfile\n# Use official Python runtime as base image\nFROM python:3.11-slim\n\n# Set working directory\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    libgl1-mesa-glx \\\n    libglib2.0-0 \\\n    libsm6 \\\n    libxext6 \\\n    libxrender-dev \\\n    libgomp1 \\\n    wget \\\n    curl \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy requirements first for better caching\nCOPY requirements.txt .\n\n# Install PyTorch CPU version (smaller image)\nRUN pip install --no-cache-dir --upgrade pip && \\\n    pip install torch torchvision --index-url https://download.pytorch.org/whl/cpu && \\\n    pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY app/ ./app/\n\n# Create non-root user for security\nRUN useradd --create-home --shell /bin/bash app && \\\n    chown -R app:app /app\nUSER app\n\n# Pre-download ImageNet classes\nRUN python -c \"from app.utils import get_imagenet_classes; get_imagenet_classes()\"\n\n# Expose port\nEXPOSE 8000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=30s --start-period=60s --retries=3 \\\n    CMD curl -f http://localhost:8000/health || exit 1\n\n# Command to run the application\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n### `Dockerfile.gpu` (For GPU Support)\n\n```dockerfile\n# Use NVIDIA PyTorch base image\nFROM pytorch/pytorch:2.1.0-cuda12.1-cudnn8-runtime\n\n# Set working directory\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    curl \\\n    wget \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy requirements first for better caching\nCOPY requirements.txt .\n\n# Install additional dependencies\nRUN pip install --no-cache-dir --upgrade pip && \\\n    pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY app/ ./app/\n\n# Create non-root user for security\nRUN useradd --create-home --shell /bin/bash app && \\\n    chown -R app:app /app\nUSER app\n\n# Pre-download ImageNet classes\nRUN python -c \"from app.utils import get_imagenet_classes; get_imagenet_classes()\"\n\n# Expose port\nEXPOSE 8000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=30s --start-period=60s --retries=3 \\\n    CMD curl -f http://localhost:8000/health || exit 1\n\n# Command to run the application\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n### `docker-compose.yml`\n\n```yaml\nversion: '3.8'\n\nservices:\n  mobilenetv2-pytorch-api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - PYTHONPATH=/app\n      - TORCH_HOME=/app/.torch\n    volumes:\n      - ./logs:/app/logs\n      - torch_cache:/app/.torch\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 60s\n    deploy:\n      resources:\n        limits:\n          memory: 2G\n        reservations:\n          memory: 1G\n\n  # GPU version (uncomment and modify as needed)\n  # mobilenetv2-pytorch-gpu:\n  #   build:\n  #     context: .\n  #     dockerfile: Dockerfile.gpu\n  #   ports:\n  #     - \"8000:8000\"\n  #   environment:\n  #     - PYTHONPATH=/app\n  #     - TORCH_HOME=/app/.torch\n  #     - NVIDIA_VISIBLE_DEVICES=all\n  #   volumes:\n  #     - ./logs:/app/logs\n  #     - torch_cache:/app/.torch\n  #   restart: unless-stopped\n  #   deploy:\n  #     resources:\n  #       reservations:\n  #         devices:\n  #           - driver: nvidia\n  #             count: 1\n  #             capabilities: [gpu]\n\n  # Optional: Add nginx for production\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n    depends_on:\n      - mobilenetv2-pytorch-api\n    restart: unless-stopped\n\nvolumes:\n  torch_cache:\n```\n\n### `.dockerignore`\n\n```\n__pycache__\n*.pyc\n*.pyo\n*.pyd\n.Python\nenv/\npip-log.txt\npip-delete-this-directory.txt\n.git\n.gitignore\nREADME.md\n.pytest_cache\n.coverage\n.nyc_output\nnode_modules\n.DS_Store\n*.log\nlogs/\n*.pth\n*.pt\n.torch/\n```\n\n### `nginx.conf` (Optional - for production)\n\n```nginx\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    upstream api {\n        server mobilenetv2-pytorch-api:8000;\n    }\n\n    server {\n        listen 80;\n        client_max_body_size 10M;\n\n        location / {\n            proxy_pass http://api;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_read_timeout 300;\n            proxy_connect_timeout 300;\n            proxy_send_timeout 300;\n        }\n    }\n}\n```\n\n## 3. Deployment Commands\n\n### Build and Run with Docker\n\n```bash\n# Build the CPU image\ndocker build -t mobilenetv2-pytorch-api .\n\n# Build the GPU image (if you have NVIDIA GPU)\ndocker build -f Dockerfile.gpu -t mobilenetv2-pytorch-gpu .\n\n# Run CPU version\ndocker run -p 8000:8000 mobilenetv2-pytorch-api\n\n# Run GPU version\ndocker run --gpus all -p 8000:8000 mobilenetv2-pytorch-gpu\n\n# Run with environment variables\ndocker run -p 8000:8000 -e TORCH_HOME=/tmp/.torch mobilenetv2-pytorch-api\n```\n\n### Using Docker Compose\n\n```bash\n# Build and start services\ndocker-compose up --build\n\n# Run in background\ndocker-compose up -d\n\n# View logs\ndocker-compose logs -f mobilenetv2-pytorch-api\n\n# Stop services\ndocker-compose down\n```\n\n## 4. Usage Examples\n\n### Test the API\n\n```bash\n# Health check\ncurl http://localhost:8000/health\n\n# Model info\ncurl http://localhost:8000/model_info\n\n# Single image prediction\ncurl -X POST \"http://localhost:8000/predict\" \\\n     -H \"accept: application/json\" \\\n     -H \"Content-Type: multipart/form-data\" \\\n     -F \"file=@path/to/your/image.jpg\"\n\n# Batch prediction\ncurl -X POST \"http://localhost:8000/batch_predict\" \\\n     -H \"accept: application/json\" \\\n     -H \"Content-Type: multipart/form-data\" \\\n     -F \"files=@image1.jpg\" \\\n     -F \"files=@image2.jpg\"\n```\n\n### Python Client Example\n\n```python\nimport requests\nimport json\n\n# Single prediction\ndef predict_image(image_path, api_url=\"http://localhost:8000\"):\n    url = f\"{api_url}/predict\"\n    files = {\"file\": open(image_path, \"rb\")}\n    response = requests.post(url, files=files)\n    return response.json()\n\n# Batch prediction\ndef predict_batch(image_paths, api_url=\"http://localhost:8000\"):\n    url = f\"{api_url}/batch_predict\"\n    files = [(\"files\", open(path, \"rb\")) for path in image_paths]\n    response = requests.post(url, files=files)\n    return response.json()\n\n# Usage\nresult = predict_image(\"cat.jpg\")\nprint(json.dumps(result, indent=2))\n\nbatch_result = predict_batch([\"cat.jpg\", \"dog.jpg\"])\nprint(json.dumps(batch_result, indent=2))\n```\n\n### Response Format\n\n```json\n{\n  \"predictions\": [\n    {\n      \"class_id\": 281,\n      \"class_name\": \"tabby\",\n      \"confidence\": 0.8234567\n    },\n    {\n      \"class_id\": 282,\n      \"class_name\": \"tiger_cat\",\n      \"confidence\": 0.1234567\n    }\n  ],\n  \"success\": true\n}\n```\n\n## 5. Performance Optimization\n\n### Model Optimization\n\n```python\n# Add to model_handler.py for optimization\nimport torch.jit\n\nclass OptimizedMobileNetV2Handler(MobileNetV2Handler):\n    def __init__(self, use_jit=True, use_half_precision=False):\n        super().__init__()\n        self.use_jit = use_jit\n        self.use_half_precision = use_half_precision\n    \n    def load_model(self):\n        super().load_model()\n        \n        if self.use_jit:\n            # TorchScript compilation for faster inference\n            self.model = torch.jit.script(self.model)\n            logger.info(\"Model compiled with TorchScript\")\n        \n        if self.use_half_precision and self.device.type == 'cuda':\n            # Half precision for GPU\n            self.model = self.model.half()\n            logger.info(\"Model converted to half precision\")\n```\n\n### Docker Optimization\n\n```dockerfile\n# Multi-stage build for smaller image\nFROM python:3.11-slim as builder\n\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --user --no-cache-dir -r requirements.txt\n\nFROM python:3.11-slim\n\nWORKDIR /app\nCOPY --from=builder /root/.local /root/.local\nCOPY app/ ./app/\n\n# Make sure scripts in .local are usable\nENV PATH=/root/.local/bin:$PATH\n\nEXPOSE 8000\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n## 6. Monitoring and Logging\n\n### Enhanced Logging\n\n```python\n# Add to main.py\nimport time\nfrom app.utils import profiler\n\n@app.middleware(\"http\")\nasync def log_requests(request, call_next):\n    start_time = time.time()\n    response = await call_next(request)\n    process_time = (time.time() - start_time) * 1000\n    \n    logger.info(f\"{request.method} {request.url.path} - {process_time:.2f}ms\")\n    \n    if request.url.path == \"/predict\":\n        profiler.record_inference_time(process_time)\n    \n    return response\n\n@app.get(\"/stats\")\nasync def get_stats():\n    \"\"\"Get performance statistics\"\"\"\n    return profiler.get_stats()\n```\n\n## 7. Cloud Deployment\n\n### AWS ECS Task Definition\n\n```json\n{\n  \"family\": \"mobilenetv2-pytorch-task\",\n  \"networkMode\": \"awsvpc\",\n  \"requiresCompatibilities\": [\"FARGATE\"],\n  \"cpu\": \"1024\",\n  \"memory\": \"2048\",\n  \"containerDefinitions\": [\n    {\n      \"name\": \"mobilenetv2-pytorch-api\",\n      \"image\": \"your-registry/mobilenetv2-pytorch-api:latest\",\n      \"portMappings\": [\n        {\n          \"containerPort\": 8000,\n          \"protocol\": \"tcp\"\n        }\n      ],\n      \"environment\": [\n        {\n          \"name\": \"TORCH_HOME\",\n          \"value\": \"/tmp/.torch\"\n        }\n      ],\n      \"essential\": true,\n      \"logConfiguration\": {\n        \"logDriver\": \"awslogs\",\n        \"options\": {\n          \"awslogs-group\": \"/ecs/mobilenetv2-pytorch\",\n          \"awslogs-region\": \"us-east-1\",\n          \"awslogs-stream-prefix\": \"ecs\"\n        }\n      }\n    }\n  ]\n}\n```\n\n### Kubernetes Deployment\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mobilenetv2-pytorch-api\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: mobilenetv2-pytorch-api\n  template:\n    metadata:\n      labels:\n        app: mobilenetv2-pytorch-api\n    spec:\n      containers:\n      - name: mobilenetv2-pytorch-api\n        image: mobilenetv2-pytorch-api:latest\n        ports:\n        - containerPort: 8000\n        env:\n        - name: TORCH_HOME\n          value: /tmp/.torch\n        resources:\n          requests:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n          limits:\n            memory: \"2Gi\"\n            cpu: \"1000m\"\n        volumeMounts:\n        - name: torch-cache\n          mountPath: /tmp/.torch\n      volumes:\n      - name: torch-cache\n        emptyDir: {}\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: mobilenetv2-pytorch-service\nspec:\n  selector:\n    app: mobilenetv2-pytorch-api\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8000\n  type: LoadBalancer\n```\n\nThis PyTorch-based guide provides the same functionality as the TensorFlow version but uses PyTorch's ecosystem, including torchvision for pre-trained models, PyTorch transformations for preprocessing, and proper tensor handling throughout the application.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}