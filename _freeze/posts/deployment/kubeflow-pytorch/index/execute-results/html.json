{
  "hash": "9b4facb32e116b3b2ed7cfa6e452af41",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Kubeflow Deep Learning Guide with PyTorch\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-05-31\"\ncategories: [code, mlops, intermediate]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# Kubeflow Deep Learning Guide with PyTorch\n![](kupyt.png)\n\n## Introduction\n\nKubeflow is a machine learning toolkit for Kubernetes that makes deployments of ML workflows on Kubernetes simple, portable, and scalable. This guide focuses on using Kubeflow with PyTorch for deep learning tasks.\n\n### Key Kubeflow Components for Deep Learning:\n- **Training Operator**: For distributed training jobs\n- **Katib**: For hyperparameter tuning and neural architecture search\n- **KServe**: For model serving and inference\n- **Pipelines**: For ML workflow orchestration\n- **Notebooks**: For interactive development\n\n## Prerequisites\n\nBefore starting, ensure you have:\n\n- Kubernetes cluster with Kubeflow installed\n- kubectl configured to access your cluster\n- Docker for building container images\n- Basic knowledge of PyTorch and Kubernetes\n\n## Setting Up Your Environment\n\n### 1. Create a Namespace\n```yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: pytorch-training\n```\n\n### 2. Base Docker Image for PyTorch\nCreate a `Dockerfile` for your PyTorch environment:\n\n```dockerfile\nFROM pytorch/pytorch:2.0.1-cuda11.7-cudnn8-runtime\n\nWORKDIR /app\n\n# Install additional dependencies\nRUN pip install --no-cache-dir \\\n    torchvision \\\n    tensorboard \\\n    scikit-learn \\\n    pandas \\\n    numpy \\\n    matplotlib \\\n    seaborn\n\n# Copy your training code\nCOPY . /app/\n\n# Set the default command\nCMD [\"python\", \"train.py\"]\n```\n\n## Creating PyTorch Training Jobs\n\n### Simple Training Job\n\nCreate a basic PyTorch training script (`train.py`):\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader\nfrom torchvision import datasets, transforms\nimport argparse\nimport os\n\nclass SimpleNet(nn.Module):\n    def __init__(self, num_classes=10):\n        super(SimpleNet, self).__init__()\n        self.features = nn.Sequential(\n            nn.Conv2d(1, 32, 3, 1),\n            nn.ReLU(),\n            nn.Conv2d(32, 64, 3, 1),\n            nn.ReLU(),\n            nn.MaxPool2d(2),\n            nn.Dropout(0.25),\n            nn.Flatten(),\n            nn.Linear(9216, 128),\n            nn.ReLU(),\n            nn.Dropout(0.5),\n            nn.Linear(128, num_classes)\n        )\n    \n    def forward(self, x):\n        return self.features(x)\n\ndef train_epoch(model, device, train_loader, optimizer, criterion, epoch):\n    model.train()\n    total_loss = 0\n    correct = 0\n    \n    for batch_idx, (data, target) in enumerate(train_loader):\n        data, target = data.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = criterion(output, target)\n        loss.backward()\n        optimizer.step()\n        \n        total_loss += loss.item()\n        pred = output.argmax(dim=1, keepdim=True)\n        correct += pred.eq(target.view_as(pred)).sum().item()\n        \n        if batch_idx % 100 == 0:\n            print(f'Train Epoch: {epoch} [{batch_idx * len(data)}/{len(train_loader.dataset)}] '\n                  f'Loss: {loss.item():.6f}')\n    \n    accuracy = 100. * correct / len(train_loader.dataset)\n    avg_loss = total_loss / len(train_loader)\n    print(f'Train Epoch: {epoch}, Average Loss: {avg_loss:.4f}, Accuracy: {accuracy:.2f}%')\n    return avg_loss, accuracy\n\ndef test(model, device, test_loader, criterion):\n    model.eval()\n    test_loss = 0\n    correct = 0\n    \n    with torch.no_grad():\n        for data, target in test_loader:\n            data, target = data.to(device), target.to(device)\n            output = model(data)\n            test_loss += criterion(output, target).item()\n            pred = output.argmax(dim=1, keepdim=True)\n            correct += pred.eq(target.view_as(pred)).sum().item()\n    \n    test_loss /= len(test_loader)\n    accuracy = 100. * correct / len(test_loader.dataset)\n    print(f'Test set: Average loss: {test_loss:.4f}, Accuracy: {accuracy:.2f}%')\n    return test_loss, accuracy\n\ndef main():\n    parser = argparse.ArgumentParser(description='PyTorch MNIST Training')\n    parser.add_argument('--batch-size', type=int, default=64, metavar='N',\n                        help='input batch size for training (default: 64)')\n    parser.add_argument('--test-batch-size', type=int, default=1000, metavar='N',\n                        help='input batch size for testing (default: 1000)')\n    parser.add_argument('--epochs', type=int, default=10, metavar='N',\n                        help='number of epochs to train (default: 10)')\n    parser.add_argument('--lr', type=float, default=0.01, metavar='LR',\n                        help='learning rate (default: 0.01)')\n    parser.add_argument('--momentum', type=float, default=0.5, metavar='M',\n                        help='SGD momentum (default: 0.5)')\n    parser.add_argument('--no-cuda', action='store_true', default=False,\n                        help='disables CUDA training')\n    parser.add_argument('--seed', type=int, default=1, metavar='S',\n                        help='random seed (default: 1)')\n    parser.add_argument('--model-dir', type=str, default='/tmp/model',\n                        help='directory to save the model')\n    \n    args = parser.parse_args()\n    \n    torch.manual_seed(args.seed)\n    device = torch.device(\"cuda\" if torch.cuda.is_available() and not args.no_cuda else \"cpu\")\n    \n    # Data loading\n    transform = transforms.Compose([\n        transforms.ToTensor(),\n        transforms.Normalize((0.1307,), (0.3081,))\n    ])\n    \n    train_dataset = datasets.MNIST('/tmp/data', train=True, download=True, transform=transform)\n    test_dataset = datasets.MNIST('/tmp/data', train=False, transform=transform)\n    \n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, shuffle=True)\n    test_loader = DataLoader(test_dataset, batch_size=args.test_batch_size, shuffle=False)\n    \n    # Model, loss, and optimizer\n    model = SimpleNet().to(device)\n    criterion = nn.CrossEntropyLoss()\n    optimizer = optim.SGD(model.parameters(), lr=args.lr, momentum=args.momentum)\n    \n    # Training loop\n    for epoch in range(1, args.epochs + 1):\n        train_loss, train_acc = train_epoch(model, device, train_loader, optimizer, criterion, epoch)\n        test_loss, test_acc = test(model, device, test_loader, criterion)\n    \n    # Save model\n    os.makedirs(args.model_dir, exist_ok=True)\n    torch.save(model.state_dict(), f'{args.model_dir}/model.pth')\n    print(f'Model saved to {args.model_dir}/model.pth')\n\nif __name__ == '__main__':\n    main()\n```\n\n### PyTorchJob YAML Configuration\n\nCreate a `pytorchjob.yaml` file:\n\n```yaml\napiVersion: kubeflow.org/v1\nkind: PyTorchJob\nmetadata:\n  name: pytorch-mnist-training\n  namespace: pytorch-training\nspec:\n  pytorchReplicaSpecs:\n    Master:\n      replicas: 1\n      restartPolicy: OnFailure\n      template:\n        metadata:\n          annotations:\n            sidecar.istio.io/inject: \"false\"\n        spec:\n          containers:\n          - name: pytorch\n            image: your-registry/pytorch-mnist:latest\n            imagePullPolicy: Always\n            command:\n            - python\n            - train.py\n            args:\n            - --epochs=20\n            - --batch-size=64\n            - --lr=0.01\n            - --model-dir=/mnt/model\n            resources:\n              requests:\n                memory: \"2Gi\"\n                cpu: \"1\"\n              limits:\n                memory: \"4Gi\"\n                cpu: \"2\"\n                nvidia.com/gpu: \"1\"\n            volumeMounts:\n            - name: model-storage\n              mountPath: /mnt/model\n          volumes:\n          - name: model-storage\n            persistentVolumeClaim:\n              claimName: model-pvc\n```\n\n## Distributed Training\n\nFor distributed training across multiple GPUs or nodes:\n\n### Distributed Training Script\n\n```python\nimport torch\nimport torch.distributed as dist\nimport torch.multiprocessing as mp\nfrom torch.nn.parallel import DistributedDataParallel as DDP\nfrom torch.utils.data.distributed import DistributedSampler\nimport os\n\ndef setup(rank, world_size):\n    \"\"\"Initialize the distributed environment.\"\"\"\n    os.environ['MASTER_ADDR'] = os.environ.get('MASTER_ADDR', 'localhost')\n    os.environ['MASTER_PORT'] = os.environ.get('MASTER_PORT', '12355')\n    dist.init_process_group(\"nccl\", rank=rank, world_size=world_size)\n\ndef cleanup():\n    \"\"\"Clean up the distributed environment.\"\"\"\n    dist.destroy_process_group()\n\ndef train_distributed(rank, world_size, args):\n    setup(rank, world_size)\n    \n    device = torch.device(f\"cuda:{rank}\")\n    torch.cuda.set_device(device)\n    \n    # Create model and move to GPU\n    model = SimpleNet().to(device)\n    model = DDP(model, device_ids=[rank])\n    \n    # Create distributed sampler\n    train_sampler = DistributedSampler(train_dataset, \n                                       num_replicas=world_size, \n                                       rank=rank)\n    \n    train_loader = DataLoader(train_dataset, \n                              batch_size=args.batch_size,\n                              sampler=train_sampler,\n                              pin_memory=True)\n    \n    criterion = nn.CrossEntropyLoss()\n    optimizer = optim.SGD(model.parameters(), lr=args.lr)\n    \n    # Training loop\n    for epoch in range(args.epochs):\n        train_sampler.set_epoch(epoch)\n        \n        for batch_idx, (data, target) in enumerate(train_loader):\n            data, target = data.to(device, non_blocking=True), target.to(device, non_blocking=True)\n            \n            optimizer.zero_grad()\n            output = model(data)\n            loss = criterion(output, target)\n            loss.backward()\n            optimizer.step()\n            \n            if rank == 0 and batch_idx % 100 == 0:\n                print(f\"Epoch {epoch}, Batch {batch_idx}, Loss: {loss.item()}\")\n    \n    # Save model only on rank 0\n    if rank == 0:\n        torch.save(model.module.state_dict(), f'{args.model_dir}/distributed_model.pth')\n    \n    cleanup()\n```\n\n### Distributed PyTorchJob YAML\n\n```yaml\napiVersion: kubeflow.org/v1\nkind: PyTorchJob\nmetadata:\n  name: pytorch-distributed-training\n  namespace: pytorch-training\nspec:\n  pytorchReplicaSpecs:\n    Master:\n      replicas: 1\n      restartPolicy: OnFailure\n      template:\n        spec:\n          containers:\n          - name: pytorch\n            image: your-registry/pytorch-distributed:latest\n            command:\n            - python\n            - distributed_train.py\n            args:\n            - --epochs=50\n            - --batch-size=32\n            resources:\n              limits:\n                nvidia.com/gpu: \"1\"\n    Worker:\n      replicas: 3\n      restartPolicy: OnFailure\n      template:\n        spec:\n          containers:\n          - name: pytorch\n            image: your-registry/pytorch-distributed:latest\n            command:\n            - python\n            - distributed_train.py\n            args:\n            - --epochs=50\n            - --batch-size=32\n            resources:\n              limits:\n                nvidia.com/gpu: \"1\"\n```\n\n## Hyperparameter Tuning with Katib\n\n### Katib Experiment Configuration\n\nCreate a `katib-experiment.yaml`:\n\n```yaml\napiVersion: kubeflow.org/v1beta1\nkind: Experiment\nmetadata:\n  name: pytorch-hyperparameter-tuning\n  namespace: pytorch-training\nspec:\n  algorithm:\n    algorithmName: random\n  objective:\n    type: maximize\n    goal: 0.95\n    objectiveMetricName: accuracy\n  parameters:\n  - name: lr\n    parameterType: double\n    feasibleSpace:\n      min: \"0.001\"\n      max: \"0.1\"\n  - name: batch-size\n    parameterType: int\n    feasibleSpace:\n      min: \"16\"\n      max: \"128\"\n  - name: momentum\n    parameterType: double\n    feasibleSpace:\n      min: \"0.1\"\n      max: \"0.9\"\n  trialTemplate:\n    primaryContainerName: training-container\n    trialSpec:\n      apiVersion: kubeflow.org/v1\n      kind: PyTorchJob\n      spec:\n        pytorchReplicaSpecs:\n          Master:\n            replicas: 1\n            restartPolicy: OnFailure\n            template:\n              spec:\n                containers:\n                - name: training-container\n                  image: your-registry/pytorch-katib:latest\n                  command:\n                  - python\n                  - train_with_metrics.py\n                  args:\n                  - --lr=${trialParameters.lr}\n                  - --batch-size=${trialParameters.batch-size}\n                  - --momentum=${trialParameters.momentum}\n                  - --epochs=10\n  parallelTrialCount: 3\n  maxTrialCount: 20\n  maxFailedTrialCount: 3\n```\n\n### Training Script with Metrics for Katib\n\n```python\n# train_with_metrics.py\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader\nfrom torchvision import datasets, transforms\nimport argparse\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--lr', type=float, default=0.01)\n    parser.add_argument('--batch-size', type=int, default=64)\n    parser.add_argument('--momentum', type=float, default=0.5)\n    parser.add_argument('--epochs', type=int, default=10)\n    args = parser.parse_args()\n    \n    # Setup device\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    \n    # Data loading\n    transform = transforms.Compose([\n        transforms.ToTensor(),\n        transforms.Normalize((0.1307,), (0.3081,))\n    ])\n    \n    train_dataset = datasets.MNIST('/tmp/data', train=True, download=True, transform=transform)\n    test_dataset = datasets.MNIST('/tmp/data', train=False, transform=transform)\n    \n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, shuffle=True)\n    test_loader = DataLoader(test_dataset, batch_size=1000, shuffle=False)\n    \n    # Model\n    model = SimpleNet().to(device)\n    criterion = nn.CrossEntropyLoss()\n    optimizer = optim.SGD(model.parameters(), lr=args.lr, momentum=args.momentum)\n    \n    # Training\n    for epoch in range(args.epochs):\n        model.train()\n        for batch_idx, (data, target) in enumerate(train_loader):\n            data, target = data.to(device), target.to(device)\n            optimizer.zero_grad()\n            output = model(data)\n            loss = criterion(output, target)\n            loss.backward()\n            optimizer.step()\n    \n    # Evaluation\n    model.eval()\n    correct = 0\n    total = 0\n    with torch.no_grad():\n        for data, target in test_loader:\n            data, target = data.to(device), target.to(device)\n            outputs = model(data)\n            _, predicted = torch.max(outputs.data, 1)\n            total += target.size(0)\n            correct += (predicted == target).sum().item()\n    \n    accuracy = correct / total\n    \n    # Print metrics for Katib (important format)\n    print(f\"accuracy={accuracy:.4f}\")\n    print(f\"loss={1-accuracy:.4f}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n## Model Serving with KServe\n\n### Create a Model Server\n\nFirst, create a custom predictor (`predictor.py`):\n\n```python\nimport torch\nimport torch.nn as nn\nfrom torchvision import transforms\nimport kserve\nfrom typing import Dict\nimport numpy as np\nfrom PIL import Image\nimport io\nimport base64\n\nclass SimpleNet(nn.Module):\n    def __init__(self, num_classes=10):\n        super(SimpleNet, self).__init__()\n        self.features = nn.Sequential(\n            nn.Conv2d(1, 32, 3, 1),\n            nn.ReLU(),\n            nn.Conv2d(32, 64, 3, 1),\n            nn.ReLU(),\n            nn.MaxPool2d(2),\n            nn.Dropout(0.25),\n            nn.Flatten(),\n            nn.Linear(9216, 128),\n            nn.ReLU(),\n            nn.Dropout(0.5),\n            nn.Linear(128, num_classes)\n        )\n    \n    def forward(self, x):\n        return self.features(x)\n\nclass PyTorchMNISTPredictor(kserve.Model):\n    def __init__(self, name: str):\n        super().__init__(name)\n        self.name = name\n        self.model = None\n        self.transform = transforms.Compose([\n            transforms.ToTensor(),\n            transforms.Normalize((0.1307,), (0.3081,))\n        ])\n        self.ready = False\n\n    def load(self):\n        self.model = SimpleNet()\n        self.model.load_state_dict(torch.load('/mnt/models/model.pth', map_location='cpu'))\n        self.model.eval()\n        self.ready = True\n\n    def predict(self, payload: Dict) -> Dict:\n        if not self.ready:\n            raise RuntimeError(\"Model not loaded\")\n        \n        # Decode base64 image\n        image_data = base64.b64decode(payload[\"instances\"][0][\"image\"])\n        image = Image.open(io.BytesIO(image_data)).convert('L')\n        \n        # Preprocess\n        input_tensor = self.transform(image).unsqueeze(0)\n        \n        # Predict\n        with torch.no_grad():\n            output = self.model(input_tensor)\n            probabilities = torch.softmax(output, dim=1)\n            predicted_class = torch.argmax(probabilities, dim=1).item()\n            confidence = probabilities[0][predicted_class].item()\n        \n        return {\n            \"predictions\": [{\n                \"class\": predicted_class,\n                \"confidence\": confidence,\n                \"probabilities\": probabilities[0].tolist()\n            }]\n        }\n\nif __name__ == \"__main__\":\n    model = PyTorchMNISTPredictor(\"pytorch-mnist-predictor\")\n    model.load()\n    kserve.ModelServer().start([model])\n```\n\n### InferenceService YAML\n\n```yaml\napiVersion: serving.kserve.io/v1beta1\nkind: InferenceService\nmetadata:\n  name: pytorch-mnist-predictor\n  namespace: pytorch-training\nspec:\n  predictor:\n    containers:\n    - name: kserve-container\n      image: your-registry/pytorch-predictor:latest\n      ports:\n      - containerPort: 8080\n        protocol: TCP\n      volumeMounts:\n      - name: model-storage\n        mountPath: /mnt/models\n      resources:\n        requests:\n          cpu: \"100m\"\n          memory: \"1Gi\"\n        limits:\n          cpu: \"1\"\n          memory: \"2Gi\"\n    volumes:\n    - name: model-storage\n      persistentVolumeClaim:\n        claimName: model-pvc\n```\n\n## Complete Pipeline Example\n\n### Kubeflow Pipeline with PyTorch\n\n```python\nimport kfp\nfrom kfp import dsl\nfrom kfp.components import create_component_from_func\n\ndef preprocess_data_op():\n    return dsl.ContainerOp(\n        name='preprocess-data',\n        image='your-registry/data-preprocessing:latest',\n        command=['python', 'preprocess.py'],\n        file_outputs={'dataset_path': '/tmp/dataset_path.txt'}\n    )\n\ndef train_model_op(dataset_path, lr: float = 0.01, batch_size: int = 64):\n    return dsl.ContainerOp(\n        name='train-model',\n        image='your-registry/pytorch-training:latest',\n        command=['python', 'train.py'],\n        arguments=[\n            '--data-path', dataset_path,\n            '--lr', lr,\n            '--batch-size', batch_size,\n            '--model-dir', '/tmp/model'\n        ],\n        file_outputs={'model_path': '/tmp/model_path.txt'}\n    )\n\ndef evaluate_model_op(model_path, dataset_path):\n    return dsl.ContainerOp(\n        name='evaluate-model',\n        image='your-registry/pytorch-evaluation:latest',\n        command=['python', 'evaluate.py'],\n        arguments=[\n            '--model-path', model_path,\n            '--data-path', dataset_path\n        ],\n        file_outputs={'metrics': '/tmp/metrics.json'}\n    )\n\ndef deploy_model_op(model_path):\n    return dsl.ContainerOp(\n        name='deploy-model',\n        image='your-registry/model-deployment:latest',\n        command=['python', 'deploy.py'],\n        arguments=['--model-path', model_path]\n    )\n\n@dsl.pipeline(\n    name='PyTorch Training Pipeline',\n    description='Complete PyTorch training and deployment pipeline'\n)\ndef pytorch_training_pipeline(\n    lr: float = 0.01,\n    batch_size: int = 64,\n    epochs: int = 10\n):\n    # Data preprocessing\n    preprocess_task = preprocess_data_op()\n    \n    # Model training\n    train_task = train_model_op(\n        dataset_path=preprocess_task.outputs['dataset_path'],\n        lr=lr,\n        batch_size=batch_size\n    )\n    \n    # Model evaluation\n    evaluate_task = evaluate_model_op(\n        model_path=train_task.outputs['model_path'],\n        dataset_path=preprocess_task.outputs['dataset_path']\n    )\n    \n    # Conditional deployment based on accuracy\n    with dsl.Condition(evaluate_task.outputs['metrics'], '>', '0.9'):\n        deploy_task = deploy_model_op(\n            model_path=train_task.outputs['model_path']\n        )\n\n# Compile and run the pipeline\nif __name__ == '__main__':\n    kfp.compiler.Compiler().compile(pytorch_training_pipeline, 'pytorch_pipeline.yaml')\n```\n\n## Best Practices\n\n### 1. Resource Management\n- Always specify resource requests and limits\n- Use GPU resources efficiently with proper scheduling\n- Implement proper cleanup procedures\n\n### 2. Data Management\n- Use persistent volumes for model storage\n- Implement data versioning\n- Use distributed storage for large datasets\n\n### 3. Monitoring and Logging\n- Implement comprehensive logging\n- Use metrics collection for model performance\n- Set up alerts for training failures\n\n### 4. Security\n- Use proper RBAC configurations\n- Secure container images\n- Implement secrets management for sensitive data\n\n### 5. Scalability\n- Design for horizontal scaling\n- Use distributed training for large models\n- Implement efficient data loading pipelines\n\n### 6. Model Versioning\n- Tag and version your models\n- Implement A/B testing for model deployments\n- Use model registries for tracking\n\n### 7. Error Handling\n- Implement robust error handling in training scripts\n- Use appropriate restart policies\n- Set up proper monitoring and alerting\n\nThis guide provides a comprehensive foundation for using Kubeflow with PyTorch for deep learning workflows. Adapt the examples to your specific use cases and requirements.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}