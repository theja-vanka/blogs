{
  "hash": "7e40d427eadbebf1a6ca50b838696505",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"DINOv2 Student-Teacher Network Training Guide\"\nauthor: \"Krishnatheja Vanka\"\ndate: \"2025-05-28\"\ncategories: [code, advanced]\nformat:\n  html:\n    code-fold: false\nexecute:\n  echo: true\n  timing: true\njupyter: python3\n---\n\n# DINOv2 Student-Teacher Network Training Guide\n\n![](dino.png)\n\n\nThis guide provides a complete implementation for training a DINOv2 (DINO version 2) student-teacher network from scratch using PyTorch. DINOv2 is a self-supervised learning method that trains vision transformers without labels using a teacher-student distillation framework.\n\n## Table of Contents\n1. [Overview](#overview)\n2. [Architecture Components](#architecture-components)\n3. [Implementation](#implementation)\n4. [Training Loop](#training-loop)\n5. [Usage Example](#usage-example)\n\n## Overview\n\nDINOv2 uses a student-teacher framework where:\n\n- **Teacher network**: Provides stable targets (EMA of student weights)\n- **Student network**: Learns to match teacher outputs\n- **Multi-crop strategy**: Uses different image crops for robustness\n- **Centering mechanism**: Prevents mode collapse\n\n## Architecture Components\n\n### Vision Transformer (ViT) Backbone\n\n#### Import Libraries\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.distributed as dist\nfrom torch.utils.data import DataLoader\nimport torchvision.transforms as transforms\nfrom torchvision.datasets import ImageFolder\nimport math\nimport numpy as np\nfrom typing import Optional, List, Tuple\n\n```\n#### Patch Embedding\n```python\nclass PatchEmbed(nn.Module):\n    \"\"\"Image to Patch Embedding\"\"\"\n    def __init__(self, img_size=224, patch_size=16, in_chans=3, embed_dim=768):\n        super().__init__()\n        self.img_size = img_size\n        self.patch_size = patch_size\n        self.num_patches = (img_size // patch_size) ** 2\n        \n        self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=patch_size, stride=patch_size)\n    \n    def forward(self, x):\n        B, C, H, W = x.shape\n        x = self.proj(x).flatten(2).transpose(1, 2)  # [B, N, D]\n        return x\n```\n\n#### Multi-head Self-Attention\n```python\nclass MultiheadAttention(nn.Module):\n    \"\"\"Multi-head Self Attention\"\"\"\n    def __init__(self, embed_dim, num_heads, dropout=0.0):\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.head_dim = embed_dim // num_heads\n        \n        self.qkv = nn.Linear(embed_dim, embed_dim * 3)\n        self.proj = nn.Linear(embed_dim, embed_dim)\n        self.dropout = nn.Dropout(dropout)\n    \n    def forward(self, x):\n        B, N, D = x.shape\n        qkv = self.qkv(x).reshape(B, N, 3, self.num_heads, self.head_dim).permute(2, 0, 3, 1, 4)\n        q, k, v = qkv[0], qkv[1], qkv[2]\n        \n        attn = (q @ k.transpose(-2, -1)) * (self.head_dim ** -0.5)\n        attn = attn.softmax(dim=-1)\n        attn = self.dropout(attn)\n        \n        x = (attn @ v).transpose(1, 2).reshape(B, N, D)\n        x = self.proj(x)\n        return x\n```\n\n#### Transformer Block\n```python\nclass TransformerBlock(nn.Module):\n    \"\"\"Transformer Block\"\"\"\n    def __init__(self, embed_dim, num_heads, mlp_ratio=4.0, dropout=0.0):\n        super().__init__()\n        self.norm1 = nn.LayerNorm(embed_dim)\n        self.attn = MultiheadAttention(embed_dim, num_heads, dropout)\n        self.norm2 = nn.LayerNorm(embed_dim)\n        \n        mlp_hidden_dim = int(embed_dim * mlp_ratio)\n        self.mlp = nn.Sequential(\n            nn.Linear(embed_dim, mlp_hidden_dim),\n            nn.GELU(),\n            nn.Dropout(dropout),\n            nn.Linear(mlp_hidden_dim, embed_dim),\n            nn.Dropout(dropout)\n        )\n    \n    def forward(self, x):\n        x = x + self.attn(self.norm1(x))\n        x = x + self.mlp(self.norm2(x))\n        return x\n```\n\n#### Vision Transformer\n```python\nclass VisionTransformer(nn.Module):\n    \"\"\"Vision Transformer\"\"\"\n    def __init__(self, img_size=224, patch_size=16, in_chans=3, embed_dim=768, \n                 depth=12, num_heads=12, mlp_ratio=4.0, dropout=0.0):\n        super().__init__()\n        self.patch_embed = PatchEmbed(img_size, patch_size, in_chans, embed_dim)\n        num_patches = self.patch_embed.num_patches\n        \n        self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim))\n        self.pos_embed = nn.Parameter(torch.zeros(1, num_patches + 1, embed_dim))\n        self.dropout = nn.Dropout(dropout)\n        \n        self.blocks = nn.ModuleList([\n            TransformerBlock(embed_dim, num_heads, mlp_ratio, dropout)\n            for _ in range(depth)\n        ])\n        \n        self.norm = nn.LayerNorm(embed_dim)\n        \n        # Initialize weights\n        self._init_weights()\n    \n    def _init_weights(self):\n        nn.init.trunc_normal_(self.pos_embed, std=0.02)\n        nn.init.trunc_normal_(self.cls_token, std=0.02)\n        \n        for m in self.modules():\n            if isinstance(m, nn.Linear):\n                nn.init.trunc_normal_(m.weight, std=0.02)\n                if m.bias is not None:\n                    nn.init.constant_(m.bias, 0)\n            elif isinstance(m, nn.LayerNorm):\n                nn.init.constant_(m.bias, 0)\n                nn.init.constant_(m.weight, 1.0)\n    \n    def forward(self, x):\n        B = x.shape[0]\n        x = self.patch_embed(x)\n        \n        cls_tokens = self.cls_token.expand(B, -1, -1)\n        x = torch.cat((cls_tokens, x), dim=1)\n        x = x + self.pos_embed\n        x = self.dropout(x)\n        \n        for block in self.blocks:\n            x = block(x)\n        \n        x = self.norm(x)\n        return x[:, 0]  # Return CLS token\n```\n\n#### Dino Head\n```python\nclass DINOHead(nn.Module):\n    \"\"\"DINO Projection Head\"\"\"\n    def __init__(self, in_dim, out_dim, hidden_dim=2048, bottleneck_dim=256, \n                 num_layers=3, use_bn=False, norm_last_layer=True):\n        super().__init__()\n        \n        if num_layers == 1:\n            self.mlp = nn.Linear(in_dim, bottleneck_dim)\n        else:\n            layers = [nn.Linear(in_dim, hidden_dim)]\n            if use_bn:\n                layers.append(nn.BatchNorm1d(hidden_dim))\n            layers.append(nn.GELU())\n            \n            for _ in range(num_layers - 2):\n                layers.append(nn.Linear(hidden_dim, hidden_dim))\n                if use_bn:\n                    layers.append(nn.BatchNorm1d(hidden_dim))\n                layers.append(nn.GELU())\n            \n            layers.append(nn.Linear(hidden_dim, bottleneck_dim))\n            self.mlp = nn.Sequential(*layers)\n        \n        self.apply(self._init_weights)\n        \n        self.last_layer = nn.utils.weight_norm(\n            nn.Linear(bottleneck_dim, out_dim, bias=False)\n        )\n        self.last_layer.weight_g.data.fill_(1)\n        if norm_last_layer:\n            self.last_layer.weight_g.requires_grad = False\n    \n    def _init_weights(self, m):\n        if isinstance(m, nn.Linear):\n            nn.init.trunc_normal_(m.weight, std=0.02)\n            if m.bias is not None:\n                nn.init.constant_(m.bias, 0)\n    \n    def forward(self, x):\n        x = self.mlp(x)\n        x = nn.functional.normalize(x, dim=-1, p=2)\n        x = self.last_layer(x)\n        return x\n```\n\n#### DINOv2 Model\n```python\nclass DINOv2(nn.Module):\n    \"\"\"Complete DINOv2 Model\"\"\"\n    def __init__(self, backbone_args, head_args):\n        super().__init__()\n        self.backbone = VisionTransformer(**backbone_args)\n        self.head = DINOHead(**head_args)\n    \n    def forward(self, x):\n        x = self.backbone(x)\n        x = self.head(x)\n        return x\n```\n\n### Data Augmentation and Multi-Crop Strategy\n\n#### Multi-Crop Data Augmentation\n\n```python\nclass MultiCropDataAugmentation:\n    \"\"\"Multi-crop data augmentation for DINOv2\"\"\"\n    def __init__(self, global_crops_scale=(0.4, 1.0), local_crops_scale=(0.05, 0.4),\n                 global_crops_number=2, local_crops_number=6, size_crops=(224, 96)):\n        self.global_crops_number = global_crops_number\n        self.local_crops_number = local_crops_number\n        \n        # Global crops (teacher and student)\n        self.global_transform = transforms.Compose([\n            transforms.RandomResizedCrop(size_crops[0], scale=global_crops_scale, \n                                       interpolation=transforms.InterpolationMode.BICUBIC),\n            transforms.RandomHorizontalFlip(p=0.5),\n            transforms.ColorJitter(brightness=0.4, contrast=0.4, saturation=0.2, hue=0.1),\n            transforms.RandomGrayscale(p=0.2),\n            GaussianBlur(p=1.0),\n            Solarization(p=0.0),\n            transforms.ToTensor(),\n            transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225))\n        ])\n        \n        # Local crops (student only)\n        self.local_transform = transforms.Compose([\n            transforms.RandomResizedCrop(size_crops[1], scale=local_crops_scale,\n                                       interpolation=transforms.InterpolationMode.BICUBIC),\n            transforms.RandomHorizontalFlip(p=0.5),\n            transforms.ColorJitter(brightness=0.4, contrast=0.4, saturation=0.2, hue=0.1),\n            transforms.RandomGrayscale(p=0.2),\n            GaussianBlur(p=0.5),\n            Solarization(p=0.2),\n            transforms.ToTensor(),\n            transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225))\n        ])\n    \n    def __call__(self, image):\n        crops = []\n        \n        # Global crops\n        for _ in range(self.global_crops_number):\n            crops.append(self.global_transform(image))\n        \n        # Local crops\n        for _ in range(self.local_crops_number):\n            crops.append(self.local_transform(image))\n        \n        return crops\n```\n\n#### Augmentation Utilities\n\n```python\nclass GaussianBlur:\n    \"\"\"Gaussian blur augmentation\"\"\"\n    def __init__(self, p=0.5, radius_min=0.1, radius_max=2.0):\n        self.prob = p\n        self.radius_min = radius_min\n        self.radius_max = radius_max\n    \n    def __call__(self, img):\n        if torch.rand(1) < self.prob:\n            radius = self.radius_min + torch.rand(1) * (self.radius_max - self.radius_min)\n            return transforms.functional.gaussian_blur(img, kernel_size=9, sigma=radius.item())\n        return img\n\nclass Solarization:\n    \"\"\"Solarization augmentation\"\"\"\n    def __init__(self, p=0.2):\n        self.p = p\n    \n    def __call__(self, img):\n        if torch.rand(1) < self.p:\n            return transforms.functional.solarize(img, threshold=128)\n        return img\n```\n\n### Loss Functions and Training Components\n\n```python\nclass DINOLoss(nn.Module):\n    \"\"\"DINO Loss with centering and sharpening\"\"\"\n    def __init__(self, out_dim, ncrops, warmup_teacher_temp=0.04, \n                 teacher_temp=0.04, warmup_teacher_temp_epochs=0, \n                 student_temp=0.1, center_momentum=0.9):\n        super().__init__()\n        self.student_temp = student_temp\n        self.center_momentum = center_momentum\n        self.ncrops = ncrops\n        self.register_buffer(\"center\", torch.zeros(1, out_dim))\n        \n        # Temperature schedule\n        self.teacher_temp_schedule = np.concatenate((\n            np.linspace(warmup_teacher_temp, teacher_temp, warmup_teacher_temp_epochs),\n            np.ones(1000) * teacher_temp  # Assume max 1000 epochs\n        ))\n    \n    def forward(self, student_output, teacher_output, epoch):\n        \"\"\"\n        Cross-entropy between softmax outputs of the teacher and student networks.\n        \"\"\"\n        student_out = student_output / self.student_temp\n        student_out = student_out.chunk(self.ncrops)\n        \n        # Teacher centering and sharpening\n        temp = self.teacher_temp_schedule[epoch]\n        teacher_out = F.softmax((teacher_output - self.center) / temp, dim=-1)\n        teacher_out = teacher_out.detach().chunk(2)  # Only 2 global crops for teacher\n        \n        total_loss = 0\n        n_loss_terms = 0\n        \n        for iq, q in enumerate(teacher_out):\n            for v in range(len(student_out)):\n                if v == iq:\n                    continue  # Skip same crop\n                loss = torch.sum(-q * F.log_softmax(student_out[v], dim=-1), dim=-1)\n                total_loss += loss.mean()\n                n_loss_terms += 1\n        \n        total_loss /= n_loss_terms\n        self.update_center(teacher_output)\n        return total_loss\n    \n    @torch.no_grad()\n    def update_center(self, teacher_output):\n        \"\"\"Update center used for teacher output.\"\"\"\n        batch_center = torch.sum(teacher_output, dim=0, keepdim=True)\n        batch_center = batch_center / len(teacher_output)\n        \n        # EMA update\n        self.center = self.center * self.center_momentum + batch_center * (1 - self.center_momentum)\n```\n#### Training Utilities\n```python\n@torch.no_grad()\ndef update_teacher(student, teacher, momentum):\n    \"\"\"EMA update of the teacher network.\"\"\"\n    for param_student, param_teacher in zip(student.parameters(), teacher.parameters()):\n        param_teacher.data.mul_(momentum).add_(param_student.data, alpha=1 - momentum)\n\ndef cosine_scheduler(base_value, final_value, epochs, niter_per_ep, warmup_epochs=0):\n    \"\"\"Cosine learning rate schedule with linear warmup.\"\"\"\n    warmup_schedule = np.array([])\n    warmup_iters = warmup_epochs * niter_per_ep\n    \n    if warmup_epochs > 0:\n        warmup_schedule = np.linspace(0, base_value, warmup_iters)\n    \n    iters = np.arange(epochs * niter_per_ep - warmup_iters)\n    schedule = final_value + 0.5 * (base_value - final_value) * (1 + np.cos(np.pi * iters / len(iters)))\n    \n    schedule = np.concatenate((warmup_schedule, schedule))\n    assert len(schedule) == epochs * niter_per_ep\n    return schedule\n```\n\n## Training Loop Implementation\n\n```python\nclass DINOv2Trainer:\n    \"\"\"DINOv2 Training Pipeline\"\"\"\n    def __init__(self, config):\n        self.config = config\n        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n        \n        # Model architecture configs\n        backbone_args = {\n            'img_size': 224,\n            'patch_size': 16,\n            'embed_dim': 768,\n            'depth': 12,\n            'num_heads': 12,\n            'mlp_ratio': 4.0,\n            'dropout': 0.0\n        }\n        \n        head_args = {\n            'in_dim': 768,\n            'out_dim': 65536,  # Large output dimension\n            'hidden_dim': 2048,\n            'bottleneck_dim': 256\n        }\n        \n        # Initialize student and teacher networks\n        self.student = DINOv2(backbone_args, head_args).to(self.device)\n        self.teacher = DINOv2(backbone_args, head_args).to(self.device)\n        \n        # Teacher starts as copy of student\n        self.teacher.load_state_dict(self.student.state_dict())\n        \n        # Teacher parameters are not updated by gradients\n        for p in self.teacher.parameters():\n            p.requires_grad = False\n        \n        # Loss function\n        self.dino_loss = DINOLoss(\n            out_dim=head_args['out_dim'],\n            ncrops=8,  # 2 global + 6 local crops\n            student_temp=0.1,\n            teacher_temp=0.04,\n            center_momentum=0.9\n        ).to(self.device)\n        \n        # Optimizer\n        self.optimizer = torch.optim.AdamW(\n            self.student.parameters(),\n            lr=config['base_lr'],\n            weight_decay=config['weight_decay']\n        )\n        \n        # Learning rate scheduler\n        self.lr_schedule = cosine_scheduler(\n            config['base_lr'],\n            config['final_lr'],\n            config['epochs'],\n            config['niter_per_ep'],\n            config['warmup_epochs']\n        )\n        \n        # Momentum schedule for teacher updates\n        self.momentum_schedule = cosine_scheduler(\n            config['momentum_teacher'],\n            1.0,\n            config['epochs'],\n            config['niter_per_ep']\n        )\n    \n    def train_epoch(self, dataloader, epoch):\n        \"\"\"Train for one epoch\"\"\"\n        self.student.train()\n        self.teacher.eval()\n        \n        total_loss = 0\n        num_batches = len(dataloader)\n        \n        for it, (images, _) in enumerate(dataloader):\n            # Update learning rate\n            lr = self.lr_schedule[epoch * num_batches + it]\n            for param_group in self.optimizer.param_groups:\n                param_group['lr'] = lr\n            \n            # Move to device and prepare crops\n            images = [im.to(self.device, non_blocking=True) for im in images]\n            \n            # Teacher forward pass (only on global crops)\n            teacher_output = self.teacher(torch.cat(images[:2]))\n            \n            # Student forward pass (on all crops)\n            student_output = self.student(torch.cat(images))\n            \n            # Compute loss\n            loss = self.dino_loss(student_output, teacher_output, epoch)\n            \n            # Backward pass\n            self.optimizer.zero_grad()\n            loss.backward()\n            \n            # Gradient clipping\n            torch.nn.utils.clip_grad_norm_(self.student.parameters(), max_norm=3.0)\n            \n            self.optimizer.step()\n            \n            # Update teacher with EMA\n            momentum = self.momentum_schedule[epoch * num_batches + it]\n            update_teacher(self.student, self.teacher, momentum)\n            \n            total_loss += loss.item()\n            \n            if it % 100 == 0:\n                print(f'Epoch {epoch}, Iter {it}/{num_batches}, Loss: {loss.item():.4f}, LR: {lr:.6f}')\n        \n        return total_loss / num_batches\n    \n    def train(self, dataloader):\n        \"\"\"Full training loop\"\"\"\n        for epoch in range(self.config['epochs']):\n            avg_loss = self.train_epoch(dataloader, epoch)\n            print(f'Epoch {epoch}/{self.config[\"epochs\"]}, Average Loss: {avg_loss:.4f}')\n            \n            # Save checkpoint\n            if epoch % self.config['save_every'] == 0:\n                self.save_checkpoint(epoch)\n    \n    def save_checkpoint(self, epoch):\n        \"\"\"Save model checkpoint\"\"\"\n        checkpoint = {\n            'epoch': epoch,\n            'student_state_dict': self.student.state_dict(),\n            'teacher_state_dict': self.teacher.state_dict(),\n            'optimizer_state_dict': self.optimizer.state_dict(),\n            'config': self.config\n        }\n        torch.save(checkpoint, f'dinov2_checkpoint_epoch_{epoch}.pth')\n```\n\n## Usage Example\n\n```python\ndef main():\n    # Training configuration\n    config = {\n        'base_lr': 5e-4,\n        'final_lr': 1e-6,\n        'weight_decay': 0.04,\n        'momentum_teacher': 0.996,\n        'epochs': 100,\n        'warmup_epochs': 10,\n        'batch_size': 64,\n        'save_every': 10,\n        'niter_per_ep': None  # Will be set after dataloader creation\n    }\n    \n    # Data setup\n    transform = MultiCropDataAugmentation()\n    dataset = ImageFolder(root='path/to/your/dataset', transform=transform)\n    dataloader = DataLoader(\n        dataset, \n        batch_size=config['batch_size'], \n        shuffle=True, \n        num_workers=4,\n        pin_memory=True,\n        drop_last=True\n    )\n    \n    config['niter_per_ep'] = len(dataloader)\n    \n    # Initialize trainer and start training\n    trainer = DINOv2Trainer(config)\n    trainer.train(dataloader)\n\nmain()\n```\n\n## Key Features Implemented\n\n1. **Vision Transformer Backbone**: Complete ViT implementation with patch embedding, multi-head attention, and transformer blocks\n2. **Multi-crop Strategy**: Global and local crops with different augmentations\n3. **Teacher-Student Framework**: EMA updates for teacher network\n4. **DINO Loss**: Cross-entropy loss with centering mechanism to prevent collapse\n5. **Learning Rate Scheduling**: Cosine annealing with warmup\n6. **Gradient Clipping**: Stability during training\n7. **Checkpointing**: Save/load model states\n\n## Training Tips\n\n1. **Batch Size**: Use large batch sizes (256-1024) for better performance\n2. **Data Augmentation**: Strong augmentations are crucial for self-supervised learning\n3. **Temperature Scheduling**: Gradually increase teacher temperature\n4. **Momentum Scheduling**: Start with high momentum and decrease over time\n5. **Multi-GPU Training**: Use DistributedDataParallel for faster training\n\nThis implementation provides a solid foundation for training DINOv2 models. Adjust hyperparameters based on your dataset size and computational resources.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}