<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Krishnatheja Vanka">
<meta name="dcterms.date" content="2025-07-05">

<title>Convolutional Kolmogorov-Arnold Networks vs Convolutional Neural Networks: A Comprehensive Analysis – Krishnatheja Vanka’s Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-62c28fcd870f55f61984f019219cbd7c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Krishnatheja Vanka’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/theja-vanka"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Convolutional Kolmogorov-Arnold Networks vs Convolutional Neural Networks: A Comprehensive Analysis</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">research</div>
                <div class="quarto-category">advanced</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Krishnatheja Vanka </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 5, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="convolutional-kolmogorov-arnold-networks-vs-convolutional-neural-networks-a-comprehensive-analysis" class="level1">
<h1>Convolutional Kolmogorov-Arnold Networks vs Convolutional Neural Networks: A Comprehensive Analysis</h1>
<p><img src="ckan-vs-cnn.png" class="img-fluid"></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The landscape of deep learning has been revolutionized by Convolutional Neural Networks (CNNs), which have dominated computer vision tasks for over a decade. However, a new paradigm has emerged that challenges the fundamental assumptions of traditional neural architectures: Convolutional Kolmogorov-Arnold Networks (Convolutional KANs). This innovative approach represents a significant departure from conventional neural network design, offering enhanced parameter efficiency, interpretability, and expressive power.</p>
</section>
<section id="theoretical-foundation" class="level2">
<h2 class="anchored" data-anchor-id="theoretical-foundation">Theoretical Foundation</h2>
<section id="the-kolmogorov-arnold-representation-theorem" class="level3">
<h3 class="anchored" data-anchor-id="the-kolmogorov-arnold-representation-theorem">The Kolmogorov-Arnold Representation Theorem</h3>
<p>The theoretical foundation of KANs lies in the Kolmogorov-Arnold representation theorem, which states that any multivariate continuous function on a bounded domain can be represented as a finite composition of continuous functions of a single variable and the binary operation of addition. This mathematical principle fundamentally challenges the traditional multi-layer perceptron (MLP) approach and provides the basis for a new class of neural networks.</p>
<p>The theorem can be formally expressed as:</p>
<p><span class="math display">\[
f(x_1, x_2, \ldots, x_n) = \sum_{q=0}^{2n} \Phi_q\left( \sum_{p=1}^{n} \phi_{q,p}(x_p) \right)
\]</span></p>
<p>Where <span class="math inline">\(\phi_{i}\)</span> and <span class="math inline">\(\phi_{i,j}\)</span> are continuous univariate functions, and f is the multivariate function being approximated.</p>
</section>
<section id="architectural-differences" class="level3">
<h3 class="anchored" data-anchor-id="architectural-differences">Architectural Differences</h3>
<p>The fundamental architectural difference between traditional neural networks and KANs lies in the placement and nature of activation functions:</p>
<ul>
<li><strong>Traditional MLPs/CNNs</strong>: Fixed activation functions on nodes (neurons), with linear weights on edges</li>
<li><strong>KANs</strong>: Learnable activation functions on edges (weights), with no linear weights at all</li>
</ul>
</section>
</section>
<section id="convolutional-neural-networks-the-established-paradigm" class="level2">
<h2 class="anchored" data-anchor-id="convolutional-neural-networks-the-established-paradigm">Convolutional Neural Networks: The Established Paradigm</h2>
<section id="architecture-overview" class="level3">
<h3 class="anchored" data-anchor-id="architecture-overview">Architecture Overview</h3>
<p>CNNs have been the backbone of computer vision applications since their breakthrough in the early 2010s. The typical CNN architecture consists of:</p>
<ol type="1">
<li><strong>Convolutional Layers</strong>: Apply fixed-weight kernels with linear transformations</li>
<li><strong>Activation Functions</strong>: Non-linear functions (ReLU, sigmoid, tanh) applied to neurons</li>
<li><strong>Pooling Layers</strong>: Downsample feature maps to reduce computational complexity</li>
<li><strong>Fully Connected Layers</strong>: Dense layers for final classification or regression</li>
</ol>
</section>
<section id="key-characteristics" class="level3">
<h3 class="anchored" data-anchor-id="key-characteristics">Key Characteristics</h3>
<ul>
<li><strong>Parameter Sharing</strong>: Convolutional kernels share weights across spatial locations</li>
<li><strong>Translation Invariance</strong>: Ability to detect features regardless of their position in the input</li>
<li><strong>Hierarchical Feature Learning</strong>: Progressive abstraction from low-level to high-level features</li>
<li><strong>Fixed Activation Functions</strong>: Predetermined non-linear functions that remain constant during training</li>
</ul>
</section>
<section id="limitations" class="level3">
<h3 class="anchored" data-anchor-id="limitations">Limitations</h3>
<p>Despite their success, CNNs face several inherent limitations:</p>
<ol type="1">
<li><strong>Parameter Inefficiency</strong>: Large numbers of parameters required for complex tasks</li>
<li><strong>Limited Interpretability</strong>: Black-box nature makes understanding difficult</li>
<li><strong>Fixed Representational Capacity</strong>: Predetermined activation functions limit adaptability</li>
<li><strong>Scaling Challenges</strong>: Performance improvements often require significantly larger models</li>
</ol>
</section>
</section>
<section id="convolutional-kolmogorov-arnold-networks-the-new-paradigm" class="level2">
<h2 class="anchored" data-anchor-id="convolutional-kolmogorov-arnold-networks-the-new-paradigm">Convolutional Kolmogorov-Arnold Networks: The New Paradigm</h2>
<section id="architecture-innovation" class="level3">
<h3 class="anchored" data-anchor-id="architecture-innovation">Architecture Innovation</h3>
<p>Convolutional KANs represent a revolutionary approach to neural network design by replacing traditional fixed-weight kernels with learnable non-linear functions. The key innovations include:</p>
<ol type="1">
<li><strong>Spline-Based Convolutional Layers</strong>: Replace fixed linear weights with learnable spline functions</li>
<li><strong>Edge-Based Activation</strong>: Activation functions are learned on the connections between neurons</li>
<li><strong>Adaptive Kernel Functions</strong>: Convolutional operations with learnable, non-linear transformations</li>
<li><strong>Flexible Representational Power</strong>: Ability to adapt the network’s fundamental computational primitives</li>
</ol>
</section>
<section id="technical-implementation" class="level3">
<h3 class="anchored" data-anchor-id="technical-implementation">Technical Implementation</h3>
<p>In Convolutional KANs, every weight parameter is replaced by a univariate function parametrized as a B-spline. The spline functions provide:</p>
<ul>
<li><strong>Continuous Differentiability</strong>: Smooth gradients for effective backpropagation</li>
<li><strong>Local Control</strong>: Ability to modify function behavior in specific regions</li>
<li><strong>Efficient Representation</strong>: Compact parametrization of complex functions</li>
<li><strong>Numerical Stability</strong>: Well-conditioned optimization properties</li>
</ul>
</section>
<section id="architectural-flexibility" class="level3">
<h3 class="anchored" data-anchor-id="architectural-flexibility">Architectural Flexibility</h3>
<p>The Convolutional KAN architecture allows for various configurations:</p>
<ul>
<li><strong>Hybrid Approaches</strong>: Combination of KAN convolutional layers with traditional MLPs</li>
<li><strong>Full KAN Networks</strong>: Complete replacement of traditional layers with KAN equivalents</li>
<li><strong>Scalable Design</strong>: Adaptable to different problem complexities and computational constraints</li>
</ul>
</section>
</section>
<section id="comparative-analysis" class="level2">
<h2 class="anchored" data-anchor-id="comparative-analysis">Comparative Analysis</h2>
<section id="parameter-efficiency" class="level3">
<h3 class="anchored" data-anchor-id="parameter-efficiency">Parameter Efficiency</h3>
<p>One of the most significant advantages of Convolutional KANs is their parameter efficiency. Research has demonstrated that Convolutional KANs require significantly fewer parameters compared to traditional CNNs while maintaining or improving performance. This efficiency stems from:</p>
<ol type="1">
<li><strong>Learnable Function Approximation</strong>: Spline-based functions can represent complex transformations with fewer parameters</li>
<li><strong>Adaptive Representation</strong>: Network can learn optimal activation functions for specific tasks</li>
<li><strong>Reduced Redundancy</strong>: Elimination of fixed linear weights reduces parameter overhead</li>
</ol>
</section>
<section id="expressive-power" class="level3">
<h3 class="anchored" data-anchor-id="expressive-power">Expressive Power</h3>
<p>Convolutional KANs offer superior expressive power through:</p>
<ol type="1">
<li><strong>Adaptive Activation Functions</strong>: Ability to learn task-specific non-linearities</li>
<li><strong>Enhanced Function Approximation</strong>: Theoretical foundation in universal approximation</li>
<li><strong>Flexible Computational Primitives</strong>: Learnable spline functions provide greater representational capacity</li>
</ol>
</section>
<section id="interpretability" class="level3">
<h3 class="anchored" data-anchor-id="interpretability">Interpretability</h3>
<p>KANs provide enhanced interpretability compared to traditional CNNs:</p>
<ol type="1">
<li><strong>Visualizable Functions</strong>: Learned spline functions can be directly visualized and analyzed</li>
<li><strong>Human Interaction</strong>: Easier to understand and modify network behavior</li>
<li><strong>Mathematical Transparency</strong>: Clear mathematical foundation enables better analysis</li>
</ol>
</section>
<section id="performance-characteristics" class="level3">
<h3 class="anchored" data-anchor-id="performance-characteristics">Performance Characteristics</h3>
<p>Empirical evaluations have shown that Convolutional KANs can achieve:</p>
<ul>
<li><strong>Comparable or Superior Accuracy</strong>: Match or exceed CNN performance on various tasks</li>
<li><strong>Faster Neural Scaling Laws</strong>: More efficient scaling with increased model complexity</li>
<li><strong>Better Generalization</strong>: Improved performance on unseen data</li>
</ul>
</section>
</section>
<section id="practical-applications-and-limitations" class="level2">
<h2 class="anchored" data-anchor-id="practical-applications-and-limitations">Practical Applications and Limitations</h2>
<section id="suitable-applications" class="level3">
<h3 class="anchored" data-anchor-id="suitable-applications">Suitable Applications</h3>
<p>Convolutional KANs are particularly well-suited for:</p>
<ol type="1">
<li><strong>Computer Vision Tasks</strong>: Image classification, object detection, segmentation</li>
<li><strong>Pattern Recognition</strong>: Complex pattern matching with adaptive feature extraction</li>
<li><strong>Scientific Computing</strong>: Problems requiring interpretable and efficient models</li>
<li><strong>Resource-Constrained Environments</strong>: Applications with limited computational resources</li>
</ol>
</section>
<section id="current-limitations" class="level3">
<h3 class="anchored" data-anchor-id="current-limitations">Current Limitations</h3>
<p>Despite their advantages, Convolutional KANs face certain challenges:</p>
<ol type="1">
<li><strong>Computational Complexity</strong>: Spline function evaluation may increase computational overhead</li>
<li><strong>Training Complexity</strong>: More complex optimization landscape due to learnable activation functions</li>
<li><strong>Limited Ecosystem</strong>: Fewer available tools and implementations compared to CNNs</li>
<li><strong>Scaling Challenges</strong>: Performance on very large-scale problems remains to be fully validated</li>
</ol>
</section>
</section>
<section id="implementation-considerations" class="level2">
<h2 class="anchored" data-anchor-id="implementation-considerations">Implementation Considerations</h2>
<section id="training-strategies" class="level3">
<h3 class="anchored" data-anchor-id="training-strategies">Training Strategies</h3>
<p>Effective training of Convolutional KANs requires:</p>
<ol type="1">
<li><strong>Careful Initialization</strong>: Proper initialization of spline parameters</li>
<li><strong>Adaptive Learning Rates</strong>: Different learning rates for different parameter types</li>
<li><strong>Regularization Techniques</strong>: Preventing overfitting in the learnable activation functions</li>
<li><strong>Numerical Stability</strong>: Ensuring stable spline function evaluation</li>
</ol>
</section>
<section id="hyperparameter-tuning" class="level3">
<h3 class="anchored" data-anchor-id="hyperparameter-tuning">Hyperparameter Tuning</h3>
<p>Key hyperparameters include:</p>
<ul>
<li><strong>Spline Order</strong>: Degree of the B-spline basis functions</li>
<li><strong>Grid Size</strong>: Number of control points for spline functions</li>
<li><strong>Regularization Strength</strong>: Balance between fitting and smoothness</li>
<li><strong>Learning Rate Schedules</strong>: Optimization strategy for different parameter types</li>
</ul>
</section>
</section>
<section id="future-directions-and-research-opportunities" class="level2">
<h2 class="anchored" data-anchor-id="future-directions-and-research-opportunities">Future Directions and Research Opportunities</h2>
<section id="emerging-research-areas" class="level3">
<h3 class="anchored" data-anchor-id="emerging-research-areas">Emerging Research Areas</h3>
<ol type="1">
<li><strong>Hybrid Architectures</strong>: Combining KANs with other neural network paradigms</li>
<li><strong>Specialized Applications</strong>: Domain-specific adaptations of Convolutional KANs</li>
<li><strong>Optimization Techniques</strong>: Novel training methods for improved efficiency</li>
<li><strong>Theoretical Analysis</strong>: Deeper understanding of KAN properties and capabilities</li>
</ol>
</section>
<section id="potential-developments" class="level3">
<h3 class="anchored" data-anchor-id="potential-developments">Potential Developments</h3>
<ol type="1">
<li><strong>Hardware Acceleration</strong>: Specialized hardware for efficient KAN computation</li>
<li><strong>AutoML Integration</strong>: Automated design and optimization of KAN architectures</li>
<li><strong>Large-Scale Applications</strong>: Scaling to very large datasets and complex problems</li>
<li><strong>Transfer Learning</strong>: Adapting pre-trained KAN models to new tasks</li>
</ol>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Convolutional Kolmogorov-Arnold Networks represent a paradigm shift in neural network design, offering significant advantages in parameter efficiency, interpretability, and expressive power compared to traditional CNNs. While CNNs have proven their worth over the past decade, Convolutional KANs provide a compelling alternative that addresses many of the limitations of traditional approaches.</p>
<p>The key advantages of Convolutional KANs include their theoretical foundation in the Kolmogorov-Arnold representation theorem, enhanced parameter efficiency, superior interpretability, and adaptive representational capacity. However, challenges remain in terms of computational complexity, training strategies, and large-scale validation.</p>
<p>As research continues to advance, Convolutional KANs are poised to become increasingly important in the deep learning landscape, particularly for applications requiring efficient, interpretable, and high-performance neural networks. The choice between CNNs and Convolutional KANs will ultimately depend on specific application requirements, computational constraints, and the importance of interpretability in the given domain.</p>
<p>The future of computer vision and deep learning may well be shaped by the continued development and adoption of Kolmogorov-Arnold Networks, marking a new chapter in the evolution of artificial intelligence architectures.</p>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/theja-vanka\.github\.io\/blogs\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© 2025 Krishnatheja Vanka</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>