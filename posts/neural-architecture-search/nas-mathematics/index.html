<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Krishnatheja Vanka">
<meta name="dcterms.date" content="2025-07-11">

<title>The Mathematics Behind Neural Architecture Search – Krishnatheja Vanka’s Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-2fef5ea3f8957b3e4ecc936fc74692ca.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-62c28fcd870f55f61984f019219cbd7c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark-5a86c4bd0c1f9981a70f893fdae069f2.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../../site_libs/bootstrap/bootstrap-62c28fcd870f55f61984f019219cbd7c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles/styles.css">
</head>

<body class="floating nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Krishnatheja Vanka’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/theja-vanka"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-right">
      <h1 class="title">The Mathematics Behind Neural Architecture Search</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">research</div>
                <div class="quarto-category">advanced</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-right">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Krishnatheja Vanka </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 11, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-mathematics-behind-neural-architecture-search" id="toc-the-mathematics-behind-neural-architecture-search" class="nav-link active" data-scroll-target="#the-mathematics-behind-neural-architecture-search">The Mathematics Behind Neural Architecture Search</a>
  <ul class="collapse">
  <li><a href="#problem-formulation" id="toc-problem-formulation" class="nav-link" data-scroll-target="#problem-formulation">Problem Formulation</a></li>
  <li><a href="#search-space-representation" id="toc-search-space-representation" class="nav-link" data-scroll-target="#search-space-representation">Search Space Representation</a>
  <ul class="collapse">
  <li><a href="#continuous-relaxation" id="toc-continuous-relaxation" class="nav-link" data-scroll-target="#continuous-relaxation">Continuous Relaxation</a></li>
  <li><a href="#graph-based-representations" id="toc-graph-based-representations" class="nav-link" data-scroll-target="#graph-based-representations">Graph-Based Representations</a></li>
  </ul></li>
  <li><a href="#optimization-strategies" id="toc-optimization-strategies" class="nav-link" data-scroll-target="#optimization-strategies">Optimization Strategies</a>
  <ul class="collapse">
  <li><a href="#gradient-based-methods-darts" id="toc-gradient-based-methods-darts" class="nav-link" data-scroll-target="#gradient-based-methods-darts">Gradient-Based Methods (DARTS)</a></li>
  <li><a href="#evolutionary-approaches" id="toc-evolutionary-approaches" class="nav-link" data-scroll-target="#evolutionary-approaches">Evolutionary Approaches</a></li>
  <li><a href="#reinforcement-learning-formulation" id="toc-reinforcement-learning-formulation" class="nav-link" data-scroll-target="#reinforcement-learning-formulation">Reinforcement Learning Formulation</a></li>
  </ul></li>
  <li><a href="#probability-and-sampling" id="toc-probability-and-sampling" class="nav-link" data-scroll-target="#probability-and-sampling">Probability and Sampling</a>
  <ul class="collapse">
  <li><a href="#architecture-sampling" id="toc-architecture-sampling" class="nav-link" data-scroll-target="#architecture-sampling">Architecture Sampling</a></li>
  <li><a href="#bayesian-optimization" id="toc-bayesian-optimization" class="nav-link" data-scroll-target="#bayesian-optimization">Bayesian Optimization</a></li>
  </ul></li>
  <li><a href="#weight-sharing-and-supernets" id="toc-weight-sharing-and-supernets" class="nav-link" data-scroll-target="#weight-sharing-and-supernets">Weight Sharing and Supernets</a>
  <ul class="collapse">
  <li><a href="#one-shot-architecture-search" id="toc-one-shot-architecture-search" class="nav-link" data-scroll-target="#one-shot-architecture-search">One-Shot Architecture Search</a></li>
  <li><a href="#progressive-shrinking" id="toc-progressive-shrinking" class="nav-link" data-scroll-target="#progressive-shrinking">Progressive Shrinking</a></li>
  </ul></li>
  <li><a href="#performance-prediction" id="toc-performance-prediction" class="nav-link" data-scroll-target="#performance-prediction">Performance Prediction</a>
  <ul class="collapse">
  <li><a href="#learning-curves-and-extrapolation" id="toc-learning-curves-and-extrapolation" class="nav-link" data-scroll-target="#learning-curves-and-extrapolation">Learning Curves and Extrapolation</a></li>
  <li><a href="#neural-predictors" id="toc-neural-predictors" class="nav-link" data-scroll-target="#neural-predictors">Neural Predictors</a></li>
  </ul></li>
  <li><a href="#multi-objective-optimization" id="toc-multi-objective-optimization" class="nav-link" data-scroll-target="#multi-objective-optimization">Multi-Objective Optimization</a>
  <ul class="collapse">
  <li><a href="#pareto-optimality" id="toc-pareto-optimality" class="nav-link" data-scroll-target="#pareto-optimality">Pareto Optimality</a></li>
  <li><a href="#scalarization-methods" id="toc-scalarization-methods" class="nav-link" data-scroll-target="#scalarization-methods">Scalarization Methods</a></li>
  </ul></li>
  <li><a href="#complexity-analysis" id="toc-complexity-analysis" class="nav-link" data-scroll-target="#complexity-analysis">Complexity Analysis</a>
  <ul class="collapse">
  <li><a href="#search-space-size" id="toc-search-space-size" class="nav-link" data-scroll-target="#search-space-size">Search Space Size</a></li>
  <li><a href="#computational-complexity" id="toc-computational-complexity" class="nav-link" data-scroll-target="#computational-complexity">Computational Complexity</a></li>
  </ul></li>
  <li><a href="#convergence-analysis" id="toc-convergence-analysis" class="nav-link" data-scroll-target="#convergence-analysis">Convergence Analysis</a>
  <ul class="collapse">
  <li><a href="#darts-convergence" id="toc-darts-convergence" class="nav-link" data-scroll-target="#darts-convergence">DARTS Convergence</a></li>
  <li><a href="#evolutionary-algorithm-convergence" id="toc-evolutionary-algorithm-convergence" class="nav-link" data-scroll-target="#evolutionary-algorithm-convergence">Evolutionary Algorithm Convergence</a></li>
  </ul></li>
  <li><a href="#practical-considerations" id="toc-practical-considerations" class="nav-link" data-scroll-target="#practical-considerations">Practical Considerations</a>
  <ul class="collapse">
  <li><a href="#regularization" id="toc-regularization" class="nav-link" data-scroll-target="#regularization">Regularization</a></li>
  <li><a href="#search-space-design" id="toc-search-space-design" class="nav-link" data-scroll-target="#search-space-design">Search Space Design</a></li>
  </ul></li>
  <li><a href="#future-directions" id="toc-future-directions" class="nav-link" data-scroll-target="#future-directions">Future Directions</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-right" id="quarto-document-content">






<section id="the-mathematics-behind-neural-architecture-search" class="level1">
<h1>The Mathematics Behind Neural Architecture Search</h1>
<p><img src="nas-math.png" class="img-fluid"></p>
<p>Neural Architecture Search (NAS) represents one of the most sophisticated applications of automated machine learning, where algorithms autonomously design neural network architectures. This field combines optimization theory, probability, and deep learning to solve the fundamental question: what is the optimal neural network architecture for a given task?</p>
<section id="problem-formulation" class="level2">
<h2 class="anchored" data-anchor-id="problem-formulation">Problem Formulation</h2>
<p>The core mathematical challenge in NAS can be formulated as a bilevel optimization problem. Given a dataset <span class="math inline">\(D = \{(x_i, y_i)\}_{i=1}^N\)</span>, we seek to find the optimal architecture <span class="math inline">\(\alpha^*\)</span> that minimizes the validation loss:</p>
<p><span class="math display">\[\alpha^* = \arg \min_\alpha L_{\text{val}}(w^*(\alpha), \alpha)\]</span></p>
<p>where <span class="math inline">\(w^*(\alpha)\)</span> is the optimal set of weights for architecture <span class="math inline">\(\alpha\)</span>, obtained by solving:</p>
<p><span class="math display">\[w^*(\alpha) = \arg \min_w L_{\text{train}}(w, \alpha)\]</span></p>
<p>This bilevel structure creates significant computational challenges, as evaluating each architecture requires full training to obtain <span class="math inline">\(w^*(\alpha)\)</span>.</p>
</section>
<section id="search-space-representation" class="level2">
<h2 class="anchored" data-anchor-id="search-space-representation">Search Space Representation</h2>
<section id="continuous-relaxation" class="level3">
<h3 class="anchored" data-anchor-id="continuous-relaxation">Continuous Relaxation</h3>
<p>One of the key mathematical innovations in NAS is the continuous relaxation of the discrete architecture search space. Instead of searching over discrete architectural choices, we can represent the search space as a continuous optimization problem.</p>
<p>Consider a search space where each edge in the network can be one of <span class="math inline">\(O\)</span> operations from a set <span class="math inline">\(\mathcal{O} = \{o^1, o^2, \ldots, o^{|\mathcal{O}|}\}\)</span>. The continuous relaxation introduces architecture parameters <span class="math inline">\(\alpha = \{\alpha_{i,j}\}_{i,j}\)</span> where <span class="math inline">\(\alpha_{i,j} \in \mathbb{R}^{|\mathcal{O}|}\)</span>.</p>
<p>The mixed operation at edge <span class="math inline">\((i,j)\)</span> becomes:</p>
<p><span class="math display">\[o^{\text{mixed}}_{i,j}(x) = \sum_{k=1}^{|\mathcal{O}|} \frac{\exp(\alpha_{i,j}^{(k)})}{\sum_{l=1}^{|\mathcal{O}|} \exp(\alpha_{i,j}^{(l)})} \cdot o^{(k)}(x)\]</span></p>
<p>This softmax weighting allows gradient-based optimization while maintaining the constraint that weights sum to 1.</p>
</section>
<section id="graph-based-representations" class="level3">
<h3 class="anchored" data-anchor-id="graph-based-representations">Graph-Based Representations</h3>
<p>Neural architectures can be represented as directed acyclic graphs (DAGs) <span class="math inline">\(G = (V, E)\)</span> where:</p>
<ul>
<li><span class="math inline">\(V\)</span> represents computational nodes (layers, operations)</li>
<li><span class="math inline">\(E\)</span> represents data flow connections</li>
</ul>
<p>The adjacency matrix <span class="math inline">\(A \in \{0,1\}^{|V|\times|V|}\)</span> encodes the connectivity, where <span class="math inline">\(A_{i,j} = 1\)</span> indicates a connection from node <span class="math inline">\(i\)</span> to node <span class="math inline">\(j\)</span>.</p>
<p>For a node <span class="math inline">\(j\)</span> with incoming edges from nodes <span class="math inline">\(i_1, i_2, \ldots, i_k\)</span>, the output is:</p>
<p><span class="math display">\[h_j = f_j\left(\sum_{i \in \text{pred}(j)} A_{i,j} \cdot h_i\right)\]</span></p>
<p>where <span class="math inline">\(f_j\)</span> is the operation at node <span class="math inline">\(j\)</span> and <span class="math inline">\(\text{pred}(j)\)</span> denotes the predecessor nodes.</p>
</section>
</section>
<section id="optimization-strategies" class="level2">
<h2 class="anchored" data-anchor-id="optimization-strategies">Optimization Strategies</h2>
<section id="gradient-based-methods-darts" class="level3">
<h3 class="anchored" data-anchor-id="gradient-based-methods-darts">Gradient-Based Methods (DARTS)</h3>
<p>Differentiable Architecture Search (DARTS) transforms the discrete search into a continuous optimization problem. The architecture parameters <span class="math inline">\(\alpha\)</span> and network weights <span class="math inline">\(w\)</span> are optimized alternately:</p>
<p><span class="math display">\[\alpha_{t+1} = \alpha_t - \xi_\alpha \nabla_\alpha L_{\text{val}}(w_t, \alpha_t)\]</span> <span class="math display">\[w_{t+1} = w_t - \xi_w \nabla_w L_{\text{train}}(w_t, \alpha_t)\]</span></p>
<p>The gradient with respect to architecture parameters is:</p>
<p><span class="math display">\[\nabla_\alpha L_{\text{val}} = \sum_{i,j} \nabla_\alpha o^{\text{mixed}}_{i,j} \cdot \nabla_{o^{\text{mixed}}_{i,j}} L_{\text{val}}\]</span></p>
<p>The chain rule application requires careful handling of the softmax operation:</p>
<p><span class="math display">\[\nabla_{\alpha_{i,j}^{(k)}} o^{\text{mixed}}_{i,j} = (\delta_{k,l} - p_{i,j}^{(k)}) p_{i,j}^{(l)} \cdot o^{(l)}\]</span></p>
<p>where <span class="math inline">\(p_{i,j}^{(k)} = \frac{\exp(\alpha_{i,j}^{(k)})}{\sum_l \exp(\alpha_{i,j}^{(l)})}\)</span> and <span class="math inline">\(\delta_{k,l}\)</span> is the Kronecker delta.</p>
</section>
<section id="evolutionary-approaches" class="level3">
<h3 class="anchored" data-anchor-id="evolutionary-approaches">Evolutionary Approaches</h3>
<p>Evolutionary algorithms treat architecture search as a population-based optimization problem. Each architecture is represented as a genome <span class="math inline">\(g\)</span>, and the fitness function is typically the validation accuracy.</p>
<p>The mutation operator <span class="math inline">\(M: \mathcal{G} \to \mathcal{G}\)</span> modifies architectures:</p>
<ul>
<li><strong>Node mutations</strong>: Add/remove computational nodes</li>
<li><strong>Edge mutations</strong>: Add/remove connections<br>
</li>
<li><strong>Operation mutations</strong>: Change operation types</li>
</ul>
<p>The crossover operator <span class="math inline">\(C: \mathcal{G} \times \mathcal{G} \to \mathcal{G}\)</span> combines two parent architectures:</p>
<p><span class="math display">\[g_{\text{child}} = C(g_{\text{parent1}}, g_{\text{parent2}})\]</span></p>
<p>Common crossover strategies include:</p>
<ul>
<li><strong>Uniform crossover</strong>: Each gene inherited from parent1 with probability <span class="math inline">\(p\)</span></li>
<li><strong>Graph crossover</strong>: Combine subgraphs from both parents</li>
</ul>
</section>
<section id="reinforcement-learning-formulation" class="level3">
<h3 class="anchored" data-anchor-id="reinforcement-learning-formulation">Reinforcement Learning Formulation</h3>
<p>NAS can be formulated as a sequential decision problem where an agent (controller) generates architectures. The state space <span class="math inline">\(\mathcal{S}\)</span> represents partial architectures, actions <span class="math inline">\(\mathcal{A}\)</span> represent architectural choices, and rewards <span class="math inline">\(\mathcal{R}\)</span> correspond to validation performance.</p>
<p>The policy <span class="math inline">\(\pi(a|s)\)</span> gives the probability of selecting action <span class="math inline">\(a\)</span> in state <span class="math inline">\(s\)</span>. The objective is to maximize expected reward:</p>
<p><span class="math display">\[J(\theta) = \mathbb{E}_{\pi_\theta}[R(\tau)]\]</span></p>
<p>where <span class="math inline">\(\tau\)</span> is a trajectory (sequence of architectural decisions) and <span class="math inline">\(\theta\)</span> are the controller parameters.</p>
<p>Using the REINFORCE algorithm, the gradient is:</p>
<p><span class="math display">\[\nabla_\theta J(\theta) = \mathbb{E}_{\pi_\theta}[\nabla_\theta \log \pi_\theta(a|s) \cdot (R(\tau) - b)]\]</span></p>
<p>where <span class="math inline">\(b\)</span> is a baseline to reduce variance.</p>
</section>
</section>
<section id="probability-and-sampling" class="level2">
<h2 class="anchored" data-anchor-id="probability-and-sampling">Probability and Sampling</h2>
<section id="architecture-sampling" class="level3">
<h3 class="anchored" data-anchor-id="architecture-sampling">Architecture Sampling</h3>
<p>When using continuous relaxation, the final discrete architecture must be sampled. The Gumbel-Softmax trick provides a differentiable sampling mechanism:</p>
<p><span class="math display">\[\alpha_{\text{sampled}} = \text{softmax}\left(\frac{\log(\alpha) + g}{\tau}\right)\]</span></p>
<p>where <span class="math inline">\(g \sim \text{Gumbel}(0,1)\)</span> and <span class="math inline">\(\tau\)</span> is a temperature parameter controlling the sampling sharpness.</p>
</section>
<section id="bayesian-optimization" class="level3">
<h3 class="anchored" data-anchor-id="bayesian-optimization">Bayesian Optimization</h3>
<p>Some NAS methods model the architecture performance as a Gaussian process. Given observed architectures and performances <span class="math inline">\(\{(\alpha_i, y_i)\}_{i=1}^n\)</span>, we model:</p>
<p><span class="math display">\[f(\alpha) \sim \mathcal{GP}(\mu(\alpha), k(\alpha, \alpha'))\]</span></p>
<p>The acquisition function guides the search:</p>
<p><span class="math display">\[\alpha_{\text{next}} = \arg \max_\alpha a(\alpha|\{(\alpha_i, y_i)\}_{i=1}^n)\]</span></p>
<p>Common acquisition functions include:</p>
<ul>
<li><strong>Expected Improvement</strong>: <span class="math inline">\(\text{EI}(\alpha) = \mathbb{E}[\max(0, f(\alpha) - f(\alpha_{\text{best}}))]\)</span></li>
<li><strong>Upper Confidence Bound</strong>: <span class="math inline">\(\text{UCB}(\alpha) = \mu(\alpha) + \beta \cdot \sigma(\alpha)\)</span></li>
</ul>
</section>
</section>
<section id="weight-sharing-and-supernets" class="level2">
<h2 class="anchored" data-anchor-id="weight-sharing-and-supernets">Weight Sharing and Supernets</h2>
<section id="one-shot-architecture-search" class="level3">
<h3 class="anchored" data-anchor-id="one-shot-architecture-search">One-Shot Architecture Search</h3>
<p>Weight sharing reduces computational cost by training a single “supernet” containing all possible architectures. The supernet weight tensor <span class="math inline">\(W\)</span> has dimensions accommodating all operations.</p>
<p>For a mixed operation with architecture weights <span class="math inline">\(\alpha\)</span>, the effective computation is:</p>
<p><span class="math display">\[\text{output} = \sum_k \alpha_k \cdot \text{op}_k(\text{input}, W_k)\]</span></p>
<p>The challenge is ensuring that shared weights <span class="math inline">\(W_k\)</span> generalize across different architectural contexts.</p>
</section>
<section id="progressive-shrinking" class="level3">
<h3 class="anchored" data-anchor-id="progressive-shrinking">Progressive Shrinking</h3>
<p>Progressive shrinking gradually reduces the search space by removing poorly-performing operations. The pruning criterion at iteration <span class="math inline">\(t\)</span> is:</p>
<p><span class="math display">\[\text{keep}_k = \begin{cases}
1 &amp; \text{if } \alpha_k^{(t)} &gt; \text{threshold}_t \\
0 &amp; \text{otherwise}
\end{cases}\]</span></p>
<p>This creates a sequence of nested search spaces: <span class="math inline">\(\mathcal{S}_0 \supset \mathcal{S}_1 \supset \ldots \supset \mathcal{S}_T\)</span>.</p>
</section>
</section>
<section id="performance-prediction" class="level2">
<h2 class="anchored" data-anchor-id="performance-prediction">Performance Prediction</h2>
<section id="learning-curves-and-extrapolation" class="level3">
<h3 class="anchored" data-anchor-id="learning-curves-and-extrapolation">Learning Curves and Extrapolation</h3>
<p>Early stopping strategies predict final performance from partial training curves. Common models include:</p>
<p><strong>Power Law</strong>: <span class="math inline">\(f(x) = a \cdot x^b + c\)</span> <strong>Exponential</strong>: <span class="math inline">\(f(x) = a \cdot e^{-bx} + c\)</span> <strong>Logarithmic</strong>: <span class="math inline">\(f(x) = a \cdot \log(x) + b\)</span></p>
<p>The parameters are fitted using least squares on early training data, then extrapolated to predict full training performance.</p>
</section>
<section id="neural-predictors" class="level3">
<h3 class="anchored" data-anchor-id="neural-predictors">Neural Predictors</h3>
<p>Neural networks can predict architecture performance from structural features. Given an architecture encoding <span class="math inline">\(\phi(\alpha)\)</span>, a predictor network estimates:</p>
<p><span class="math display">\[\hat{y} = f_\theta(\phi(\alpha))\]</span></p>
<p>where <span class="math inline">\(\phi(\alpha)\)</span> might include:</p>
<ul>
<li>Graph neural network embeddings</li>
<li>Handcrafted features (depth, width, parameter count)</li>
<li>Learned representations</li>
</ul>
</section>
</section>
<section id="multi-objective-optimization" class="level2">
<h2 class="anchored" data-anchor-id="multi-objective-optimization">Multi-Objective Optimization</h2>
<p>Real-world NAS often involves multiple objectives: accuracy, latency, energy consumption, and memory usage. This creates a multi-objective optimization problem:</p>
<p><span class="math display">\[\min F(\alpha) = (f_1(\alpha), f_2(\alpha), \ldots, f_m(\alpha))\]</span></p>
<section id="pareto-optimality" class="level3">
<h3 class="anchored" data-anchor-id="pareto-optimality">Pareto Optimality</h3>
<p>An architecture <span class="math inline">\(\alpha^*\)</span> is Pareto optimal if there exists no <span class="math inline">\(\alpha\)</span> such that:</p>
<ul>
<li><span class="math inline">\(f_i(\alpha) \leq f_i(\alpha^*)\)</span> for all <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(f_j(\alpha) &lt; f_j(\alpha^*)\)</span> for at least one <span class="math inline">\(j\)</span></li>
</ul>
<p>The Pareto front represents the set of all Pareto optimal solutions.</p>
</section>
<section id="scalarization-methods" class="level3">
<h3 class="anchored" data-anchor-id="scalarization-methods">Scalarization Methods</h3>
<p><strong>Weighted Sum</strong>: <span class="math inline">\(\min_\alpha \sum_i w_i \cdot f_i(\alpha)\)</span> <strong>ε-Constraint</strong>: <span class="math inline">\(\min_\alpha f_1(\alpha)\)</span> subject to <span class="math inline">\(f_i(\alpha) \leq \varepsilon_i\)</span> for <span class="math inline">\(i &gt; 1\)</span> <strong>Chebyshev</strong>: <span class="math inline">\(\min_\alpha \max_i w_i \cdot |f_i(\alpha) - z_i^*|\)</span></p>
<p>where <span class="math inline">\(z_i^*\)</span> is the ideal value for objective <span class="math inline">\(i\)</span>.</p>
</section>
</section>
<section id="complexity-analysis" class="level2">
<h2 class="anchored" data-anchor-id="complexity-analysis">Complexity Analysis</h2>
<section id="search-space-size" class="level3">
<h3 class="anchored" data-anchor-id="search-space-size">Search Space Size</h3>
<p>The size of the discrete search space grows exponentially with the number of choices. For a search space with:</p>
<ul>
<li><span class="math inline">\(L\)</span> layers</li>
<li><span class="math inline">\(O\)</span> operations per layer<br>
</li>
<li><span class="math inline">\(C\)</span> connections per layer</li>
</ul>
<p>The total number of architectures is approximately <span class="math inline">\(O^L \cdot 2^{LC}\)</span>, making exhaustive search intractable for realistic problem sizes.</p>
</section>
<section id="computational-complexity" class="level3">
<h3 class="anchored" data-anchor-id="computational-complexity">Computational Complexity</h3>
<p>Different NAS methods have varying computational requirements:</p>
<p><strong>Exhaustive Search</strong>: <span class="math inline">\(\mathcal{O}(|\mathcal{S}| \cdot T)\)</span> where <span class="math inline">\(|\mathcal{S}|\)</span> is search space size and <span class="math inline">\(T\)</span> is training time <strong>Gradient-Based</strong>: <span class="math inline">\(\mathcal{O}(K \cdot T)\)</span> where <span class="math inline">\(K\)</span> is number of gradient steps <strong>Evolutionary</strong>: <span class="math inline">\(\mathcal{O}(P \cdot G \cdot T)\)</span> where <span class="math inline">\(P\)</span> is population size and <span class="math inline">\(G\)</span> is number of generations <strong>One-Shot</strong>: <span class="math inline">\(\mathcal{O}(T_{\text{supernet}} + |\mathcal{S}| \cdot T_{\text{eval}})\)</span> where <span class="math inline">\(T_{\text{eval}} \ll T\)</span></p>
</section>
</section>
<section id="convergence-analysis" class="level2">
<h2 class="anchored" data-anchor-id="convergence-analysis">Convergence Analysis</h2>
<section id="darts-convergence" class="level3">
<h3 class="anchored" data-anchor-id="darts-convergence">DARTS Convergence</h3>
<p>For DARTS, convergence depends on the interplay between architecture and weight optimization. The coupled dynamics can be analyzed using:</p>
<p><span class="math display">\[\alpha_{t+1} = \alpha_t - \xi_\alpha \nabla_\alpha L_{\text{val}}(w^*(\alpha_t), \alpha_t)\]</span> <span class="math display">\[w_{t+1} = w_t - \xi_w \nabla_w L_{\text{train}}(w_t, \alpha_t)\]</span></p>
<p>Under certain conditions (convexity, smoothness), this alternating optimization converges to a stationary point. However, the bilevel nature and non-convexity of neural networks make theoretical guarantees challenging.</p>
</section>
<section id="evolutionary-algorithm-convergence" class="level3">
<h3 class="anchored" data-anchor-id="evolutionary-algorithm-convergence">Evolutionary Algorithm Convergence</h3>
<p>For evolutionary NAS, convergence analysis involves studying the transition probabilities between population states. The probability of finding the optimal architecture depends on:</p>
<ul>
<li>Selection pressure</li>
<li>Mutation rates</li>
<li>Population diversity</li>
</ul>
<p>The expected hitting time to the optimum can be bounded using Markov chain analysis.</p>
</section>
</section>
<section id="practical-considerations" class="level2">
<h2 class="anchored" data-anchor-id="practical-considerations">Practical Considerations</h2>
<section id="regularization" class="level3">
<h3 class="anchored" data-anchor-id="regularization">Regularization</h3>
<p>Architecture search often requires regularization to prevent overfitting:</p>
<p><strong>Dropout on Architecture Parameters</strong>: Randomly zero some <span class="math inline">\(\alpha\)</span> values during training</p>
<p><strong>Weight Decay</strong>: Add L2 penalty <span class="math inline">\(\lambda ||\alpha||^2\)</span> to the loss</p>
<p><strong>Early Stopping</strong>: Stop search when validation performance plateaus</p>
</section>
<section id="search-space-design" class="level3">
<h3 class="anchored" data-anchor-id="search-space-design">Search Space Design</h3>
<p>The choice of search space significantly impacts results. Key considerations include:</p>
<p><strong>Expressivity</strong>: Can the space represent effective architectures? <strong>Efficiency</strong>: Can the space be searched efficiently? <strong>Inductive Bias</strong>: Does the space encode useful architectural priors?</p>
<p>Mathematical analysis of search spaces involves studying their geometric properties, connectivity, and the distribution of high-performing architectures.</p>
</section>
</section>
<section id="future-directions" class="level2">
<h2 class="anchored" data-anchor-id="future-directions">Future Directions</h2>
<p>Neural Architecture Search continues to evolve, with emerging mathematical frameworks addressing:</p>
<ul>
<li><strong>Theoretical foundations</strong>: Convergence guarantees and optimality conditions</li>
<li><strong>Efficient search</strong>: Better approximation algorithms and search strategies<br>
</li>
<li><strong>Transferability</strong>: Mathematical models for cross-domain architecture transfer</li>
<li><strong>Interpretability</strong>: Understanding why certain architectures perform well</li>
</ul>
<p>The mathematical sophistication of NAS continues to grow, drawing from diverse fields including optimization theory, probability, graph theory, and control theory. As the field matures, we expect to see more principled approaches that combine theoretical rigor with practical effectiveness.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The intersection of discrete optimization, continuous relaxation, and deep learning in NAS represents one of the most mathematically rich areas in modern machine learning, with applications extending far beyond neural network design to general automated algorithm design and meta-learning.</p>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/theja-vanka\.github\.io\/blogs\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© 2025 Krishnatheja Vanka</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>