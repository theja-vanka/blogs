[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "Hi üëã, I‚Äôm Krishnatheja Vanka\n\nMachine Learning Engineer (Applied Computer Vision)"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html",
    "href": "posts/pytorch-lightning/index.html",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "PyTorch Lightning is a lightweight wrapper for PyTorch that helps organize code and reduce boilerplate while adding powerful features for research and production. This guide will walk you through the basics to advanced techniques.\n\n\n\nIntroduction to PyTorch Lightning\nInstallation\nBasic Structure: The LightningModule\nDataModules\nTraining with Trainer\nCallbacks\nLogging\nDistributed Training\nHyperparameter Tuning\nModel Checkpointing\nProduction Deployment\nBest Practices\n\n\n\n\nPyTorch Lightning separates research code from engineering code, making models more: - Reproducible: The same code works across different hardware - Readable: Standard project structure makes collaboration easier - Scalable: Train on CPUs, GPUs, TPUs or clusters with no code changes\nLightning helps you focus on the science by handling the engineering details.\n\n\n\npip install pytorch-lightning\nFor the latest features, you can install from the source:\npip install git+https://github.com/Lightning-AI/lightning.git\n\n\n\nThe core component in Lightning is the LightningModule, which organizes your PyTorch code into a standardized structure:\n\nimport pytorch_lightning as pl\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass MNISTModel(pl.LightningModule):\n    def __init__(self, lr=0.001):\n        super().__init__()\n        self.save_hyperparameters()  # Saves learning_rate to hparams\n        self.layer_1 = nn.Linear(28 * 28, 128)\n        self.layer_2 = nn.Linear(128, 10)\n        self.lr = lr\n        \n    def forward(self, x):\n        batch_size, channels, width, height = x.size()\n        x = x.view(batch_size, -1)\n        x = self.layer_1(x)\n        x = F.relu(x)\n        x = self.layer_2(x)\n        return x\n        \n    def training_step(self, batch, batch_idx):\n        x, y = batch\n        logits = self(x)\n        loss = F.cross_entropy(logits, y)\n        self.log('train_loss', loss)\n        return loss\n        \n    def validation_step(self, batch, batch_idx):\n        x, y = batch\n        logits = self(x)\n        loss = F.cross_entropy(logits, y)\n        preds = torch.argmax(logits, dim=1)\n        acc = (preds == y).float().mean()\n        self.log('val_loss', loss)\n        self.log('val_acc', acc)\n        \n    def test_step(self, batch, batch_idx):\n        x, y = batch\n        logits = self(x)\n        loss = F.cross_entropy(logits, y)\n        preds = torch.argmax(logits, dim=1)\n        acc = (preds == y).float().mean()\n        self.log('test_loss', loss)\n        self.log('test_acc', acc)\n        \n    def configure_optimizers(self):\n        optimizer = torch.optim.Adam(self.parameters(), lr=self.lr)\n        return optimizer\n\nThis basic structure includes: - Model architecture (__init__ and forward) - Training logic (training_step) - Validation logic (validation_step) - Test logic (test_step) - Optimization setup (configure_optimizers)\n\n\n\nLightning‚Äôs LightningDataModule encapsulates all data-related logic:\n\nfrom pytorch_lightning import LightningDataModule\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision import transforms\nfrom torchvision.datasets import MNIST\n\nclass MNISTDataModule(LightningDataModule):\n    def __init__(self, data_dir='./data', batch_size=32):\n        super().__init__()\n        self.data_dir = data_dir\n        self.batch_size = batch_size\n        self.transform = transforms.Compose([\n            transforms.ToTensor(),\n            transforms.Normalize((0.1307,), (0.3081,))\n        ])\n        \n    def prepare_data(self):\n        # Download data if needed\n        MNIST(self.data_dir, train=True, download=True)\n        MNIST(self.data_dir, train=False, download=True)\n        \n    def setup(self, stage=None):\n        # Assign train/val/test datasets\n        if stage == 'fit' or stage is None:\n            mnist_full = MNIST(self.data_dir, train=True, transform=self.transform)\n            self.mnist_train, self.mnist_val = random_split(mnist_full, [55000, 5000])\n            \n        if stage == 'test' or stage is None:\n            self.mnist_test = MNIST(self.data_dir, train=False, transform=self.transform)\n            \n    def train_dataloader(self):\n        return DataLoader(self.mnist_train, batch_size=self.batch_size)\n        \n    def val_dataloader(self):\n        return DataLoader(self.mnist_val, batch_size=self.batch_size)\n        \n    def test_dataloader(self):\n        return DataLoader(self.mnist_test, batch_size=self.batch_size)\n\nBenefits of LightningDataModule: - Encapsulates all data preparation logic - Makes data pipeline portable and reproducible - Simplifies sharing data pipelines between projects\n\n\n\nThe Lightning Trainer handles the training loop and validation:\n\nfrom pytorch_lightning import Trainer\n\n# Create model and data module\nmodel = MNISTModel()\ndata_module = MNISTDataModule()\n\n# Initialize trainer\ntrainer = Trainer(\n    max_epochs=10,\n    accelerator=\"auto\",  # Automatically use available GPU\n    devices=\"auto\",\n    logger=True,         # Use TensorBoard logger by default\n)\n\n# Train model\ntrainer.fit(model, datamodule=data_module)\n\n# Test model\ntrainer.test(model, datamodule=data_module)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n  0%|          | 0.00/9.91M [00:00&lt;?, ?B/s]  0%|          | 32.8k/9.91M [00:00&lt;01:05, 151kB/s]  1%|          | 98.3k/9.91M [00:00&lt;00:40, 241kB/s]  2%|‚ñè         | 197k/9.91M [00:00&lt;00:28, 340kB/s]   4%|‚ñç         | 426k/9.91M [00:00&lt;00:15, 623kB/s]  9%|‚ñä         | 852k/9.91M [00:00&lt;00:06, 1.36MB/s] 11%|‚ñà         | 1.05M/9.91M [00:01&lt;00:06, 1.41MB/s] 18%|‚ñà‚ñä        | 1.77M/9.91M [00:01&lt;00:03, 2.26MB/s] 35%|‚ñà‚ñà‚ñà‚ñç      | 3.44M/9.91M [00:01&lt;00:01, 5.32MB/s] 42%|‚ñà‚ñà‚ñà‚ñà‚ñè     | 4.13M/9.91M [00:01&lt;00:01, 5.32MB/s] 63%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñé   | 6.23M/9.91M [00:01&lt;00:00, 7.38MB/s] 95%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå| 9.44M/9.91M [00:01&lt;00:00, 9.84MB/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 9.91M/9.91M [00:01&lt;00:00, 5.03MB/s]\n  0%|          | 0.00/28.9k [00:00&lt;?, ?B/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 28.9k/28.9k [00:00&lt;00:00, 128kB/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 28.9k/28.9k [00:00&lt;00:00, 127kB/s]\n  0%|          | 0.00/1.65M [00:00&lt;?, ?B/s]  2%|‚ñè         | 32.8k/1.65M [00:00&lt;00:11, 142kB/s]  4%|‚ñç         | 65.5k/1.65M [00:00&lt;00:10, 147kB/s]  6%|‚ñå         | 98.3k/1.65M [00:00&lt;00:10, 150kB/s] 10%|‚ñâ         | 164k/1.65M [00:00&lt;00:07, 210kB/s]  12%|‚ñà‚ñè        | 197k/1.65M [00:01&lt;00:07, 190kB/s] 14%|‚ñà‚ñç        | 229k/1.65M [00:01&lt;00:07, 178kB/s] 18%|‚ñà‚ñä        | 295k/1.65M [00:01&lt;00:06, 218kB/s] 20%|‚ñà‚ñâ        | 328k/1.65M [00:01&lt;00:06, 198kB/s] 24%|‚ñà‚ñà‚ñç       | 393k/1.65M [00:01&lt;00:05, 230kB/s] 28%|‚ñà‚ñà‚ñä       | 459k/1.65M [00:02&lt;00:04, 250kB/s] 30%|‚ñà‚ñà‚ñâ       | 492k/1.65M [00:02&lt;00:05, 224kB/s] 34%|‚ñà‚ñà‚ñà‚ñç      | 557k/1.65M [00:02&lt;00:04, 249kB/s] 38%|‚ñà‚ñà‚ñà‚ñä      | 623k/1.65M [00:02&lt;00:03, 263kB/s] 42%|‚ñà‚ñà‚ñà‚ñà‚ñè     | 688k/1.65M [00:03&lt;00:03, 280kB/s] 46%|‚ñà‚ñà‚ñà‚ñà‚ñå     | 754k/1.65M [00:03&lt;00:03, 288kB/s] 50%|‚ñà‚ñà‚ñà‚ñà‚ñâ     | 819k/1.65M [00:03&lt;00:02, 294kB/s] 56%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå    | 918k/1.65M [00:03&lt;00:02, 339kB/s] 60%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñâ    | 983k/1.65M [00:03&lt;00:01, 334kB/s] 66%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå   | 1.08M/1.65M [00:04&lt;00:01, 367kB/s] 70%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñâ   | 1.15M/1.65M [00:04&lt;00:01, 354kB/s] 76%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå  | 1.25M/1.65M [00:04&lt;00:01, 393kB/s] 81%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñè | 1.34M/1.65M [00:04&lt;00:00, 407kB/s] 87%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñã | 1.44M/1.65M [00:04&lt;00:00, 423kB/s] 95%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå| 1.57M/1.65M [00:05&lt;00:00, 478kB/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 1.65M/1.65M [00:05&lt;00:00, 319kB/s]\n  0%|          | 0.00/4.54k [00:00&lt;?, ?B/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 4.54k/4.54k [00:00&lt;00:00, 4.99MB/s]\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/connectors/data_connector.py:425: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=11` in the `DataLoader` to improve performance.\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/connectors/data_connector.py:425: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=11` in the `DataLoader` to improve performance.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached.\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/connectors/data_connector.py:425: The 'test_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=11` in the `DataLoader` to improve performance.\n\n\n\n\n\n‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n‚îÉ        Test metric        ‚îÉ       DataLoader 0        ‚îÉ\n‚î°‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î©\n‚îÇ         test_acc          ‚îÇ    0.9729999899864197     ‚îÇ\n‚îÇ         test_loss         ‚îÇ     0.126272052526474     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n\n\n[{'test_loss': 0.126272052526474, 'test_acc': 0.9729999899864197}]\n\n\nThe Trainer automatically handles: - Epoch and batch iteration - Optimizer steps - Logging metrics - Hardware acceleration (CPU, GPU, TPU) - Early stopping - Checkpointing - Multi-GPU training\n\n\n\ntrainer = Trainer(\n    max_epochs=10,                    # Maximum number of epochs\n    min_epochs=1,                     # Minimum number of epochs\n    accelerator=\"cpu\",                # Use CPU acceleration\n    devices=1,                        # Use 1 CPUs\n    precision=\"16-mixed\",             # Use mixed precision for faster training\n    gradient_clip_val=0.5,            # Clip gradients\n    accumulate_grad_batches=4,        # Accumulate gradients over 4 batches\n    log_every_n_steps=50,             # Log metrics every 50 steps\n    val_check_interval=0.25,          # Run validation 4 times per epoch\n    fast_dev_run=False,               # Debug mode (only run a few batches)\n    deterministic=True,               # Make training deterministic\n)\n\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/connectors/accelerator_connector.py:513: You passed `Trainer(accelerator='cpu', precision='16-mixed')` but AMP with fp16 is not supported on CPU. Using `precision='bf16-mixed'` instead.\nUsing bfloat16 Automatic Mixed Precision (AMP)\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: False\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/setup.py:177: GPU available but not used. You can set it by doing `Trainer(accelerator='gpu')`.\n\n\n\n\n\n\nCallbacks add functionality to the training loop without modifying the core code:\n\nfrom pytorch_lightning.callbacks import ModelCheckpoint, EarlyStopping, LearningRateMonitor\n\n# Save the best model based on validation accuracy\ncheckpoint_callback = ModelCheckpoint(\n    monitor='val_acc',\n    dirpath='./checkpoints',\n    filename='mnist-{epoch:02d}-{val_acc:.2f}',\n    save_top_k=3,\n    mode='max',\n)\n\n# Stop training when validation loss stops improving\nearly_stop_callback = EarlyStopping(\n    monitor='val_loss',\n    patience=3,\n    verbose=True,\n    mode='min'\n)\n\n# Monitor learning rate\nlr_monitor = LearningRateMonitor(logging_interval='step')\n\n# Initialize trainer with callbacks\ntrainer = Trainer(\n    max_epochs=10,\n    callbacks=[checkpoint_callback, early_stop_callback, lr_monitor]\n)\n\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n\n\n\nYou can create custom callbacks by extending the base Callback class:\n\nfrom pytorch_lightning.callbacks import Callback\n\nclass PrintingCallback(Callback):\n    def on_train_start(self, trainer, pl_module):\n        print(\"Training has started!\")\n        \n    def on_train_end(self, trainer, pl_module):\n        print(\"Training has finished!\")\n        \n    def on_train_batch_end(self, trainer, pl_module, outputs, batch, batch_idx):\n        if batch_idx % 100 == 0:\n            print(f\"Batch {batch_idx} completed\")\n\n\n\n\n\nLightning supports various loggers:\n\nfrom pytorch_lightning.loggers import TensorBoardLogger, WandbLogger\n\n# TensorBoard logger\ntensorboard_logger = TensorBoardLogger(save_dir=\"logs/\", name=\"mnist\")\n\n# Initialize trainer with loggers\ntrainer = Trainer(\n    max_epochs=10,\n    logger=[tensorboard_logger]\n)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n\nAdding metrics in your model:\n\ndef training_step(self, batch, batch_idx):\n    x, y = batch\n    logits = self(x)\n    loss = F.cross_entropy(logits, y)\n    \n    # Log scalar values\n    self.log('train_loss', loss)\n    \n    # Log learning rate\n    lr = self.optimizers().param_groups[0]['lr']\n    self.log('learning_rate', lr)\n    \n    # Log histograms (on GPU)\n    if batch_idx % 100 == 0:\n        self.logger.experiment.add_histogram('logits', logits, self.global_step)\n    \n    return loss\n\n\n\n\nLightning makes distributed training simple:\n# Single GPU\ntrainer = Trainer(accelerator=\"gpu\", devices=1)\n\n# Multiple GPUs (DDP strategy automatically selected)\ntrainer = Trainer(accelerator=\"gpu\", devices=4)\n\n# Specific GPU indices\ntrainer = Trainer(accelerator=\"gpu\", devices=[0, 1, 3])\n\n# TPU cores\ntrainer = Trainer(accelerator=\"tpu\", devices=8)\n\n# Advanced distributed training\ntrainer = Trainer(\n    accelerator=\"gpu\",\n    devices=4,\n    strategy=\"ddp\",  # Distributed Data Parallel\n    num_nodes=2      # Use 2 machines\n)\nOther distribution strategies: - ddp_spawn: Similar to DDP but uses spawn for multiprocessing - deepspeed: For very large models using DeepSpeed - fsdp: Fully Sharded Data Parallel for huge models\n\n\n\nLightning integrates well with optimization libraries:\n\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.tuner import Tuner\n\n# Create model\nmodel = MNISTModel()\ndata_module = MNISTDataModule()\n\n# Create trainer\ntrainer = Trainer(max_epochs=10)\n\n# Use Lightning's Tuner for auto-scaling batch size\ntuner = Tuner(trainer)\ntuner.scale_batch_size(model, datamodule=data_module)\n\n# Find optimal learning rate\nlr_finder = tuner.lr_find(model, datamodule=data_module)\nmodel.learning_rate = lr_finder.suggestion()\n\n# Train with optimized parameters\ntrainer.fit(model, datamodule=data_module)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 2 succeeded, trying batch size 4\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 4 succeeded, trying batch size 8\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 8 succeeded, trying batch size 16\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 16 succeeded, trying batch size 32\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 32 succeeded, trying batch size 64\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 64 succeeded, trying batch size 128\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 128 succeeded, trying batch size 256\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 256 succeeded, trying batch size 512\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 512 succeeded, trying batch size 1024\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 1024 succeeded, trying batch size 2048\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (27) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 2048 succeeded, trying batch size 4096\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (14) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 4096 succeeded, trying batch size 8192\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (7) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 8192 succeeded, trying batch size 16384\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (4) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 16384 succeeded, trying batch size 32768\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (2) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 32768 succeeded, trying batch size 65536\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (1) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nThe batch size 65536 is greater or equal than the length of your dataset.\nFinished batch size finder, will continue with full run using batch size 65536\nRestoring states from the checkpoint path at /Users/vanka/Documents/blogs/posts/pytorch-lightning/.scale_batch_size_63a6ff2c-04ba-401f-afab-6ebdab16cd84.ckpt\nRestored all states from the checkpoint at /Users/vanka/Documents/blogs/posts/pytorch-lightning/.scale_batch_size_63a6ff2c-04ba-401f-afab-6ebdab16cd84.ckpt\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached.\nLR finder stopped early after 10 steps due to diverging loss.\nFailed to compute suggestion for learning rate because there are not enough points. Increase the loop iteration limits or the size of your dataset/dataloader.\nRestoring states from the checkpoint path at /Users/vanka/Documents/blogs/posts/pytorch-lightning/.lr_find_b47666fb-244a-4779-a73d-47f949695be3.ckpt\nRestored all states from the checkpoint at /Users/vanka/Documents/blogs/posts/pytorch-lightning/.lr_find_b47666fb-244a-4779-a73d-47f949695be3.ckpt\nFailed to compute suggestion for learning rate because there are not enough points. Increase the loop iteration limits or the size of your dataset/dataloader.\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached.\n\n\n\n\n\nSaving and loading model checkpoints:\n\n# Save checkpoints during training\ncheckpoint_callback = ModelCheckpoint(\n    dirpath='./checkpoints',\n    filename='{epoch}-{val_loss:.2f}',\n    monitor='val_loss',\n    save_top_k=3,\n    mode='min'\n)\n\ntrainer = Trainer(\n    max_epochs=10,\n    callbacks=[checkpoint_callback]\n)\n\ntrainer.fit(model, datamodule=data_module)\n\n# Path to best checkpoint\nbest_model_path = checkpoint_callback.best_model_path\n\n# Load checkpoint into model\nmodel = MNISTModel.load_from_checkpoint(best_model_path)\n\n# Continue training from checkpoint\ntrainer.fit(model, datamodule=data_module)\n\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached.\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/callbacks/model_checkpoint.py:654: Checkpoint directory /Users/vanka/Documents/blogs/posts/pytorch-lightning/checkpoints exists and is not empty.\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached.\n\n\nCheckpointing for production:\n\n# Save model in production-ready format\ntrainer.save_checkpoint(\"model.ckpt\")\n\n# Extract state dict for production\ncheckpoint = torch.load(\"model.ckpt\")\nmodel_state_dict = checkpoint[\"state_dict\"]\n\n# Save just the PyTorch model for production\nmodel = MNISTModel()\nmodel.load_state_dict(model_state_dict)\ntorch.save(model.state_dict(), \"production_model.pt\")\n\n\n\n\nConverting Lightning models to production:\n\n# Option 1: Use the Lightning model directly\nmodel = MNISTModel.load_from_checkpoint(\"model.ckpt\")\nmodel.eval()\nmodel.freeze()  # Freeze the model parameters\n\n# Make predictions\nwith torch.no_grad():\n    x = torch.randn(1, 1, 28, 28)\n    y_hat = model(x)\n\n# Option 2: Extract the PyTorch model\nclass ProductionModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.layer_1 = nn.Linear(28 * 28, 128)\n        self.layer_2 = nn.Linear(128, 10)\n    \n    def forward(self, x):\n        x = x.view(x.size(0), -1)\n        x = F.relu(self.layer_1(x))\n        x = self.layer_2(x)\n        return x\n\n# Load weights from Lightning model\nlightning_model = MNISTModel.load_from_checkpoint(\"model.ckpt\")\nproduction_model = ProductionModel()\n\n# Copy weights\nproduction_model.layer_1.weight.data = lightning_model.layer_1.weight.data\nproduction_model.layer_1.bias.data = lightning_model.layer_1.bias.data\nproduction_model.layer_2.weight.data = lightning_model.layer_2.weight.data\nproduction_model.layer_2.bias.data = lightning_model.layer_2.bias.data\n\n# Save production model\ntorch.save(production_model.state_dict(), \"production_model.pt\")\n\n# Export to ONNX\ndummy_input = torch.randn(1, 1, 28, 28)\ntorch.onnx.export(\n    production_model,\n    dummy_input,\n    \"model.onnx\",\n    export_params=True,\n    opset_version=11,\n    input_names=['input'],\n    output_names=['output']\n)\n\n\n\n\n\n\nA well-organized Lightning project structure:\nproject/\n‚îú‚îÄ‚îÄ configs/              # Configuration files\n‚îú‚îÄ‚îÄ data/                 # Data files\n‚îú‚îÄ‚îÄ lightning_logs/       # Generated logs\n‚îú‚îÄ‚îÄ models/               # Model definitions\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ mnist_model.py    # LightningModule\n‚îú‚îÄ‚îÄ data_modules/         # Data modules\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ mnist_data.py     # LightningDataModule\n‚îú‚îÄ‚îÄ callbacks/            # Custom callbacks\n‚îú‚îÄ‚îÄ utils/                # Utility functions\n‚îú‚îÄ‚îÄ main.py               # Training script\n‚îî‚îÄ‚îÄ README.md\n\n\n\nLightning provides a CLI for running experiments from config files:\n# main.py\nfrom pytorch_lightning.cli import LightningCLI\n\ndef cli_main():\n    # Create CLI with LightningModule and LightningDataModule\n    cli = LightningCLI(\n        MNISTModel,\n        MNISTDataModule,\n        save_config_callback=None,\n    )\n\nif __name__ == \"__main__\":\n    cli_main()\nRun with:\npython main.py fit --config configs/mnist.yaml\nExample config file (mnist.yaml):\nmodel:\n  learning_rate: 0.001\n  hidden_size: 128\ndata:\n  data_dir: ./data\n  batch_size: 64\ntrainer:\n  max_epochs: 10\n  accelerator: gpu\n  devices: 1\n\n\n\nLightning includes tools to profile your code:\n\nfrom pytorch_lightning.profilers import PyTorchProfiler, SimpleProfiler\n\n# PyTorch Profiler\nprofiler = PyTorchProfiler(\n    on_trace_ready=torch.profiler.tensorboard_trace_handler(\"logs/profiler\"),\n    schedule=torch.profiler.schedule(wait=1, warmup=1, active=3, repeat=2)\n)\n\n# Simple Profiler\n# profiler = SimpleProfiler()\nmodel = MNISTModel()\ndata_module = MNISTDataModule()\ntrainer = Trainer(\n    max_epochs=5,\n    profiler=profiler\n)\n\ntrainer.fit(model, datamodule=data_module)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n\n\n\n[W521 02:21:17.688092000 collection.cpp:659] Warning: Optimizer.step#Adam.step (function operator())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=5` reached.\nFIT Profiler Report\nProfile stats for: records\n-------------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  \n                                                   Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  \n-------------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  \n                                          ProfilerStep*         3.66%     338.123us       100.00%       9.241ms       4.621ms             2  \n                [pl][profile][_EvaluationLoop].val_next         0.26%      24.167us        37.65%       3.480ms       1.740ms             2  \nenumerate(DataLoader)#_SingleProcessDataLoaderIter._...        24.81%       2.293ms        37.39%       3.456ms       1.728ms             2  \n                                               aten::to         0.52%      48.007us        30.30%       2.800ms       5.908us           474  \n                                         aten::_to_copy         0.89%      82.412us        29.78%       2.752ms      13.900us           198  \n                                            aten::copy_        28.12%       2.599ms        28.17%       2.603ms       7.889us           330  \n[pl][profile][Strategy]SingleDeviceStrategy.batch_to...         0.62%      56.916us        27.82%       2.571ms       1.285ms             2  \n[pl][profile][LightningModule]MNISTModel.transfer_ba...         0.38%      35.291us        27.07%       2.502ms       1.251ms             2  \n[pl][profile][Strategy]SingleDeviceStrategy.validati...         7.67%     708.713us        25.85%       2.389ms       1.194ms             2  \n                                            aten::fill_         6.41%     591.916us         6.41%     591.916us       1.377us           430  \n                                             aten::mean         3.58%     331.166us         4.01%     370.166us     185.083us             2  \n[pl][profile][Callback]TQDMProgressBar.on_validation...         3.54%     327.082us         3.54%     327.082us     163.541us             2  \n                               aten::cross_entropy_loss         0.04%       3.417us         3.26%     300.958us     150.479us             2  \n                                               aten::eq         1.46%     135.297us         3.07%     284.001us       4.303us            66  \n                                           aten::linear         1.46%     135.209us         2.85%     263.083us      65.771us             4  \n                                              aten::add         1.45%     133.958us         2.59%     239.124us      29.891us             8  \n    [pl][module]torch.nn.modules.linear.Linear: layer_1         0.26%      24.458us         2.05%     189.708us      94.854us             2  \n                                            aten::empty         0.67%      61.667us         2.05%     189.457us       1.414us           134  \n                                      aten::nll_loss_nd         0.02%       1.707us         1.95%     180.541us      90.271us             2  \n                                         aten::nll_loss         0.02%       1.876us         1.94%     178.834us      89.417us             2  \n-------------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  \nSelf CPU time total: 9.241ms\n\n\n\n\n\n\n\n\n\ntrainer = Trainer(\n    accumulate_grad_batches=4  # Accumulate over 4 batches\n)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n\n\n\n\n\ndef configure_optimizers(self):\n    optimizer = torch.optim.Adam(self.parameters(), lr=1e-3)\n    scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(\n        optimizer, \n        mode='min', \n        factor=0.1, \n        patience=5\n    )\n    return {\n        \"optimizer\": optimizer,\n        \"lr_scheduler\": {\n            \"scheduler\": scheduler,\n            \"monitor\": \"val_loss\",\n            \"interval\": \"epoch\",\n            \"frequency\": 1\n        }\n    }\n\n\n\n\n\ntrainer = Trainer(\n    precision=\"16-mixed\"  # Use 16-bit mixed precision\n)\n\nUsing 16bit Automatic Mixed Precision (AMP)\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/torch/amp/grad_scaler.py:136: UserWarning:\n\ntorch.cuda.amp.GradScaler is enabled, but CUDA is not available.  Disabling.\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n\n\n\n\n\nclass TransferLearningModel(pl.LightningModule):\n    def __init__(self):\n        super().__init__()\n        # Load pretrained model\n        self.feature_extractor = torchvision.models.resnet18(pretrained=True)\n        \n        # Freeze feature extractor\n        for param in self.feature_extractor.parameters():\n            param.requires_grad = False\n            \n        # Replace final layer\n        num_features = self.feature_extractor.fc.in_features\n        self.feature_extractor.fc = nn.Linear(num_features, 10)\n        \n    def unfreeze_features(self):\n        # Unfreeze model after some training\n        for param in self.feature_extractor.parameters():\n            param.requires_grad = True\n\n\n\n\n\n\nPyTorch Lightning provides an organized framework that separates research code from engineering boilerplate, making deep learning projects easier to develop, share, and scale. It‚Äôs especially valuable for research projects that need to be reproducible and scalable across different hardware configurations.\nFor further information: - PyTorch Lightning Documentation - Lightning GitHub Repository - Lightning Tutorials"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#table-of-contents",
    "href": "posts/pytorch-lightning/index.html#table-of-contents",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "Introduction to PyTorch Lightning\nInstallation\nBasic Structure: The LightningModule\nDataModules\nTraining with Trainer\nCallbacks\nLogging\nDistributed Training\nHyperparameter Tuning\nModel Checkpointing\nProduction Deployment\nBest Practices"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#introduction-to-pytorch-lightning",
    "href": "posts/pytorch-lightning/index.html#introduction-to-pytorch-lightning",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "PyTorch Lightning separates research code from engineering code, making models more: - Reproducible: The same code works across different hardware - Readable: Standard project structure makes collaboration easier - Scalable: Train on CPUs, GPUs, TPUs or clusters with no code changes\nLightning helps you focus on the science by handling the engineering details."
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#installation",
    "href": "posts/pytorch-lightning/index.html#installation",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "pip install pytorch-lightning\nFor the latest features, you can install from the source:\npip install git+https://github.com/Lightning-AI/lightning.git"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#basic-structure-the-lightningmodule",
    "href": "posts/pytorch-lightning/index.html#basic-structure-the-lightningmodule",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "The core component in Lightning is the LightningModule, which organizes your PyTorch code into a standardized structure:\n\nimport pytorch_lightning as pl\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass MNISTModel(pl.LightningModule):\n    def __init__(self, lr=0.001):\n        super().__init__()\n        self.save_hyperparameters()  # Saves learning_rate to hparams\n        self.layer_1 = nn.Linear(28 * 28, 128)\n        self.layer_2 = nn.Linear(128, 10)\n        self.lr = lr\n        \n    def forward(self, x):\n        batch_size, channels, width, height = x.size()\n        x = x.view(batch_size, -1)\n        x = self.layer_1(x)\n        x = F.relu(x)\n        x = self.layer_2(x)\n        return x\n        \n    def training_step(self, batch, batch_idx):\n        x, y = batch\n        logits = self(x)\n        loss = F.cross_entropy(logits, y)\n        self.log('train_loss', loss)\n        return loss\n        \n    def validation_step(self, batch, batch_idx):\n        x, y = batch\n        logits = self(x)\n        loss = F.cross_entropy(logits, y)\n        preds = torch.argmax(logits, dim=1)\n        acc = (preds == y).float().mean()\n        self.log('val_loss', loss)\n        self.log('val_acc', acc)\n        \n    def test_step(self, batch, batch_idx):\n        x, y = batch\n        logits = self(x)\n        loss = F.cross_entropy(logits, y)\n        preds = torch.argmax(logits, dim=1)\n        acc = (preds == y).float().mean()\n        self.log('test_loss', loss)\n        self.log('test_acc', acc)\n        \n    def configure_optimizers(self):\n        optimizer = torch.optim.Adam(self.parameters(), lr=self.lr)\n        return optimizer\n\nThis basic structure includes: - Model architecture (__init__ and forward) - Training logic (training_step) - Validation logic (validation_step) - Test logic (test_step) - Optimization setup (configure_optimizers)"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#datamodules",
    "href": "posts/pytorch-lightning/index.html#datamodules",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "Lightning‚Äôs LightningDataModule encapsulates all data-related logic:\n\nfrom pytorch_lightning import LightningDataModule\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision import transforms\nfrom torchvision.datasets import MNIST\n\nclass MNISTDataModule(LightningDataModule):\n    def __init__(self, data_dir='./data', batch_size=32):\n        super().__init__()\n        self.data_dir = data_dir\n        self.batch_size = batch_size\n        self.transform = transforms.Compose([\n            transforms.ToTensor(),\n            transforms.Normalize((0.1307,), (0.3081,))\n        ])\n        \n    def prepare_data(self):\n        # Download data if needed\n        MNIST(self.data_dir, train=True, download=True)\n        MNIST(self.data_dir, train=False, download=True)\n        \n    def setup(self, stage=None):\n        # Assign train/val/test datasets\n        if stage == 'fit' or stage is None:\n            mnist_full = MNIST(self.data_dir, train=True, transform=self.transform)\n            self.mnist_train, self.mnist_val = random_split(mnist_full, [55000, 5000])\n            \n        if stage == 'test' or stage is None:\n            self.mnist_test = MNIST(self.data_dir, train=False, transform=self.transform)\n            \n    def train_dataloader(self):\n        return DataLoader(self.mnist_train, batch_size=self.batch_size)\n        \n    def val_dataloader(self):\n        return DataLoader(self.mnist_val, batch_size=self.batch_size)\n        \n    def test_dataloader(self):\n        return DataLoader(self.mnist_test, batch_size=self.batch_size)\n\nBenefits of LightningDataModule: - Encapsulates all data preparation logic - Makes data pipeline portable and reproducible - Simplifies sharing data pipelines between projects"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#training-with-trainer",
    "href": "posts/pytorch-lightning/index.html#training-with-trainer",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "The Lightning Trainer handles the training loop and validation:\n\nfrom pytorch_lightning import Trainer\n\n# Create model and data module\nmodel = MNISTModel()\ndata_module = MNISTDataModule()\n\n# Initialize trainer\ntrainer = Trainer(\n    max_epochs=10,\n    accelerator=\"auto\",  # Automatically use available GPU\n    devices=\"auto\",\n    logger=True,         # Use TensorBoard logger by default\n)\n\n# Train model\ntrainer.fit(model, datamodule=data_module)\n\n# Test model\ntrainer.test(model, datamodule=data_module)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n  0%|          | 0.00/9.91M [00:00&lt;?, ?B/s]  0%|          | 32.8k/9.91M [00:00&lt;01:05, 151kB/s]  1%|          | 98.3k/9.91M [00:00&lt;00:40, 241kB/s]  2%|‚ñè         | 197k/9.91M [00:00&lt;00:28, 340kB/s]   4%|‚ñç         | 426k/9.91M [00:00&lt;00:15, 623kB/s]  9%|‚ñä         | 852k/9.91M [00:00&lt;00:06, 1.36MB/s] 11%|‚ñà         | 1.05M/9.91M [00:01&lt;00:06, 1.41MB/s] 18%|‚ñà‚ñä        | 1.77M/9.91M [00:01&lt;00:03, 2.26MB/s] 35%|‚ñà‚ñà‚ñà‚ñç      | 3.44M/9.91M [00:01&lt;00:01, 5.32MB/s] 42%|‚ñà‚ñà‚ñà‚ñà‚ñè     | 4.13M/9.91M [00:01&lt;00:01, 5.32MB/s] 63%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñé   | 6.23M/9.91M [00:01&lt;00:00, 7.38MB/s] 95%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå| 9.44M/9.91M [00:01&lt;00:00, 9.84MB/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 9.91M/9.91M [00:01&lt;00:00, 5.03MB/s]\n  0%|          | 0.00/28.9k [00:00&lt;?, ?B/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 28.9k/28.9k [00:00&lt;00:00, 128kB/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 28.9k/28.9k [00:00&lt;00:00, 127kB/s]\n  0%|          | 0.00/1.65M [00:00&lt;?, ?B/s]  2%|‚ñè         | 32.8k/1.65M [00:00&lt;00:11, 142kB/s]  4%|‚ñç         | 65.5k/1.65M [00:00&lt;00:10, 147kB/s]  6%|‚ñå         | 98.3k/1.65M [00:00&lt;00:10, 150kB/s] 10%|‚ñâ         | 164k/1.65M [00:00&lt;00:07, 210kB/s]  12%|‚ñà‚ñè        | 197k/1.65M [00:01&lt;00:07, 190kB/s] 14%|‚ñà‚ñç        | 229k/1.65M [00:01&lt;00:07, 178kB/s] 18%|‚ñà‚ñä        | 295k/1.65M [00:01&lt;00:06, 218kB/s] 20%|‚ñà‚ñâ        | 328k/1.65M [00:01&lt;00:06, 198kB/s] 24%|‚ñà‚ñà‚ñç       | 393k/1.65M [00:01&lt;00:05, 230kB/s] 28%|‚ñà‚ñà‚ñä       | 459k/1.65M [00:02&lt;00:04, 250kB/s] 30%|‚ñà‚ñà‚ñâ       | 492k/1.65M [00:02&lt;00:05, 224kB/s] 34%|‚ñà‚ñà‚ñà‚ñç      | 557k/1.65M [00:02&lt;00:04, 249kB/s] 38%|‚ñà‚ñà‚ñà‚ñä      | 623k/1.65M [00:02&lt;00:03, 263kB/s] 42%|‚ñà‚ñà‚ñà‚ñà‚ñè     | 688k/1.65M [00:03&lt;00:03, 280kB/s] 46%|‚ñà‚ñà‚ñà‚ñà‚ñå     | 754k/1.65M [00:03&lt;00:03, 288kB/s] 50%|‚ñà‚ñà‚ñà‚ñà‚ñâ     | 819k/1.65M [00:03&lt;00:02, 294kB/s] 56%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå    | 918k/1.65M [00:03&lt;00:02, 339kB/s] 60%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñâ    | 983k/1.65M [00:03&lt;00:01, 334kB/s] 66%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå   | 1.08M/1.65M [00:04&lt;00:01, 367kB/s] 70%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñâ   | 1.15M/1.65M [00:04&lt;00:01, 354kB/s] 76%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå  | 1.25M/1.65M [00:04&lt;00:01, 393kB/s] 81%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñè | 1.34M/1.65M [00:04&lt;00:00, 407kB/s] 87%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñã | 1.44M/1.65M [00:04&lt;00:00, 423kB/s] 95%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå| 1.57M/1.65M [00:05&lt;00:00, 478kB/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 1.65M/1.65M [00:05&lt;00:00, 319kB/s]\n  0%|          | 0.00/4.54k [00:00&lt;?, ?B/s]100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 4.54k/4.54k [00:00&lt;00:00, 4.99MB/s]\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/connectors/data_connector.py:425: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=11` in the `DataLoader` to improve performance.\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/connectors/data_connector.py:425: The 'train_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=11` in the `DataLoader` to improve performance.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached.\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/connectors/data_connector.py:425: The 'test_dataloader' does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` to `num_workers=11` in the `DataLoader` to improve performance.\n\n\n\n\n\n‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n‚îÉ        Test metric        ‚îÉ       DataLoader 0        ‚îÉ\n‚î°‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î©\n‚îÇ         test_acc          ‚îÇ    0.9729999899864197     ‚îÇ\n‚îÇ         test_loss         ‚îÇ     0.126272052526474     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n\n\n[{'test_loss': 0.126272052526474, 'test_acc': 0.9729999899864197}]\n\n\nThe Trainer automatically handles: - Epoch and batch iteration - Optimizer steps - Logging metrics - Hardware acceleration (CPU, GPU, TPU) - Early stopping - Checkpointing - Multi-GPU training\n\n\n\ntrainer = Trainer(\n    max_epochs=10,                    # Maximum number of epochs\n    min_epochs=1,                     # Minimum number of epochs\n    accelerator=\"cpu\",                # Use CPU acceleration\n    devices=1,                        # Use 1 CPUs\n    precision=\"16-mixed\",             # Use mixed precision for faster training\n    gradient_clip_val=0.5,            # Clip gradients\n    accumulate_grad_batches=4,        # Accumulate gradients over 4 batches\n    log_every_n_steps=50,             # Log metrics every 50 steps\n    val_check_interval=0.25,          # Run validation 4 times per epoch\n    fast_dev_run=False,               # Debug mode (only run a few batches)\n    deterministic=True,               # Make training deterministic\n)\n\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/connectors/accelerator_connector.py:513: You passed `Trainer(accelerator='cpu', precision='16-mixed')` but AMP with fp16 is not supported on CPU. Using `precision='bf16-mixed'` instead.\nUsing bfloat16 Automatic Mixed Precision (AMP)\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: False\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/trainer/setup.py:177: GPU available but not used. You can set it by doing `Trainer(accelerator='gpu')`."
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#callbacks",
    "href": "posts/pytorch-lightning/index.html#callbacks",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "Callbacks add functionality to the training loop without modifying the core code:\n\nfrom pytorch_lightning.callbacks import ModelCheckpoint, EarlyStopping, LearningRateMonitor\n\n# Save the best model based on validation accuracy\ncheckpoint_callback = ModelCheckpoint(\n    monitor='val_acc',\n    dirpath='./checkpoints',\n    filename='mnist-{epoch:02d}-{val_acc:.2f}',\n    save_top_k=3,\n    mode='max',\n)\n\n# Stop training when validation loss stops improving\nearly_stop_callback = EarlyStopping(\n    monitor='val_loss',\n    patience=3,\n    verbose=True,\n    mode='min'\n)\n\n# Monitor learning rate\nlr_monitor = LearningRateMonitor(logging_interval='step')\n\n# Initialize trainer with callbacks\ntrainer = Trainer(\n    max_epochs=10,\n    callbacks=[checkpoint_callback, early_stop_callback, lr_monitor]\n)\n\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n\n\n\nYou can create custom callbacks by extending the base Callback class:\n\nfrom pytorch_lightning.callbacks import Callback\n\nclass PrintingCallback(Callback):\n    def on_train_start(self, trainer, pl_module):\n        print(\"Training has started!\")\n        \n    def on_train_end(self, trainer, pl_module):\n        print(\"Training has finished!\")\n        \n    def on_train_batch_end(self, trainer, pl_module, outputs, batch, batch_idx):\n        if batch_idx % 100 == 0:\n            print(f\"Batch {batch_idx} completed\")"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#logging",
    "href": "posts/pytorch-lightning/index.html#logging",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "Lightning supports various loggers:\n\nfrom pytorch_lightning.loggers import TensorBoardLogger, WandbLogger\n\n# TensorBoard logger\ntensorboard_logger = TensorBoardLogger(save_dir=\"logs/\", name=\"mnist\")\n\n# Initialize trainer with loggers\ntrainer = Trainer(\n    max_epochs=10,\n    logger=[tensorboard_logger]\n)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n\nAdding metrics in your model:\n\ndef training_step(self, batch, batch_idx):\n    x, y = batch\n    logits = self(x)\n    loss = F.cross_entropy(logits, y)\n    \n    # Log scalar values\n    self.log('train_loss', loss)\n    \n    # Log learning rate\n    lr = self.optimizers().param_groups[0]['lr']\n    self.log('learning_rate', lr)\n    \n    # Log histograms (on GPU)\n    if batch_idx % 100 == 0:\n        self.logger.experiment.add_histogram('logits', logits, self.global_step)\n    \n    return loss"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#distributed-training",
    "href": "posts/pytorch-lightning/index.html#distributed-training",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "Lightning makes distributed training simple:\n# Single GPU\ntrainer = Trainer(accelerator=\"gpu\", devices=1)\n\n# Multiple GPUs (DDP strategy automatically selected)\ntrainer = Trainer(accelerator=\"gpu\", devices=4)\n\n# Specific GPU indices\ntrainer = Trainer(accelerator=\"gpu\", devices=[0, 1, 3])\n\n# TPU cores\ntrainer = Trainer(accelerator=\"tpu\", devices=8)\n\n# Advanced distributed training\ntrainer = Trainer(\n    accelerator=\"gpu\",\n    devices=4,\n    strategy=\"ddp\",  # Distributed Data Parallel\n    num_nodes=2      # Use 2 machines\n)\nOther distribution strategies: - ddp_spawn: Similar to DDP but uses spawn for multiprocessing - deepspeed: For very large models using DeepSpeed - fsdp: Fully Sharded Data Parallel for huge models"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#hyperparameter-tuning",
    "href": "posts/pytorch-lightning/index.html#hyperparameter-tuning",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "Lightning integrates well with optimization libraries:\n\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.tuner import Tuner\n\n# Create model\nmodel = MNISTModel()\ndata_module = MNISTDataModule()\n\n# Create trainer\ntrainer = Trainer(max_epochs=10)\n\n# Use Lightning's Tuner for auto-scaling batch size\ntuner = Tuner(trainer)\ntuner.scale_batch_size(model, datamodule=data_module)\n\n# Find optimal learning rate\nlr_finder = tuner.lr_find(model, datamodule=data_module)\nmodel.learning_rate = lr_finder.suggestion()\n\n# Train with optimized parameters\ntrainer.fit(model, datamodule=data_module)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 2 succeeded, trying batch size 4\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 4 succeeded, trying batch size 8\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 8 succeeded, trying batch size 16\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 16 succeeded, trying batch size 32\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 32 succeeded, trying batch size 64\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 64 succeeded, trying batch size 128\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 128 succeeded, trying batch size 256\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 256 succeeded, trying batch size 512\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 512 succeeded, trying batch size 1024\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 1024 succeeded, trying batch size 2048\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (27) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 2048 succeeded, trying batch size 4096\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (14) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 4096 succeeded, trying batch size 8192\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (7) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 8192 succeeded, trying batch size 16384\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (4) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 16384 succeeded, trying batch size 32768\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (2) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nBatch size 32768 succeeded, trying batch size 65536\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/loops/fit_loop.py:310: The number of training batches (1) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n`Trainer.fit` stopped: `max_steps=3` reached.\nThe batch size 65536 is greater or equal than the length of your dataset.\nFinished batch size finder, will continue with full run using batch size 65536\nRestoring states from the checkpoint path at /Users/vanka/Documents/blogs/posts/pytorch-lightning/.scale_batch_size_63a6ff2c-04ba-401f-afab-6ebdab16cd84.ckpt\nRestored all states from the checkpoint at /Users/vanka/Documents/blogs/posts/pytorch-lightning/.scale_batch_size_63a6ff2c-04ba-401f-afab-6ebdab16cd84.ckpt\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached.\nLR finder stopped early after 10 steps due to diverging loss.\nFailed to compute suggestion for learning rate because there are not enough points. Increase the loop iteration limits or the size of your dataset/dataloader.\nRestoring states from the checkpoint path at /Users/vanka/Documents/blogs/posts/pytorch-lightning/.lr_find_b47666fb-244a-4779-a73d-47f949695be3.ckpt\nRestored all states from the checkpoint at /Users/vanka/Documents/blogs/posts/pytorch-lightning/.lr_find_b47666fb-244a-4779-a73d-47f949695be3.ckpt\nFailed to compute suggestion for learning rate because there are not enough points. Increase the loop iteration limits or the size of your dataset/dataloader.\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached."
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#model-checkpointing",
    "href": "posts/pytorch-lightning/index.html#model-checkpointing",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "Saving and loading model checkpoints:\n\n# Save checkpoints during training\ncheckpoint_callback = ModelCheckpoint(\n    dirpath='./checkpoints',\n    filename='{epoch}-{val_loss:.2f}',\n    monitor='val_loss',\n    save_top_k=3,\n    mode='min'\n)\n\ntrainer = Trainer(\n    max_epochs=10,\n    callbacks=[checkpoint_callback]\n)\n\ntrainer.fit(model, datamodule=data_module)\n\n# Path to best checkpoint\nbest_model_path = checkpoint_callback.best_model_path\n\n# Load checkpoint into model\nmodel = MNISTModel.load_from_checkpoint(best_model_path)\n\n# Continue training from checkpoint\ntrainer.fit(model, datamodule=data_module)\n\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached.\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/pytorch_lightning/callbacks/model_checkpoint.py:654: Checkpoint directory /Users/vanka/Documents/blogs/posts/pytorch-lightning/checkpoints exists and is not empty.\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=10` reached.\n\n\nCheckpointing for production:\n\n# Save model in production-ready format\ntrainer.save_checkpoint(\"model.ckpt\")\n\n# Extract state dict for production\ncheckpoint = torch.load(\"model.ckpt\")\nmodel_state_dict = checkpoint[\"state_dict\"]\n\n# Save just the PyTorch model for production\nmodel = MNISTModel()\nmodel.load_state_dict(model_state_dict)\ntorch.save(model.state_dict(), \"production_model.pt\")"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#production-deployment",
    "href": "posts/pytorch-lightning/index.html#production-deployment",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "Converting Lightning models to production:\n\n# Option 1: Use the Lightning model directly\nmodel = MNISTModel.load_from_checkpoint(\"model.ckpt\")\nmodel.eval()\nmodel.freeze()  # Freeze the model parameters\n\n# Make predictions\nwith torch.no_grad():\n    x = torch.randn(1, 1, 28, 28)\n    y_hat = model(x)\n\n# Option 2: Extract the PyTorch model\nclass ProductionModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.layer_1 = nn.Linear(28 * 28, 128)\n        self.layer_2 = nn.Linear(128, 10)\n    \n    def forward(self, x):\n        x = x.view(x.size(0), -1)\n        x = F.relu(self.layer_1(x))\n        x = self.layer_2(x)\n        return x\n\n# Load weights from Lightning model\nlightning_model = MNISTModel.load_from_checkpoint(\"model.ckpt\")\nproduction_model = ProductionModel()\n\n# Copy weights\nproduction_model.layer_1.weight.data = lightning_model.layer_1.weight.data\nproduction_model.layer_1.bias.data = lightning_model.layer_1.bias.data\nproduction_model.layer_2.weight.data = lightning_model.layer_2.weight.data\nproduction_model.layer_2.bias.data = lightning_model.layer_2.bias.data\n\n# Save production model\ntorch.save(production_model.state_dict(), \"production_model.pt\")\n\n# Export to ONNX\ndummy_input = torch.randn(1, 1, 28, 28)\ntorch.onnx.export(\n    production_model,\n    dummy_input,\n    \"model.onnx\",\n    export_params=True,\n    opset_version=11,\n    input_names=['input'],\n    output_names=['output']\n)"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#best-practices",
    "href": "posts/pytorch-lightning/index.html#best-practices",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "A well-organized Lightning project structure:\nproject/\n‚îú‚îÄ‚îÄ configs/              # Configuration files\n‚îú‚îÄ‚îÄ data/                 # Data files\n‚îú‚îÄ‚îÄ lightning_logs/       # Generated logs\n‚îú‚îÄ‚îÄ models/               # Model definitions\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ mnist_model.py    # LightningModule\n‚îú‚îÄ‚îÄ data_modules/         # Data modules\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ mnist_data.py     # LightningDataModule\n‚îú‚îÄ‚îÄ callbacks/            # Custom callbacks\n‚îú‚îÄ‚îÄ utils/                # Utility functions\n‚îú‚îÄ‚îÄ main.py               # Training script\n‚îî‚îÄ‚îÄ README.md\n\n\n\nLightning provides a CLI for running experiments from config files:\n# main.py\nfrom pytorch_lightning.cli import LightningCLI\n\ndef cli_main():\n    # Create CLI with LightningModule and LightningDataModule\n    cli = LightningCLI(\n        MNISTModel,\n        MNISTDataModule,\n        save_config_callback=None,\n    )\n\nif __name__ == \"__main__\":\n    cli_main()\nRun with:\npython main.py fit --config configs/mnist.yaml\nExample config file (mnist.yaml):\nmodel:\n  learning_rate: 0.001\n  hidden_size: 128\ndata:\n  data_dir: ./data\n  batch_size: 64\ntrainer:\n  max_epochs: 10\n  accelerator: gpu\n  devices: 1\n\n\n\nLightning includes tools to profile your code:\n\nfrom pytorch_lightning.profilers import PyTorchProfiler, SimpleProfiler\n\n# PyTorch Profiler\nprofiler = PyTorchProfiler(\n    on_trace_ready=torch.profiler.tensorboard_trace_handler(\"logs/profiler\"),\n    schedule=torch.profiler.schedule(wait=1, warmup=1, active=3, repeat=2)\n)\n\n# Simple Profiler\n# profiler = SimpleProfiler()\nmodel = MNISTModel()\ndata_module = MNISTDataModule()\ntrainer = Trainer(\n    max_epochs=5,\n    profiler=profiler\n)\n\ntrainer.fit(model, datamodule=data_module)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n  | Name    | Type   | Params | Mode \n-------------------------------------------\n0 | layer_1 | Linear | 100 K  | train\n1 | layer_2 | Linear | 1.3 K  | train\n-------------------------------------------\n101 K     Trainable params\n0         Non-trainable params\n101 K     Total params\n0.407     Total estimated model params size (MB)\n2         Modules in train mode\n0         Modules in eval mode\n\n\n\n\n\n\n\n\n[W521 02:21:17.688092000 collection.cpp:659] Warning: Optimizer.step#Adam.step (function operator())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`Trainer.fit` stopped: `max_epochs=5` reached.\nFIT Profiler Report\nProfile stats for: records\n-------------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  \n                                                   Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  \n-------------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  \n                                          ProfilerStep*         3.66%     338.123us       100.00%       9.241ms       4.621ms             2  \n                [pl][profile][_EvaluationLoop].val_next         0.26%      24.167us        37.65%       3.480ms       1.740ms             2  \nenumerate(DataLoader)#_SingleProcessDataLoaderIter._...        24.81%       2.293ms        37.39%       3.456ms       1.728ms             2  \n                                               aten::to         0.52%      48.007us        30.30%       2.800ms       5.908us           474  \n                                         aten::_to_copy         0.89%      82.412us        29.78%       2.752ms      13.900us           198  \n                                            aten::copy_        28.12%       2.599ms        28.17%       2.603ms       7.889us           330  \n[pl][profile][Strategy]SingleDeviceStrategy.batch_to...         0.62%      56.916us        27.82%       2.571ms       1.285ms             2  \n[pl][profile][LightningModule]MNISTModel.transfer_ba...         0.38%      35.291us        27.07%       2.502ms       1.251ms             2  \n[pl][profile][Strategy]SingleDeviceStrategy.validati...         7.67%     708.713us        25.85%       2.389ms       1.194ms             2  \n                                            aten::fill_         6.41%     591.916us         6.41%     591.916us       1.377us           430  \n                                             aten::mean         3.58%     331.166us         4.01%     370.166us     185.083us             2  \n[pl][profile][Callback]TQDMProgressBar.on_validation...         3.54%     327.082us         3.54%     327.082us     163.541us             2  \n                               aten::cross_entropy_loss         0.04%       3.417us         3.26%     300.958us     150.479us             2  \n                                               aten::eq         1.46%     135.297us         3.07%     284.001us       4.303us            66  \n                                           aten::linear         1.46%     135.209us         2.85%     263.083us      65.771us             4  \n                                              aten::add         1.45%     133.958us         2.59%     239.124us      29.891us             8  \n    [pl][module]torch.nn.modules.linear.Linear: layer_1         0.26%      24.458us         2.05%     189.708us      94.854us             2  \n                                            aten::empty         0.67%      61.667us         2.05%     189.457us       1.414us           134  \n                                      aten::nll_loss_nd         0.02%       1.707us         1.95%     180.541us      90.271us             2  \n                                         aten::nll_loss         0.02%       1.876us         1.94%     178.834us      89.417us             2  \n-------------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  \nSelf CPU time total: 9.241ms\n\n\n\n\n\n\n\n\n\ntrainer = Trainer(\n    accumulate_grad_batches=4  # Accumulate over 4 batches\n)\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n\n\n\n\n\ndef configure_optimizers(self):\n    optimizer = torch.optim.Adam(self.parameters(), lr=1e-3)\n    scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(\n        optimizer, \n        mode='min', \n        factor=0.1, \n        patience=5\n    )\n    return {\n        \"optimizer\": optimizer,\n        \"lr_scheduler\": {\n            \"scheduler\": scheduler,\n            \"monitor\": \"val_loss\",\n            \"interval\": \"epoch\",\n            \"frequency\": 1\n        }\n    }\n\n\n\n\n\ntrainer = Trainer(\n    precision=\"16-mixed\"  # Use 16-bit mixed precision\n)\n\nUsing 16bit Automatic Mixed Precision (AMP)\n/opt/homebrew/Caskroom/miniconda/base/envs/blog/lib/python3.12/site-packages/torch/amp/grad_scaler.py:136: UserWarning:\n\ntorch.cuda.amp.GradScaler is enabled, but CUDA is not available.  Disabling.\n\nUsing default `ModelCheckpoint`. Consider installing `litmodels` package to enable `LitModelCheckpoint` for automatic upload to the Lightning model registry.\nGPU available: True (mps), used: True\nTPU available: False, using: 0 TPU cores\nHPU available: False, using: 0 HPUs\n\n\n\n\n\n\nclass TransferLearningModel(pl.LightningModule):\n    def __init__(self):\n        super().__init__()\n        # Load pretrained model\n        self.feature_extractor = torchvision.models.resnet18(pretrained=True)\n        \n        # Freeze feature extractor\n        for param in self.feature_extractor.parameters():\n            param.requires_grad = False\n            \n        # Replace final layer\n        num_features = self.feature_extractor.fc.in_features\n        self.feature_extractor.fc = nn.Linear(num_features, 10)\n        \n    def unfreeze_features(self):\n        # Unfreeze model after some training\n        for param in self.feature_extractor.parameters():\n            param.requires_grad = True"
  },
  {
    "objectID": "posts/pytorch-lightning/index.html#conclusion",
    "href": "posts/pytorch-lightning/index.html#conclusion",
    "title": "PyTorch Lightning: A Comprehensive Guide",
    "section": "",
    "text": "PyTorch Lightning provides an organized framework that separates research code from engineering boilerplate, making deep learning projects easier to develop, share, and scale. It‚Äôs especially valuable for research projects that need to be reproducible and scalable across different hardware configurations.\nFor further information: - PyTorch Lightning Documentation - Lightning GitHub Repository - Lightning Tutorials"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "üëÅÔ∏è Welcome to My Computer Vision Blog!\n\nThis is the first post in this blog.\nHello and welcome!\nI‚Äôm thrilled to kick off this blog dedicated to exploring the fascinating world of computer vision ‚Äî a field where machines learn to see, interpret, and understand the visual world around us. Whether you‚Äôre a seasoned AI researcher, an aspiring developer, or simply curious about how technology can ‚Äúsee,‚Äù you‚Äôll find something valuable here.\nFrom image processing techniques to deep learning breakthroughs, from real-world applications to hands-on tutorials ‚Äî this blog will cover it all. My goal is to make computer vision approachable, insightful, and exciting for everyone.\nSo, whether you‚Äôre here to learn, build, or stay on top of the latest innovations, I‚Äôm glad to have you along for the journey. Let‚Äôs dive into the visual future together!\nStay tuned, and let‚Äôs make machines see the world like never before. üöÄ\nCheers,  Krishna"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html",
    "href": "posts/pandas-to-polars/index.html",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "As datasets grow in size and complexity, performance and efficiency become critical in data processing. While Pandas has long been the go-to library for data manipulation in Python, it can struggle with speed and memory usage, especially on large datasets. Polars, a newer DataFrame library written in Rust, offers a faster, more memory-efficient alternative with support for lazy evaluation and multi-threading.\nThis guide explores how to convert Pandas DataFrames to Polars, and highlights key differences in syntax, performance, and functionality. Whether you‚Äôre looking to speed up your data workflows or just exploring modern tools, understanding the transition from Pandas to Polars is a valuable step.\n\n\n\nInstallation and Setup\nCreating DataFrames\nBasic Operations\nFiltering Data\nGrouping and Aggregation\nJoining/Merging DataFrames\nHandling Missing Values\nString Operations\nTime Series Operations\nPerformance Comparison\nAPI Philosophy Differences\nMigration Guide\n\n\n\n\n\n\n\n# Import pandas\nimport pandas as pd\n\n\n\n\n\n# Import polars\nimport polars as pl\n\n\n\n\n\n\n\n\n\n\nimport pandas as pd\n\n# Create DataFrame from dictionary\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'age': [25, 30, 35, 40],\n    'city': ['New York', 'Los Angeles', 'Chicago', 'Houston']\n}\ndf_pd = pd.DataFrame(data)\nprint(df_pd)\n\n      name  age         city\n0    Alice   25     New York\n1      Bob   30  Los Angeles\n2  Charlie   35      Chicago\n3    David   40      Houston\n\n\n\n\n\n\nimport polars as pl\n\n# Create DataFrame from dictionary\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'age': [25, 30, 35, 40],\n    'city': ['New York', 'Los Angeles', 'Chicago', 'Houston']\n}\ndf_pl = pl.DataFrame(data)\nprint(df_pl)\n\nshape: (4, 3)\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ name    ‚îÜ age ‚îÜ city        ‚îÇ\n‚îÇ ---     ‚îÜ --- ‚îÜ ---         ‚îÇ\n‚îÇ str     ‚îÜ i64 ‚îÜ str         ‚îÇ\n‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï°\n‚îÇ Alice   ‚îÜ 25  ‚îÜ New York    ‚îÇ\n‚îÇ Bob     ‚îÜ 30  ‚îÜ Los Angeles ‚îÇ\n‚îÇ Charlie ‚îÜ 35  ‚îÜ Chicago     ‚îÇ\n‚îÇ David   ‚îÜ 40  ‚îÜ Houston     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n\n\n\n\n\n\n\n\n\n\n\n# Select a single column (returns Series)\nseries = df_pd['name']\n\n# Select multiple columns\ndf_subset = df_pd[['name', 'age']]\n\n\n\n\n\n# Select a single column (returns Series)\nseries = df_pl['name']\n# Alternative method\nseries = df_pl.select(pl.col('name')).to_series()\n\n# Select multiple columns\ndf_subset = df_pl.select(['name', 'age'])\n# Alternative method\ndf_subset = df_pl.select(pl.col(['name', 'age']))\n\n\n\n\n\n\n\n\n# Add a new column\ndf_pd['is_adult'] = df_pd['age'] &gt;= 18\n\n# Using assign (creates a new DataFrame)\ndf_pd = df_pd.assign(age_squared=df_pd['age'] ** 2)\n\n\n\n\n\n# Add a new column\ndf_pl = df_pl.with_columns(\n    pl.when(pl.col('age') &gt;= 18).then(True).otherwise(False).alias('is_adult')\n)\n\n# Creating derived columns \ndf_pl = df_pl.with_columns(\n    (pl.col('age') ** 2).alias('age_squared')\n)\n\n# Multiple columns at once\ndf_pl = df_pl.with_columns([\n    pl.col('age').is_null().alias('age_is_null'),\n    (pl.col('age') * 2).alias('age_doubled')\n])\n\n\n\n\n\n\n\n\n# Get summary statistics\nsummary = df_pd.describe()\n\n# Individual statistics\nmean_age = df_pd['age'].mean()\nmedian_age = df_pd['age'].median()\nmin_age = df_pd['age'].min()\nmax_age = df_pd['age'].max()\n\n\n\n\n\n# Get summary statistics\nsummary = df_pl.describe()\n\n# Individual statistics\nmean_age = df_pl.select(pl.col('age').mean()).item()\nmedian_age = df_pl.select(pl.col('age').median()).item()\nmin_age = df_pl.select(pl.col('age').min()).item()\nmax_age = df_pl.select(pl.col('age').max()).item()\n\n\n\n\n\n\n\n\n\n\n\n# Filter rows\nadults = df_pd[df_pd['age'] &gt;= 18]\n\n# Multiple conditions\nfiltered = df_pd[(df_pd['age'] &gt; 30) & (df_pd['city'] == 'Chicago')]\n\n\n\n\n\n# Filter rows\nadults = df_pl.filter(pl.col('age') &gt;= 18)\n\n# Multiple conditions\nfiltered = df_pl.filter((pl.col('age') &gt; 30) & (pl.col('city') == 'Chicago'))\n\n\n\n\n\n\n\n\n# Filter with OR conditions\ndf_filtered = df_pd[(df_pd['city'] == 'New York') | (df_pd['city'] == 'Chicago')]\n\n# Using isin\ncities = ['New York', 'Chicago']\ndf_filtered = df_pd[df_pd['city'].isin(cities)]\n\n# String contains\ndf_filtered = df_pd[df_pd['name'].str.contains('li')]\n\n\n\n\n\n# Filter with OR conditions\ndf_filtered = df_pl.filter((pl.col('city') == 'New York') | (pl.col('city') == 'Chicago'))\n\n# Using is_in\ncities = ['New York', 'Chicago']\ndf_filtered = df_pl.filter(pl.col('city').is_in(cities))\n\n# String contains\ndf_filtered = df_pl.filter(pl.col('name').str.contains('li'))\n\n\n\n\n\n\n\n\n\n\n\n# Group by one column and aggregate\ncity_stats = df_pd.groupby('city').agg({\n    'age': ['mean', 'min', 'max', 'count']\n})\n\n# Reset index for flat DataFrame\ncity_stats = city_stats.reset_index()\n\n\n\n\n\n# Group by one column and aggregate\ncity_stats = df_pl.group_by('city').agg([\n    pl.col('age').mean().alias('age_mean'),\n    pl.col('age').min().alias('age_min'),\n    pl.col('age').max().alias('age_max'),\n    pl.col('age').count().alias('age_count')\n])\n\n\n\n\n\n\n\n\n\n\n\n# Create another DataFrame\nemployee_data = {\n    'emp_id': [1, 2, 3, 4],\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'dept': ['HR', 'IT', 'Finance', 'IT']\n}\nemployee_df_pd = pd.DataFrame(employee_data)\n\nsalary_data = {\n    'emp_id': [1, 2, 3, 5],\n    'salary': [50000, 60000, 70000, 80000]\n}\nsalary_df_pd = pd.DataFrame(salary_data)\n\n# Inner join\nmerged_df = employee_df_pd.merge(\n    salary_df_pd,\n    on='emp_id',\n    how='inner'\n)\n\n\n\n\n\n# Create another DataFrame\nemployee_data = {\n    'emp_id': [1, 2, 3, 4],\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'dept': ['HR', 'IT', 'Finance', 'IT']\n}\nemployee_df_pl = pl.DataFrame(employee_data)\n\nsalary_data = {\n    'emp_id': [1, 2, 3, 5],\n    'salary': [50000, 60000, 70000, 80000]\n}\nsalary_df_pl = pl.DataFrame(salary_data)\n\n# Inner join\nmerged_df = employee_df_pl.join(\n    salary_df_pl,\n    on='emp_id',\n    how='inner'\n)\n\n\n\n\n\n\n\n\n# Left join\nleft_join = employee_df_pd.merge(salary_df_pd, on='emp_id', how='left')\n\n# Right join\nright_join = employee_df_pd.merge(salary_df_pd, on='emp_id', how='right')\n\n# Outer join\nouter_join = employee_df_pd.merge(salary_df_pd, on='emp_id', how='outer')\n\n\n\n\n\n# Left join\nleft_join = employee_df_pl.join(salary_df_pl, on='emp_id', how='left')\n\n# Right join\nright_join = employee_df_pl.join(salary_df_pl, on='emp_id', how='right')\n\n# Outer join\nouter_join = employee_df_pl.join(salary_df_pl, on='emp_id', how='full')\n\n\n\n\n\n\n\n\n\n\n\n# Check for missing values\nmissing_count = df_pd.isnull().sum()\n\n# Check if any column has missing values\nhas_missing = df_pd.isnull().any().any()\n\n\n\n\n\n# Check for missing values\nmissing_count = df_pl.null_count()\n\n# Check if specific column has missing values\nhas_missing = df_pl.select(pl.col('age').is_null().any()).item()\n\n\n\n\n\n\n\n\n# Drop rows with any missing values\ndf_pd_clean = df_pd.dropna()\n\n# Fill missing values\ndf_pd_filled = df_pd.fillna({\n    'age': 0,\n    'city': 'Unknown'\n})\n\n# Forward fill\ndf_pd_ffill = df_pd.ffill()\n\n\n\n\n\n# Drop rows with any missing values\ndf_pl_clean = df_pl.drop_nulls()\n\n# Fill missing values\ndf_pl_filled = df_pl.with_columns([\n    pl.col('age').fill_null(0),\n    pl.col('city').fill_null('Unknown')\n])\n\n# Forward fill\ndf_pl_ffill = df_pl.with_columns([\n    pl.col('age').fill_null(strategy='forward'),\n    pl.col('city').fill_null(strategy='forward')\n])\n\n\n\n\n\n\n\n\n\n\n\n# Convert to uppercase\ndf_pd['name_upper'] = df_pd['name'].str.upper()\n\n# Get string length\ndf_pd['name_length'] = df_pd['name'].str.len()\n\n# Extract substring\ndf_pd['name_first_char'] = df_pd['name'].str[0]\n\n# Replace substrings\ndf_pd['city_replaced'] = df_pd['city'].str.replace('New', 'Old')\n\n\n\n\n\n# Convert to uppercase\ndf_pl = df_pl.with_columns(pl.col('name').str.to_uppercase().alias('name_upper'))\n\n# Get string length\ndf_pl = df_pl.with_columns(pl.col('name').str.len_chars().alias('name_length'))\n\n# Extract substring \ndf_pl = df_pl.with_columns(pl.col('name').str.slice(0, 1).alias('name_first_char'))\n\n# Replace substrings\ndf_pl = df_pl.with_columns(pl.col('city').str.replace('New', 'Old').alias('city_replaced'))\n\n\n\n\n\n\n\n\n# Split string\ndf_pd['first_word'] = df_pd['city'].str.split(' ').str[0]\n\n# Pattern matching\nhas_new = df_pd['city'].str.contains('New')\n\n# Extract with regex\ndf_pd['extracted'] = df_pd['city'].str.extract(r'(\\w+)\\s')\n\n\n\n\n\n# Split string\ndf_pl = df_pl.with_columns(\n    pl.col('city').str.split(' ').list.get(0).alias('first_word')\n)\n\n# Pattern matching\ndf_pl = df_pl.with_columns(\n    pl.col('city').str.contains('New').alias('has_new')\n)\n\n# Extract with regex\ndf_pl = df_pl.with_columns(\n    pl.col('city').str.extract(r'(\\w+)\\s').alias('extracted')\n)\n\n\n\n\n\n\n\n\n\n\n\n# Create DataFrame with dates\ndates_pd = pd.DataFrame({\n    'date_str': ['2023-01-01', '2023-02-15', '2023-03-30']\n})\n\n# Parse dates\ndates_pd['date'] = pd.to_datetime(dates_pd['date_str'])\n\n# Extract components\ndates_pd['year'] = dates_pd['date'].dt.year\ndates_pd['month'] = dates_pd['date'].dt.month\ndates_pd['day'] = dates_pd['date'].dt.day\ndates_pd['weekday'] = dates_pd['date'].dt.day_name()\n\n\n\n\n\n# Create DataFrame with dates\ndates_pl = pl.DataFrame({\n    'date_str': ['2023-01-01', '2023-02-15', '2023-03-30']\n})\n\n# Parse dates\ndates_pl = dates_pl.with_columns(\n    pl.col('date_str').str.strptime(pl.Datetime, '%Y-%m-%d').alias('date')\n)\n\n# Extract components\ndates_pl = dates_pl.with_columns([\n    pl.col('date').dt.year().alias('year'),\n    pl.col('date').dt.month().alias('month'),\n    pl.col('date').dt.day().alias('day'),\n    pl.col('date').dt.weekday().replace_strict({\n        0: 'Monday', 1: 'Tuesday', 2: 'Wednesday', \n        3: 'Thursday', 4: 'Friday', 5: 'Saturday', 6: 'Sunday'\n    }, default=\"unknown\").alias('weekday')\n])\n\n\n\n\n\n\n\n\n# Add days\ndates_pd['next_week'] = dates_pd['date'] + pd.Timedelta(days=7)\n\n# Date difference\ndate_range = pd.date_range(start='2023-01-01', end='2023-01-10')\ndf_dates = pd.DataFrame({'date': date_range})\ndf_dates['days_since_start'] = (df_dates['date'] - df_dates['date'].min()).dt.days\n\n\n\n\n\n# Add days\ndates_pl = dates_pl.with_columns(\n    (pl.col('date') + pl.duration(days=7)).alias('next_week')\n)\n\n# Date difference\ndate_range = pd.date_range(start='2023-01-01', end='2023-01-10')  # Using pandas to generate range\ndf_dates = pl.DataFrame({'date': date_range})\ndf_dates = df_dates.with_columns(\n    (pl.col('date') - pl.col('date').min()).dt.total_days().alias('days_since_start')\n)\n\n\n\n\n\n\nThis section demonstrates performance differences between pandas and polars for a large dataset operation.\n\nimport pandas as pd\nimport polars as pl\nimport time\nimport numpy as np\n\n# Generate a large dataset (10 million rows)\nn = 10_000_000\ndata = {\n    'id': np.arange(n),\n    'value': np.random.randn(n),\n    'group': np.random.choice(['A', 'B', 'C', 'D'], n)\n}\n\n# Convert to pandas DataFrame\ndf_pd = pd.DataFrame(data)\n\n# Convert to polars DataFrame\ndf_pl = pl.DataFrame(data)\n\n# Benchmark: Group by and calculate mean, min, max\nprint(\"Running pandas groupby...\")\nstart = time.time()\nresult_pd = df_pd.groupby('group').agg({\n    'value': ['mean', 'min', 'max', 'count']\n})\npd_time = time.time() - start\nprint(f\"Pandas time: {pd_time:.4f} seconds\")\n\nprint(\"Running polars groupby...\")\nstart = time.time()\nresult_pl = df_pl.group_by('group').agg([\n    pl.col('value').mean().alias('value_mean'),\n    pl.col('value').min().alias('value_min'),\n    pl.col('value').max().alias('value_max'),\n    pl.col('value').count().alias('value_count')\n])\npl_time = time.time() - start\nprint(f\"Polars time: {pl_time:.4f} seconds\")\n\nprint(f\"Polars is {pd_time / pl_time:.2f}x faster\")\n\nRunning pandas groupby...\nPandas time: 0.2320 seconds\nRunning polars groupby...\nPolars time: 0.0545 seconds\nPolars is 4.26x faster\n\n\nTypically, for operations like this, Polars will be 3-10x faster than pandas, especially as data sizes increase. The performance gap widens further with more complex operations that can benefit from query optimization.\n\n\n\nPandas and Polars differ in several fundamental aspects:\n\n\nPandas uses eager execution by default:\nPolars supports both eager and lazy execution:\n\n\n\nPandas often uses assignment operations:\n\n# Many pandas operations use in-place assignment\npd_df['new_col'] = pd_df['new_col'] * 2\npd_df['new_col'] = pd_df['new_col'].fillna(0)\n\n# Some operations return new DataFrames\npd_df = pd_df.sort_values('new_col')\n\nPolars consistently uses method chaining:\n\n# All operations return new DataFrames and can be chained\npl_df = (pl_df\n    .with_columns((pl.col('new_col') * 2).alias('new_col'))\n    .with_columns(pl.col('new_col').fill_null(0))\n    .sort('new_col')\n)\n\n\n\n\nPandas directly references columns:\n\npd_df['result'] = pd_df['age'] + pd_df['new_col']\nfiltered = pd_df[pd_df['age'] &gt; pd_df['age'].mean()]\n\nPolars uses an expression API:\n\npl_df = pl_df.with_columns(\n    (pl.col('age') + pl.col('new_col')).alias('result')\n)\nfiltered = pl_df.filter(pl.col('age') &gt; pl.col('age').mean())\n\n\n\n\n\nIf you‚Äôre transitioning from pandas to polars, here are key mappings between common operations:\n\n\n\n\n\n\n\n\nOperation\nPandas\nPolars\n\n\n\n\nRead CSV\npd.read_csv('file.csv')\npl.read_csv('file.csv')\n\n\nSelect columns\ndf[['col1', 'col2']]\ndf.select(['col1', 'col2'])\n\n\nAdd column\ndf['new'] = df['col1'] * 2\ndf.with_columns((pl.col('col1') * 2).alias('new'))\n\n\nFilter rows\ndf[df['col'] &gt; 5]\ndf.filter(pl.col('col') &gt; 5)\n\n\nSort\ndf.sort_values('col')\ndf.sort('col')\n\n\nGroup by\ndf.groupby('col').agg({'val': 'sum'})\ndf.group_by('col').agg(pl.col('val').sum())\n\n\nJoin\ndf1.merge(df2, on='key')\ndf1.join(df2, on='key')\n\n\nFill NA\ndf.fillna(0)\ndf.fill_null(0)\n\n\nDrop NA\ndf.dropna()\ndf.drop_nulls()\n\n\nRename\ndf.rename(columns={'a': 'b'})\ndf.rename({'a': 'b'})\n\n\nUnique values\ndf['col'].unique()\ndf.select(pl.col('col').unique())\n\n\nValue counts\ndf['col'].value_counts()\ndf.group_by('col').count()\n\n\n\n\n\n\nThink in expressions: Use pl.col() to reference columns in operations\nEmbrace method chaining: String operations together instead of intermediate variables\nTry lazy execution: For complex operations, use pl.scan_csv() and lazy operations\nUse with_columns(): Instead of direct assignment, use with_columns for adding/modifying columns\nLearn the expression functions: Many operations like string manipulation use different syntax\n\n\n\n\nDespite Polars‚Äô advantages, pandas might still be preferred when:\n\nWorking with existing codebases heavily dependent on pandas\nUsing specialized libraries that only support pandas (some visualization tools)\nDealing with very small datasets where performance isn‚Äôt critical\nUsing pandas-specific features without polars equivalents\nWorking with time series data that benefits from pandas‚Äô specialized functionality\n\n\n\n\n\nPolars offers significant performance improvements and a more consistent API compared to pandas, particularly for large datasets and complex operations. While the syntax differences require some adjustment, the benefits in speed and memory efficiency make it a compelling choice for modern data analysis workflows.\nBoth libraries have their place in the Python data ecosystem. Pandas remains the more mature option with broader ecosystem compatibility, while Polars represents the future of high-performance data processing. For new projects dealing with large datasets, Polars is increasingly becoming the recommended choice."
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#table-of-contents",
    "href": "posts/pandas-to-polars/index.html#table-of-contents",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "Installation and Setup\nCreating DataFrames\nBasic Operations\nFiltering Data\nGrouping and Aggregation\nJoining/Merging DataFrames\nHandling Missing Values\nString Operations\nTime Series Operations\nPerformance Comparison\nAPI Philosophy Differences\nMigration Guide"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#installation-and-setup",
    "href": "posts/pandas-to-polars/index.html#installation-and-setup",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "# Import pandas\nimport pandas as pd\n\n\n\n\n\n# Import polars\nimport polars as pl"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#creating-dataframes",
    "href": "posts/pandas-to-polars/index.html#creating-dataframes",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "import pandas as pd\n\n# Create DataFrame from dictionary\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'age': [25, 30, 35, 40],\n    'city': ['New York', 'Los Angeles', 'Chicago', 'Houston']\n}\ndf_pd = pd.DataFrame(data)\nprint(df_pd)\n\n      name  age         city\n0    Alice   25     New York\n1      Bob   30  Los Angeles\n2  Charlie   35      Chicago\n3    David   40      Houston\n\n\n\n\n\n\nimport polars as pl\n\n# Create DataFrame from dictionary\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'age': [25, 30, 35, 40],\n    'city': ['New York', 'Los Angeles', 'Chicago', 'Houston']\n}\ndf_pl = pl.DataFrame(data)\nprint(df_pl)\n\nshape: (4, 3)\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ name    ‚îÜ age ‚îÜ city        ‚îÇ\n‚îÇ ---     ‚îÜ --- ‚îÜ ---         ‚îÇ\n‚îÇ str     ‚îÜ i64 ‚îÜ str         ‚îÇ\n‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï°\n‚îÇ Alice   ‚îÜ 25  ‚îÜ New York    ‚îÇ\n‚îÇ Bob     ‚îÜ 30  ‚îÜ Los Angeles ‚îÇ\n‚îÇ Charlie ‚îÜ 35  ‚îÜ Chicago     ‚îÇ\n‚îÇ David   ‚îÜ 40  ‚îÜ Houston     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#basic-operations",
    "href": "posts/pandas-to-polars/index.html#basic-operations",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "# Select a single column (returns Series)\nseries = df_pd['name']\n\n# Select multiple columns\ndf_subset = df_pd[['name', 'age']]\n\n\n\n\n\n# Select a single column (returns Series)\nseries = df_pl['name']\n# Alternative method\nseries = df_pl.select(pl.col('name')).to_series()\n\n# Select multiple columns\ndf_subset = df_pl.select(['name', 'age'])\n# Alternative method\ndf_subset = df_pl.select(pl.col(['name', 'age']))\n\n\n\n\n\n\n\n\n# Add a new column\ndf_pd['is_adult'] = df_pd['age'] &gt;= 18\n\n# Using assign (creates a new DataFrame)\ndf_pd = df_pd.assign(age_squared=df_pd['age'] ** 2)\n\n\n\n\n\n# Add a new column\ndf_pl = df_pl.with_columns(\n    pl.when(pl.col('age') &gt;= 18).then(True).otherwise(False).alias('is_adult')\n)\n\n# Creating derived columns \ndf_pl = df_pl.with_columns(\n    (pl.col('age') ** 2).alias('age_squared')\n)\n\n# Multiple columns at once\ndf_pl = df_pl.with_columns([\n    pl.col('age').is_null().alias('age_is_null'),\n    (pl.col('age') * 2).alias('age_doubled')\n])\n\n\n\n\n\n\n\n\n# Get summary statistics\nsummary = df_pd.describe()\n\n# Individual statistics\nmean_age = df_pd['age'].mean()\nmedian_age = df_pd['age'].median()\nmin_age = df_pd['age'].min()\nmax_age = df_pd['age'].max()\n\n\n\n\n\n# Get summary statistics\nsummary = df_pl.describe()\n\n# Individual statistics\nmean_age = df_pl.select(pl.col('age').mean()).item()\nmedian_age = df_pl.select(pl.col('age').median()).item()\nmin_age = df_pl.select(pl.col('age').min()).item()\nmax_age = df_pl.select(pl.col('age').max()).item()"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#filtering-data",
    "href": "posts/pandas-to-polars/index.html#filtering-data",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "# Filter rows\nadults = df_pd[df_pd['age'] &gt;= 18]\n\n# Multiple conditions\nfiltered = df_pd[(df_pd['age'] &gt; 30) & (df_pd['city'] == 'Chicago')]\n\n\n\n\n\n# Filter rows\nadults = df_pl.filter(pl.col('age') &gt;= 18)\n\n# Multiple conditions\nfiltered = df_pl.filter((pl.col('age') &gt; 30) & (pl.col('city') == 'Chicago'))\n\n\n\n\n\n\n\n\n# Filter with OR conditions\ndf_filtered = df_pd[(df_pd['city'] == 'New York') | (df_pd['city'] == 'Chicago')]\n\n# Using isin\ncities = ['New York', 'Chicago']\ndf_filtered = df_pd[df_pd['city'].isin(cities)]\n\n# String contains\ndf_filtered = df_pd[df_pd['name'].str.contains('li')]\n\n\n\n\n\n# Filter with OR conditions\ndf_filtered = df_pl.filter((pl.col('city') == 'New York') | (pl.col('city') == 'Chicago'))\n\n# Using is_in\ncities = ['New York', 'Chicago']\ndf_filtered = df_pl.filter(pl.col('city').is_in(cities))\n\n# String contains\ndf_filtered = df_pl.filter(pl.col('name').str.contains('li'))"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#grouping-and-aggregation",
    "href": "posts/pandas-to-polars/index.html#grouping-and-aggregation",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "# Group by one column and aggregate\ncity_stats = df_pd.groupby('city').agg({\n    'age': ['mean', 'min', 'max', 'count']\n})\n\n# Reset index for flat DataFrame\ncity_stats = city_stats.reset_index()\n\n\n\n\n\n# Group by one column and aggregate\ncity_stats = df_pl.group_by('city').agg([\n    pl.col('age').mean().alias('age_mean'),\n    pl.col('age').min().alias('age_min'),\n    pl.col('age').max().alias('age_max'),\n    pl.col('age').count().alias('age_count')\n])"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#joiningmerging-dataframes",
    "href": "posts/pandas-to-polars/index.html#joiningmerging-dataframes",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "# Create another DataFrame\nemployee_data = {\n    'emp_id': [1, 2, 3, 4],\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'dept': ['HR', 'IT', 'Finance', 'IT']\n}\nemployee_df_pd = pd.DataFrame(employee_data)\n\nsalary_data = {\n    'emp_id': [1, 2, 3, 5],\n    'salary': [50000, 60000, 70000, 80000]\n}\nsalary_df_pd = pd.DataFrame(salary_data)\n\n# Inner join\nmerged_df = employee_df_pd.merge(\n    salary_df_pd,\n    on='emp_id',\n    how='inner'\n)\n\n\n\n\n\n# Create another DataFrame\nemployee_data = {\n    'emp_id': [1, 2, 3, 4],\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'dept': ['HR', 'IT', 'Finance', 'IT']\n}\nemployee_df_pl = pl.DataFrame(employee_data)\n\nsalary_data = {\n    'emp_id': [1, 2, 3, 5],\n    'salary': [50000, 60000, 70000, 80000]\n}\nsalary_df_pl = pl.DataFrame(salary_data)\n\n# Inner join\nmerged_df = employee_df_pl.join(\n    salary_df_pl,\n    on='emp_id',\n    how='inner'\n)\n\n\n\n\n\n\n\n\n# Left join\nleft_join = employee_df_pd.merge(salary_df_pd, on='emp_id', how='left')\n\n# Right join\nright_join = employee_df_pd.merge(salary_df_pd, on='emp_id', how='right')\n\n# Outer join\nouter_join = employee_df_pd.merge(salary_df_pd, on='emp_id', how='outer')\n\n\n\n\n\n# Left join\nleft_join = employee_df_pl.join(salary_df_pl, on='emp_id', how='left')\n\n# Right join\nright_join = employee_df_pl.join(salary_df_pl, on='emp_id', how='right')\n\n# Outer join\nouter_join = employee_df_pl.join(salary_df_pl, on='emp_id', how='full')"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#handling-missing-values",
    "href": "posts/pandas-to-polars/index.html#handling-missing-values",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "# Check for missing values\nmissing_count = df_pd.isnull().sum()\n\n# Check if any column has missing values\nhas_missing = df_pd.isnull().any().any()\n\n\n\n\n\n# Check for missing values\nmissing_count = df_pl.null_count()\n\n# Check if specific column has missing values\nhas_missing = df_pl.select(pl.col('age').is_null().any()).item()\n\n\n\n\n\n\n\n\n# Drop rows with any missing values\ndf_pd_clean = df_pd.dropna()\n\n# Fill missing values\ndf_pd_filled = df_pd.fillna({\n    'age': 0,\n    'city': 'Unknown'\n})\n\n# Forward fill\ndf_pd_ffill = df_pd.ffill()\n\n\n\n\n\n# Drop rows with any missing values\ndf_pl_clean = df_pl.drop_nulls()\n\n# Fill missing values\ndf_pl_filled = df_pl.with_columns([\n    pl.col('age').fill_null(0),\n    pl.col('city').fill_null('Unknown')\n])\n\n# Forward fill\ndf_pl_ffill = df_pl.with_columns([\n    pl.col('age').fill_null(strategy='forward'),\n    pl.col('city').fill_null(strategy='forward')\n])"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#string-operations",
    "href": "posts/pandas-to-polars/index.html#string-operations",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "# Convert to uppercase\ndf_pd['name_upper'] = df_pd['name'].str.upper()\n\n# Get string length\ndf_pd['name_length'] = df_pd['name'].str.len()\n\n# Extract substring\ndf_pd['name_first_char'] = df_pd['name'].str[0]\n\n# Replace substrings\ndf_pd['city_replaced'] = df_pd['city'].str.replace('New', 'Old')\n\n\n\n\n\n# Convert to uppercase\ndf_pl = df_pl.with_columns(pl.col('name').str.to_uppercase().alias('name_upper'))\n\n# Get string length\ndf_pl = df_pl.with_columns(pl.col('name').str.len_chars().alias('name_length'))\n\n# Extract substring \ndf_pl = df_pl.with_columns(pl.col('name').str.slice(0, 1).alias('name_first_char'))\n\n# Replace substrings\ndf_pl = df_pl.with_columns(pl.col('city').str.replace('New', 'Old').alias('city_replaced'))\n\n\n\n\n\n\n\n\n# Split string\ndf_pd['first_word'] = df_pd['city'].str.split(' ').str[0]\n\n# Pattern matching\nhas_new = df_pd['city'].str.contains('New')\n\n# Extract with regex\ndf_pd['extracted'] = df_pd['city'].str.extract(r'(\\w+)\\s')\n\n\n\n\n\n# Split string\ndf_pl = df_pl.with_columns(\n    pl.col('city').str.split(' ').list.get(0).alias('first_word')\n)\n\n# Pattern matching\ndf_pl = df_pl.with_columns(\n    pl.col('city').str.contains('New').alias('has_new')\n)\n\n# Extract with regex\ndf_pl = df_pl.with_columns(\n    pl.col('city').str.extract(r'(\\w+)\\s').alias('extracted')\n)"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#time-series-operations",
    "href": "posts/pandas-to-polars/index.html#time-series-operations",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "# Create DataFrame with dates\ndates_pd = pd.DataFrame({\n    'date_str': ['2023-01-01', '2023-02-15', '2023-03-30']\n})\n\n# Parse dates\ndates_pd['date'] = pd.to_datetime(dates_pd['date_str'])\n\n# Extract components\ndates_pd['year'] = dates_pd['date'].dt.year\ndates_pd['month'] = dates_pd['date'].dt.month\ndates_pd['day'] = dates_pd['date'].dt.day\ndates_pd['weekday'] = dates_pd['date'].dt.day_name()\n\n\n\n\n\n# Create DataFrame with dates\ndates_pl = pl.DataFrame({\n    'date_str': ['2023-01-01', '2023-02-15', '2023-03-30']\n})\n\n# Parse dates\ndates_pl = dates_pl.with_columns(\n    pl.col('date_str').str.strptime(pl.Datetime, '%Y-%m-%d').alias('date')\n)\n\n# Extract components\ndates_pl = dates_pl.with_columns([\n    pl.col('date').dt.year().alias('year'),\n    pl.col('date').dt.month().alias('month'),\n    pl.col('date').dt.day().alias('day'),\n    pl.col('date').dt.weekday().replace_strict({\n        0: 'Monday', 1: 'Tuesday', 2: 'Wednesday', \n        3: 'Thursday', 4: 'Friday', 5: 'Saturday', 6: 'Sunday'\n    }, default=\"unknown\").alias('weekday')\n])\n\n\n\n\n\n\n\n\n# Add days\ndates_pd['next_week'] = dates_pd['date'] + pd.Timedelta(days=7)\n\n# Date difference\ndate_range = pd.date_range(start='2023-01-01', end='2023-01-10')\ndf_dates = pd.DataFrame({'date': date_range})\ndf_dates['days_since_start'] = (df_dates['date'] - df_dates['date'].min()).dt.days\n\n\n\n\n\n# Add days\ndates_pl = dates_pl.with_columns(\n    (pl.col('date') + pl.duration(days=7)).alias('next_week')\n)\n\n# Date difference\ndate_range = pd.date_range(start='2023-01-01', end='2023-01-10')  # Using pandas to generate range\ndf_dates = pl.DataFrame({'date': date_range})\ndf_dates = df_dates.with_columns(\n    (pl.col('date') - pl.col('date').min()).dt.total_days().alias('days_since_start')\n)"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#performance-comparison",
    "href": "posts/pandas-to-polars/index.html#performance-comparison",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "This section demonstrates performance differences between pandas and polars for a large dataset operation.\n\nimport pandas as pd\nimport polars as pl\nimport time\nimport numpy as np\n\n# Generate a large dataset (10 million rows)\nn = 10_000_000\ndata = {\n    'id': np.arange(n),\n    'value': np.random.randn(n),\n    'group': np.random.choice(['A', 'B', 'C', 'D'], n)\n}\n\n# Convert to pandas DataFrame\ndf_pd = pd.DataFrame(data)\n\n# Convert to polars DataFrame\ndf_pl = pl.DataFrame(data)\n\n# Benchmark: Group by and calculate mean, min, max\nprint(\"Running pandas groupby...\")\nstart = time.time()\nresult_pd = df_pd.groupby('group').agg({\n    'value': ['mean', 'min', 'max', 'count']\n})\npd_time = time.time() - start\nprint(f\"Pandas time: {pd_time:.4f} seconds\")\n\nprint(\"Running polars groupby...\")\nstart = time.time()\nresult_pl = df_pl.group_by('group').agg([\n    pl.col('value').mean().alias('value_mean'),\n    pl.col('value').min().alias('value_min'),\n    pl.col('value').max().alias('value_max'),\n    pl.col('value').count().alias('value_count')\n])\npl_time = time.time() - start\nprint(f\"Polars time: {pl_time:.4f} seconds\")\n\nprint(f\"Polars is {pd_time / pl_time:.2f}x faster\")\n\nRunning pandas groupby...\nPandas time: 0.2320 seconds\nRunning polars groupby...\nPolars time: 0.0545 seconds\nPolars is 4.26x faster\n\n\nTypically, for operations like this, Polars will be 3-10x faster than pandas, especially as data sizes increase. The performance gap widens further with more complex operations that can benefit from query optimization."
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#api-philosophy-differences",
    "href": "posts/pandas-to-polars/index.html#api-philosophy-differences",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "Pandas and Polars differ in several fundamental aspects:\n\n\nPandas uses eager execution by default:\nPolars supports both eager and lazy execution:\n\n\n\nPandas often uses assignment operations:\n\n# Many pandas operations use in-place assignment\npd_df['new_col'] = pd_df['new_col'] * 2\npd_df['new_col'] = pd_df['new_col'].fillna(0)\n\n# Some operations return new DataFrames\npd_df = pd_df.sort_values('new_col')\n\nPolars consistently uses method chaining:\n\n# All operations return new DataFrames and can be chained\npl_df = (pl_df\n    .with_columns((pl.col('new_col') * 2).alias('new_col'))\n    .with_columns(pl.col('new_col').fill_null(0))\n    .sort('new_col')\n)\n\n\n\n\nPandas directly references columns:\n\npd_df['result'] = pd_df['age'] + pd_df['new_col']\nfiltered = pd_df[pd_df['age'] &gt; pd_df['age'].mean()]\n\nPolars uses an expression API:\n\npl_df = pl_df.with_columns(\n    (pl.col('age') + pl.col('new_col')).alias('result')\n)\nfiltered = pl_df.filter(pl.col('age') &gt; pl.col('age').mean())"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#migration-guide",
    "href": "posts/pandas-to-polars/index.html#migration-guide",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "If you‚Äôre transitioning from pandas to polars, here are key mappings between common operations:\n\n\n\n\n\n\n\n\nOperation\nPandas\nPolars\n\n\n\n\nRead CSV\npd.read_csv('file.csv')\npl.read_csv('file.csv')\n\n\nSelect columns\ndf[['col1', 'col2']]\ndf.select(['col1', 'col2'])\n\n\nAdd column\ndf['new'] = df['col1'] * 2\ndf.with_columns((pl.col('col1') * 2).alias('new'))\n\n\nFilter rows\ndf[df['col'] &gt; 5]\ndf.filter(pl.col('col') &gt; 5)\n\n\nSort\ndf.sort_values('col')\ndf.sort('col')\n\n\nGroup by\ndf.groupby('col').agg({'val': 'sum'})\ndf.group_by('col').agg(pl.col('val').sum())\n\n\nJoin\ndf1.merge(df2, on='key')\ndf1.join(df2, on='key')\n\n\nFill NA\ndf.fillna(0)\ndf.fill_null(0)\n\n\nDrop NA\ndf.dropna()\ndf.drop_nulls()\n\n\nRename\ndf.rename(columns={'a': 'b'})\ndf.rename({'a': 'b'})\n\n\nUnique values\ndf['col'].unique()\ndf.select(pl.col('col').unique())\n\n\nValue counts\ndf['col'].value_counts()\ndf.group_by('col').count()\n\n\n\n\n\n\nThink in expressions: Use pl.col() to reference columns in operations\nEmbrace method chaining: String operations together instead of intermediate variables\nTry lazy execution: For complex operations, use pl.scan_csv() and lazy operations\nUse with_columns(): Instead of direct assignment, use with_columns for adding/modifying columns\nLearn the expression functions: Many operations like string manipulation use different syntax\n\n\n\n\nDespite Polars‚Äô advantages, pandas might still be preferred when:\n\nWorking with existing codebases heavily dependent on pandas\nUsing specialized libraries that only support pandas (some visualization tools)\nDealing with very small datasets where performance isn‚Äôt critical\nUsing pandas-specific features without polars equivalents\nWorking with time series data that benefits from pandas‚Äô specialized functionality"
  },
  {
    "objectID": "posts/pandas-to-polars/index.html#conclusion",
    "href": "posts/pandas-to-polars/index.html#conclusion",
    "title": "From Pandas to Polars",
    "section": "",
    "text": "Polars offers significant performance improvements and a more consistent API compared to pandas, particularly for large datasets and complex operations. While the syntax differences require some adjustment, the benefits in speed and memory efficiency make it a compelling choice for modern data analysis workflows.\nBoth libraries have their place in the Python data ecosystem. Pandas remains the more mature option with broader ecosystem compatibility, while Polars represents the future of high-performance data processing. For new projects dealing with large datasets, Polars is increasingly becoming the recommended choice."
  },
  {
    "objectID": "posts/influence-selection/index.html",
    "href": "posts/influence-selection/index.html",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "Active learning is a machine learning paradigm where the algorithm can interactively query an oracle (typically a human annotator) to label new data points. The key idea is to select the most informative samples to be labeled, reducing the overall labeling effort while maintaining or improving model performance. This guide focuses on influence selection methods used in active learning strategies.\n\n\n\n\nFundamentals of Active Learning\nInfluence Selection Strategies\nUncertainty-Based Methods\nDiversity-Based Methods\nExpected Model Change\nExpected Error Reduction\nInfluence Functions\nQuery-by-Committee\nImplementation Considerations\nEvaluation Metrics\nPractical Examples\nAdvanced Topics\n\n\n\n\n\n\nThe typical active learning process follows these steps:\n\nStart with a small labeled dataset and a large unlabeled pool\nTrain an initial model on the labeled data\nApply an influence selection strategy to choose informative samples from the unlabeled pool\nGet annotations for the selected samples\nAdd the newly labeled samples to the training set\nRetrain the model and repeat steps 3-6 until a stopping condition is met\n\n\n\n\n\nPool-based: The learner has access to a pool of unlabeled data and selects the most informative samples\nStream-based: Samples arrive sequentially, and the learner must decide on-the-fly whether to request labels\n\n\n\n\n\nInfluence selection is about identifying which unlabeled samples would be most beneficial to label next. Here are the main strategies:\n\n\n\nThese methods select samples that the model is most uncertain about.\n\n\n\ndef least_confidence(model, unlabeled_pool, k):\n    # Predict probabilities for each sample in the unlabeled pool\n    probabilities = model.predict_proba(unlabeled_pool)\n    \n    # Get the confidence values for the most probable class\n    confidences = np.max(probabilities, axis=1)\n    \n    # Select the k samples with the lowest confidence\n    least_confident_indices = np.argsort(confidences)[:k]\n    \n    return unlabeled_pool[least_confident_indices]\n\n\n\n\nSelects samples with the smallest margin between the two most likely classes:\n\ndef margin_sampling(model, unlabeled_pool, k):\n    # Predict probabilities for each sample in the unlabeled pool\n    probabilities = model.predict_proba(unlabeled_pool)\n    \n    # Sort the probabilities in descending order\n    sorted_probs = np.sort(probabilities, axis=1)[:, ::-1]\n    \n    # Calculate the margin between the first and second most probable classes\n    margins = sorted_probs[:, 0] - sorted_probs[:, 1]\n    \n    # Select the k samples with the smallest margins\n    smallest_margin_indices = np.argsort(margins)[:k]\n    \n    return unlabeled_pool[smallest_margin_indices]\n\n\n\n\nSelects samples with the highest predictive entropy:\n\ndef entropy_sampling(model, unlabeled_pool, k):\n    # Predict probabilities for each sample in the unlabeled pool\n    probabilities = model.predict_proba(unlabeled_pool)\n    \n    # Calculate entropy for each sample\n    entropies = -np.sum(probabilities * np.log(probabilities + 1e-10), axis=1)\n    \n    # Select the k samples with the highest entropy\n    highest_entropy_indices = np.argsort(entropies)[::-1][:k]\n    \n    return unlabeled_pool[highest_entropy_indices]\n\n\n\n\nFor Bayesian models, BALD selects samples that maximize the mutual information between predictions and model parameters:\n\ndef bald_sampling(bayesian_model, unlabeled_pool, k, n_samples=100):\n    # Get multiple predictions by sampling from the model's posterior\n    probs_samples = []\n    for _ in range(n_samples):\n        probs = bayesian_model.predict_proba(unlabeled_pool)\n        probs_samples.append(probs)\n    \n    # Stack into a 3D array: (samples, data points, classes)\n    probs_samples = np.stack(probs_samples)\n    \n    # Calculate the average probability across all samples\n    mean_probs = np.mean(probs_samples, axis=0)\n    \n    # Calculate the entropy of the average prediction\n    entropy_mean = -np.sum(mean_probs * np.log(mean_probs + 1e-10), axis=1)\n    \n    # Calculate the average entropy across all samples\n    entropy_samples = -np.sum(probs_samples * np.log(probs_samples + 1e-10), axis=2)\n    mean_entropy = np.mean(entropy_samples, axis=0)\n    \n    # Mutual information = entropy of the mean - mean of entropies\n    bald_scores = entropy_mean - mean_entropy\n    \n    # Select the k samples with the highest BALD scores\n    highest_bald_indices = np.argsort(bald_scores)[::-1][:k]\n    \n    return unlabeled_pool[highest_bald_indices]\n\n\n\n\n\nThese methods aim to select a diverse set of examples to ensure broad coverage of the input space.\n\n\n\ndef clustering_based_sampling(unlabeled_pool, k, n_clusters=None):\n    if n_clusters is None:\n        n_clusters = k\n    \n    # Apply K-means clustering\n    kmeans = KMeans(n_clusters=n_clusters)\n    kmeans.fit(unlabeled_pool)\n    \n    # Get the cluster centers and distances to each point\n    centers = kmeans.cluster_centers_\n    distances = kmeans.transform(unlabeled_pool)  # Distance to each cluster center\n    \n    # Select one sample from each cluster (closest to the center)\n    selected_indices = []\n    for i in range(n_clusters):\n        # Get the samples in this cluster\n        cluster_samples = np.where(kmeans.labels_ == i)[0]\n        \n        # Find the sample closest to the center\n        closest_sample = cluster_samples[np.argmin(distances[cluster_samples, i])]\n        selected_indices.append(closest_sample)\n    \n    # If we need more samples than clusters, fill with the most uncertain samples\n    if k &gt; n_clusters:\n        # Implementation depends on uncertainty measure\n        pass\n    \n    return unlabeled_pool[selected_indices[:k]]\n\n\n\n\nThe core-set approach aims to select a subset of data that best represents the whole dataset:\n\ndef core_set_sampling(labeled_pool, unlabeled_pool, k):\n    # Combine labeled and unlabeled data for distance calculations\n    all_data = np.vstack((labeled_pool, unlabeled_pool))\n    \n    # Compute pairwise distances\n    distances = pairwise_distances(all_data)\n    \n    # Split distances into labeled-unlabeled and unlabeled-unlabeled\n    n_labeled = labeled_pool.shape[0]\n    dist_labeled_unlabeled = distances[:n_labeled, n_labeled:]\n    \n    # For each unlabeled sample, find the minimum distance to any labeled sample\n    min_distances = np.min(dist_labeled_unlabeled, axis=0)\n    \n    # Select the k samples with the largest minimum distances\n    farthest_indices = np.argsort(min_distances)[::-1][:k]\n    \n    return unlabeled_pool[farthest_indices]\n\n\n\n\n\nThe Expected Model Change (EMC) method selects samples that would cause the greatest change in the model if they were labeled:\n\ndef expected_model_change(model, unlabeled_pool, k):\n    # Predict probabilities for each sample in the unlabeled pool\n    probabilities = model.predict_proba(unlabeled_pool)\n    n_classes = probabilities.shape[1]\n    \n    # Calculate expected gradient length for each sample\n    expected_changes = []\n    for i, x in enumerate(unlabeled_pool):\n        # Calculate expected gradient length across all possible labels\n        change = 0\n        for c in range(n_classes):\n            # For each possible class, calculate the gradient if this was the true label\n            x_expanded = x.reshape(1, -1)\n            # Here we would compute the gradient of the model with respect to the sample\n            # For simplicity, we use a placeholder\n            gradient = compute_gradient(model, x_expanded, c)\n            norm_gradient = np.linalg.norm(gradient)\n            \n            # Weight by the probability of this class\n            change += probabilities[i, c] * norm_gradient\n        \n        expected_changes.append(change)\n    \n    # Select the k samples with the highest expected change\n    highest_change_indices = np.argsort(expected_changes)[::-1][:k]\n    \n    return unlabeled_pool[highest_change_indices]\n\nNote: The compute_gradient function would need to be implemented based on the specific model being used.\n\n\n\nThe Expected Error Reduction method selects samples that, when labeled, would minimally reduce the model‚Äôs expected error:\n\ndef expected_error_reduction(model, unlabeled_pool, unlabeled_pool_remaining, k):\n    # Predict probabilities for all remaining unlabeled data\n    current_probs = model.predict_proba(unlabeled_pool_remaining)\n    current_entropy = -np.sum(current_probs * np.log(current_probs + 1e-10), axis=1)\n    \n    expected_error_reductions = []\n    \n    # For each sample in the unlabeled pool we're considering\n    for i, x in enumerate(unlabeled_pool):\n        # Predict probabilities for this sample\n        probs = model.predict_proba(x.reshape(1, -1))[0]\n        \n        # Calculate the expected error reduction for each possible label\n        error_reduction = 0\n        for c in range(len(probs)):\n            # Create a hypothetical new model with this labeled sample\n            # For simplicity, we use a placeholder function\n            hypothetical_model = train_with_additional_sample(model, x, c)\n            \n            # Get new probabilities with this model\n            new_probs = hypothetical_model.predict_proba(unlabeled_pool_remaining)\n            new_entropy = -np.sum(new_probs * np.log(new_probs + 1e-10), axis=1)\n            \n            # Expected entropy reduction\n            reduction = np.sum(current_entropy - new_entropy)\n            \n            # Weight by the probability of this class\n            error_reduction += probs[c] * reduction\n        \n        expected_error_reductions.append(error_reduction)\n    \n    # Select the k samples with the highest expected error reduction\n    highest_reduction_indices = np.argsort(expected_error_reductions)[::-1][:k]\n    \n    return unlabeled_pool[highest_reduction_indices]\n\nNote: The train_with_additional_sample function would need to be implemented based on the specific model being used.\n\n\n\nInfluence functions approximate the effect of adding or removing a training example without retraining the model:\n\ndef influence_function_sampling(model, unlabeled_pool, labeled_pool, k, labels):\n    influences = []\n    \n    # For each unlabeled sample\n    for x_u in unlabeled_pool:\n        # Calculate the influence of adding this sample to the training set\n        influence = calculate_influence(model, x_u, labeled_pool, labels)\n        influences.append(influence)\n    \n    # Select the k samples with the highest influence\n    highest_influence_indices = np.argsort(influences)[::-1][:k]\n    \n    return unlabeled_pool[highest_influence_indices]\n\nNote: The calculate_influence function would need to be implemented based on the specific model and influence metric being used.\n\n\n\nQuery-by-Committee (QBC) methods train multiple models (a committee) and select samples where they disagree:\n\ndef query_by_committee(committee_models, unlabeled_pool, k):\n    # Get predictions from all committee members\n    all_predictions = []\n    for model in committee_models:\n        preds = model.predict(unlabeled_pool)\n        all_predictions.append(preds)\n    \n    # Stack predictions into a 2D array (committee members, data points)\n    all_predictions = np.stack(all_predictions)\n    \n    # Calculate disagreement (e.g., using vote entropy)\n    disagreements = []\n    for i in range(unlabeled_pool.shape[0]):\n        # Count votes for each class\n        votes = np.bincount(all_predictions[:, i])\n        # Normalize to get probabilities\n        vote_probs = votes / len(committee_models)\n        # Calculate entropy\n        entropy = -np.sum(vote_probs * np.log2(vote_probs + 1e-10))\n        disagreements.append(entropy)\n    \n    # Select the k samples with the highest disagreement\n    highest_disagreement_indices = np.argsort(disagreements)[::-1][:k]\n    \n    return unlabeled_pool[highest_disagreement_indices]\n\n\n\n\n\n\nIn practice, it‚Äôs often more efficient to select multiple samples at once. However, simply selecting the top-k samples may lead to redundancy. Consider using:\n\nGreedy Selection with Diversity: Select one sample at a time, then update the diversity metrics to avoid selecting similar samples.\n\n\ndef batch_selection_with_diversity(model, unlabeled_pool, k, lambda_diversity=0.5):\n    selected_indices = []\n    remaining_indices = list(range(len(unlabeled_pool)))\n    \n    # Calculate uncertainty scores for all samples\n    probabilities = model.predict_proba(unlabeled_pool)\n    entropies = -np.sum(probabilities * np.log(probabilities + 1e-10), axis=1)\n    \n    # Calculate distance matrix for diversity\n    distance_matrix = pairwise_distances(unlabeled_pool)\n    \n    for _ in range(k):\n        if not remaining_indices:\n            break\n        \n        scores = np.zeros(len(remaining_indices))\n        \n        # Calculate uncertainty scores\n        uncertainty_scores = entropies[remaining_indices]\n        \n        # Calculate diversity scores (if we have already selected some samples)\n        if selected_indices:\n            # For each remaining sample, calculate the minimum distance to any selected sample\n            diversity_scores = np.min(distance_matrix[remaining_indices][:, selected_indices], axis=1)\n        else:\n            diversity_scores = np.zeros(len(remaining_indices))\n        \n        # Normalize scores\n        uncertainty_scores = (uncertainty_scores - np.min(uncertainty_scores)) / (np.max(uncertainty_scores) - np.min(uncertainty_scores) + 1e-10)\n        if selected_indices:\n            diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-10)\n        \n        # Combine scores\n        scores = (1 - lambda_diversity) * uncertainty_scores + lambda_diversity * diversity_scores\n        \n        # Select the sample with the highest score\n        best_idx = np.argmax(scores)\n        selected_idx = remaining_indices[best_idx]\n        \n        # Add to selected and remove from remaining\n        selected_indices.append(selected_idx)\n        remaining_indices.remove(selected_idx)\n    \n    return unlabeled_pool[selected_indices]\n\n\nSubmodular Function Maximization: Use a submodular function to ensure diversity in the selected batch.\n\n\n\n\nActive learning can inadvertently reinforce class imbalance. Consider:\n\nStratified Sampling: Ensure representation from all classes.\nHybrid Approaches: Combine uncertainty-based and density-based methods.\nDiversity Constraints: Explicitly enforce diversity in feature space.\n\n\n\n\nSome methods (like expected error reduction) can be computationally expensive. Consider:\n\nSubsample the Unlabeled Pool: Only consider a random subset for selection.\nPre-compute Embeddings: Use a fixed feature extractor to pre-compute embeddings.\nApproximate Methods: Use approximations for expensive operations.\n\n\n\n\n\n\n\nPlot model performance vs.¬†number of labeled samples:\n\ndef plot_learning_curve(model_factory, X_train, y_train, X_test, y_test, \n                        active_learning_strategy, initial_size=10, \n                        batch_size=10, n_iterations=20):\n    # Initialize with a small labeled set\n    labeled_indices = np.random.choice(len(X_train), initial_size, replace=False)\n    unlabeled_indices = np.setdiff1d(np.arange(len(X_train)), labeled_indices)\n    \n    performance = []\n    \n    for i in range(n_iterations):\n        # Create a fresh model\n        model = model_factory()\n        \n        # Train on the currently labeled data\n        model.fit(X_train[labeled_indices], y_train[labeled_indices])\n        \n        # Evaluate on the test set\n        score = model.score(X_test, y_test)\n        performance.append((len(labeled_indices), score))\n        \n        # Select the next batch of samples\n        if len(unlabeled_indices) &gt; 0:\n            # Use the specified active learning strategy\n            selected_indices = active_learning_strategy(\n                model, X_train[unlabeled_indices], batch_size\n            )\n            \n            # Map back to original indices\n            selected_original_indices = unlabeled_indices[selected_indices]\n            \n            # Update labeled and unlabeled indices\n            labeled_indices = np.append(labeled_indices, selected_original_indices)\n            unlabeled_indices = np.setdiff1d(unlabeled_indices, selected_original_indices)\n    \n    # Plot the learning curve\n    counts, scores = zip(*performance)\n    plt.figure(figsize=(10, 6))\n    plt.plot(counts, scores, 'o-')\n    plt.xlabel('Number of labeled samples')\n    plt.ylabel('Model accuracy')\n    plt.title('Active Learning Performance')\n    plt.grid(True)\n    \n    return performance\n\n\n\n\nAlways compare your active learning strategy with random sampling as a baseline.\n\n\n\nCalculate how many annotations you saved compared to using the entire dataset.\n\n\n\n\n\n\n\nimport numpy as np\nfrom sklearn.datasets import fetch_openml\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\n\n# Load data\nmnist = fetch_openml('mnist_784', version=1, cache=True)\nX, y = mnist['data'], mnist['target']\n\n# Split into train and test\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\n# Initially, only a small portion is labeled\ninitial_size = 100\nlabeled_indices = np.random.choice(len(X_train), initial_size, replace=False)\nunlabeled_indices = np.setdiff1d(np.arange(len(X_train)), labeled_indices)\n\n# Tracking performance\nactive_learning_performance = []\nrandom_sampling_performance = []\n\n# Active learning loop\nfor i in range(10):  # 10 iterations\n    # Train a model on the currently labeled data\n    model = RandomForestClassifier(n_estimators=50, random_state=42)\n    model.fit(X_train.iloc[labeled_indices], y_train.iloc[labeled_indices])\n    \n    # Evaluate on the test set\n    y_pred = model.predict(X_test)\n    accuracy = accuracy_score(y_test, y_pred)\n    active_learning_performance.append((len(labeled_indices), accuracy))\n    \n    print(f\"Iteration {i+1}: {len(labeled_indices)} labeled samples, \"\n          f\"accuracy: {accuracy:.4f}\")\n    \n    # Select 100 new samples using entropy sampling\n    if len(unlabeled_indices) &gt; 0:\n        # Predict probabilities for each unlabeled sample\n        probs = model.predict_proba(X_train.iloc[unlabeled_indices])\n        \n        # Calculate entropy\n        entropies = -np.sum(probs * np.log(probs + 1e-10), axis=1)\n        \n        # Select samples with the highest entropy\n        top_indices = np.argsort(entropies)[::-1][:100]\n        \n        # Update labeled and unlabeled indices\n        selected_indices = unlabeled_indices[top_indices]\n        labeled_indices = np.append(labeled_indices, selected_indices)\n        unlabeled_indices = np.setdiff1d(unlabeled_indices, selected_indices)\n\n# Plot learning curve\ncounts, scores = zip(*active_learning_performance)\nplt.figure(figsize=(10, 6))\nplt.plot(counts, scores, 'o-', label='Active Learning')\nplt.xlabel('Number of labeled samples')\nplt.ylabel('Model accuracy')\nplt.title('Active Learning Performance')\nplt.grid(True)\nplt.legend()\nplt.show()\n\nIteration 1: 100 labeled samples, accuracy: 0.6755\nIteration 2: 200 labeled samples, accuracy: 0.7300\nIteration 3: 300 labeled samples, accuracy: 0.7716\nIteration 4: 400 labeled samples, accuracy: 0.8097\nIteration 5: 500 labeled samples, accuracy: 0.8359\nIteration 6: 600 labeled samples, accuracy: 0.8366\nIteration 7: 700 labeled samples, accuracy: 0.8494\nIteration 8: 800 labeled samples, accuracy: 0.8509\nIteration 9: 900 labeled samples, accuracy: 0.8678\nIteration 10: 1000 labeled samples, accuracy: 0.8758\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import VotingClassifier\nfrom sklearn.datasets import fetch_20newsgroups\n\n# Load data\ncategories = ['alt.atheism', 'soc.religion.christian', 'comp.graphics', 'sci.med']\ntwenty_train = fetch_20newsgroups(subset='train', categories=categories, shuffle=True, random_state=42)\ntwenty_test = fetch_20newsgroups(subset='test', categories=categories, shuffle=True, random_state=42)\n\n# Feature extraction\nvectorizer = TfidfVectorizer(stop_words='english')\nX_train = vectorizer.fit_transform(twenty_train.data)\nX_test = vectorizer.transform(twenty_test.data)\ny_train = twenty_train.target\ny_test = twenty_test.target\n\n# Initially, only a small portion is labeled\ninitial_size = 20\nlabeled_indices = np.random.choice(len(X_train.toarray()), initial_size, replace=False)\nunlabeled_indices = np.setdiff1d(np.arange(len(X_train.toarray())), labeled_indices)\n\n# Create a committee of models\nmodels = [\n    ('nb', MultinomialNB()),\n    ('svm', SVC(kernel='linear', probability=True)),\n    ('svm2', SVC(kernel='rbf', probability=True))\n]\n\n# Active learning loop\nfor i in range(10):  # 10 iterations\n    # Train each model on the currently labeled data\n    committee_models = []\n    for name, model in models:\n        model.fit(X_train[labeled_indices], y_train[labeled_indices])\n        committee_models.append(model)\n    \n    # Evaluate using the VotingClassifier\n    voting_clf = VotingClassifier(estimators=models, voting='soft')\n    voting_clf.fit(X_train[labeled_indices], y_train[labeled_indices])\n    \n    accuracy = voting_clf.score(X_test, y_test)\n    print(f\"Iteration {i+1}: {len(labeled_indices)} labeled samples, \"\n          f\"accuracy: {accuracy:.4f}\")\n    \n    # Select 10 new samples using Query-by-Committee\n    if len(unlabeled_indices) &gt; 0:\n        # Get predictions from all committee members\n        all_predictions = []\n        for model in committee_models:\n            preds = model.predict(X_train[unlabeled_indices])\n            all_predictions.append(preds)\n        \n        # Calculate vote entropy\n        vote_entropies = []\n        all_predictions = np.array(all_predictions)\n        for i in range(len(unlabeled_indices)):\n            # Count votes for each class\n            votes = np.bincount(all_predictions[:, i], minlength=len(categories))\n            # Normalize to get probabilities\n            vote_probs = votes / len(committee_models)\n            # Calculate entropy\n            entropy = -np.sum(vote_probs * np.log2(vote_probs + 1e-10))\n            vote_entropies.append(entropy)\n        \n        # Select samples with the highest vote entropy\n        top_indices = np.argsort(vote_entropies)[::-1][:10]\n        \n        # Update labeled and unlabeled indices\n        selected_indices = unlabeled_indices[top_indices]\n        labeled_indices = np.append(labeled_indices, selected_indices)\n        unlabeled_indices = np.setdiff1d(unlabeled_indices, selected_indices)\n\nIteration 1: 20 labeled samples, accuracy: 0.2124\nIteration 2: 30 labeled samples, accuracy: 0.2310\nIteration 3: 40 labeled samples, accuracy: 0.3668\nIteration 4: 50 labeled samples, accuracy: 0.2983\nIteration 5: 60 labeled samples, accuracy: 0.4627\nIteration 6: 70 labeled samples, accuracy: 0.6312\nIteration 7: 80 labeled samples, accuracy: 0.6864\nIteration 8: 90 labeled samples, accuracy: 0.6125\nIteration 9: 100 labeled samples, accuracy: 0.7597\nIteration 10: 110 labeled samples, accuracy: 0.7870\n\n\n\n\n\n\n\n\nCombining transfer learning with active learning can be powerful:\n\nUse pre-trained models as feature extractors.\nApply active learning on the feature space.\nFine-tune the model on the selected samples.\n\n\n\n\nSpecial considerations for deep learning models:\n\nUncertainty Estimation: Use dropout or ensemble methods for better uncertainty estimation.\nBatch Normalization: Be careful with batch normalization layers when retraining.\nData Augmentation: Apply data augmentation to increase the effective size of the labeled pool.\n\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.utils.data import DataLoader, Subset\nimport torchvision.transforms as transforms\nimport torchvision.datasets as datasets\n\n# Define a simple CNN\nclass SimpleCNN(nn.Module):\n    def __init__(self):\n        super(SimpleCNN, self).__init__()\n        self.conv1 = nn.Conv2d(1, 32, 3, 1)\n        self.conv2 = nn.Conv2d(32, 64, 3, 1)\n        self.dropout1 = nn.Dropout2d(0.25)\n        self.dropout2 = nn.Dropout2d(0.5)\n        self.fc1 = nn.Linear(9216, 128)\n        self.fc2 = nn.Linear(128, 10)\n\n    def forward(self, x, dropout=True):\n        x = self.conv1(x)\n        x = F.relu(x)\n        x = self.conv2(x)\n        x = F.relu(x)\n        x = F.max_pool2d(x, 2)\n        if dropout:\n            x = self.dropout1(x)\n        x = torch.flatten(x, 1)\n        x = self.fc1(x)\n        x = F.relu(x)\n        if dropout:\n            x = self.dropout2(x)\n        x = self.fc2(x)\n        return x\n\n# MC Dropout for uncertainty estimation\ndef mc_dropout_uncertainty(model, data_loader, n_samples=10):\n    model.eval()\n    all_probs = []\n    \n    with torch.no_grad():\n        for _ in range(n_samples):\n            batch_probs = []\n            for data, _ in data_loader:\n                output = model(data, dropout=True)\n                probs = F.softmax(output, dim=1)\n                batch_probs.append(probs)\n            \n            # Concatenate batch probabilities\n            all_probs.append(torch.cat(batch_probs))\n    \n    # Stack along a new dimension\n    all_probs = torch.stack(all_probs)\n    \n    # Calculate the mean probabilities\n    mean_probs = torch.mean(all_probs, dim=0)\n    \n    # Calculate entropy of the mean prediction\n    entropy = -torch.sum(mean_probs * torch.log(mean_probs + 1e-10), dim=1)\n    \n    return entropy.numpy()\n\n\n\n\nLeverage both labeled and unlabeled data during training:\n\nSelf-Training: Use model predictions on unlabeled data as pseudo-labels.\nCo-Training: Train multiple models and use their predictions to teach each other.\nConsistency Regularization: Enforce consistent predictions across different perturbations.\n\n\ndef semi_supervised_active_learning(labeled_X, labeled_y, unlabeled_X, model, confidence_threshold=0.95):\n    # Train model on labeled data\n    model.fit(labeled_X, labeled_y)\n    \n    # Predict on unlabeled data\n    probabilities = model.predict_proba(unlabeled_X)\n    max_probs = np.max(probabilities, axis=1)\n    \n    # Get high confidence predictions\n    confident_indices = np.where(max_probs &gt;= confidence_threshold)[0]\n    \n    # Get pseudo-labels for confident predictions\n    pseudo_labels = model.predict(unlabeled_X[confident_indices])\n    \n    # Train on combined dataset\n    combined_X = np.vstack([labeled_X, unlabeled_X[confident_indices]])\n    combined_y = np.concatenate([labeled_y, pseudo_labels])\n    \n    model.fit(combined_X, combined_y)\n    \n    return model, confident_indices\n\n\n\n\nWhen labeled data from the target domain is scarce, active learning can help select the most informative samples:\n\nDomain Discrepancy Measures: Select samples that minimize domain discrepancy.\nAdversarial Selection: Select samples that the domain discriminator is most uncertain about.\nFeature Space Alignment: Select samples that help align feature spaces between domains.\n\n\n\n\n\nAnnotation Interface Design: Make the annotation process intuitive and efficient.\nCognitive Load Management: Group similar samples to reduce cognitive switching.\nExplanations: Provide model explanations to help annotators understand the current model‚Äôs decisions.\nQuality Control: Incorporate mechanisms to detect and correct annotation errors.\n\n\n\n\n\nActive learning provides a powerful framework for efficiently building machine learning models with limited labeled data. By selecting the most informative samples for annotation, active learning can significantly reduce the labeling effort while maintaining high model performance.\nThe key to successful active learning is choosing the right influence selection strategy for your specific problem and data characteristics. Consider the following when designing your active learning pipeline:\n\nData Characteristics: Dense vs.¬†sparse data, balanced vs.¬†imbalanced classes, feature distribution.\nModel Type: Linear models, tree-based models, deep learning models.\nComputational Resources: Available memory and processing power.\nAnnotation Budget: Number of samples that can be labeled.\nTask Complexity: Classification vs.¬†regression, number of classes, difficulty of the task.\n\nBy carefully considering these factors and implementing the appropriate influence selection methods, you can build high-performance models with minimal annotation effort."
  },
  {
    "objectID": "posts/influence-selection/index.html#introduction",
    "href": "posts/influence-selection/index.html#introduction",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "Active learning is a machine learning paradigm where the algorithm can interactively query an oracle (typically a human annotator) to label new data points. The key idea is to select the most informative samples to be labeled, reducing the overall labeling effort while maintaining or improving model performance. This guide focuses on influence selection methods used in active learning strategies."
  },
  {
    "objectID": "posts/influence-selection/index.html#table-of-contents",
    "href": "posts/influence-selection/index.html#table-of-contents",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "Fundamentals of Active Learning\nInfluence Selection Strategies\nUncertainty-Based Methods\nDiversity-Based Methods\nExpected Model Change\nExpected Error Reduction\nInfluence Functions\nQuery-by-Committee\nImplementation Considerations\nEvaluation Metrics\nPractical Examples\nAdvanced Topics"
  },
  {
    "objectID": "posts/influence-selection/index.html#fundamentals-of-active-learning",
    "href": "posts/influence-selection/index.html#fundamentals-of-active-learning",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "The typical active learning process follows these steps:\n\nStart with a small labeled dataset and a large unlabeled pool\nTrain an initial model on the labeled data\nApply an influence selection strategy to choose informative samples from the unlabeled pool\nGet annotations for the selected samples\nAdd the newly labeled samples to the training set\nRetrain the model and repeat steps 3-6 until a stopping condition is met\n\n\n\n\n\nPool-based: The learner has access to a pool of unlabeled data and selects the most informative samples\nStream-based: Samples arrive sequentially, and the learner must decide on-the-fly whether to request labels"
  },
  {
    "objectID": "posts/influence-selection/index.html#influence-selection-strategies",
    "href": "posts/influence-selection/index.html#influence-selection-strategies",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "Influence selection is about identifying which unlabeled samples would be most beneficial to label next. Here are the main strategies:"
  },
  {
    "objectID": "posts/influence-selection/index.html#uncertainty-based-methods",
    "href": "posts/influence-selection/index.html#uncertainty-based-methods",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "These methods select samples that the model is most uncertain about.\n\n\n\ndef least_confidence(model, unlabeled_pool, k):\n    # Predict probabilities for each sample in the unlabeled pool\n    probabilities = model.predict_proba(unlabeled_pool)\n    \n    # Get the confidence values for the most probable class\n    confidences = np.max(probabilities, axis=1)\n    \n    # Select the k samples with the lowest confidence\n    least_confident_indices = np.argsort(confidences)[:k]\n    \n    return unlabeled_pool[least_confident_indices]\n\n\n\n\nSelects samples with the smallest margin between the two most likely classes:\n\ndef margin_sampling(model, unlabeled_pool, k):\n    # Predict probabilities for each sample in the unlabeled pool\n    probabilities = model.predict_proba(unlabeled_pool)\n    \n    # Sort the probabilities in descending order\n    sorted_probs = np.sort(probabilities, axis=1)[:, ::-1]\n    \n    # Calculate the margin between the first and second most probable classes\n    margins = sorted_probs[:, 0] - sorted_probs[:, 1]\n    \n    # Select the k samples with the smallest margins\n    smallest_margin_indices = np.argsort(margins)[:k]\n    \n    return unlabeled_pool[smallest_margin_indices]\n\n\n\n\nSelects samples with the highest predictive entropy:\n\ndef entropy_sampling(model, unlabeled_pool, k):\n    # Predict probabilities for each sample in the unlabeled pool\n    probabilities = model.predict_proba(unlabeled_pool)\n    \n    # Calculate entropy for each sample\n    entropies = -np.sum(probabilities * np.log(probabilities + 1e-10), axis=1)\n    \n    # Select the k samples with the highest entropy\n    highest_entropy_indices = np.argsort(entropies)[::-1][:k]\n    \n    return unlabeled_pool[highest_entropy_indices]\n\n\n\n\nFor Bayesian models, BALD selects samples that maximize the mutual information between predictions and model parameters:\n\ndef bald_sampling(bayesian_model, unlabeled_pool, k, n_samples=100):\n    # Get multiple predictions by sampling from the model's posterior\n    probs_samples = []\n    for _ in range(n_samples):\n        probs = bayesian_model.predict_proba(unlabeled_pool)\n        probs_samples.append(probs)\n    \n    # Stack into a 3D array: (samples, data points, classes)\n    probs_samples = np.stack(probs_samples)\n    \n    # Calculate the average probability across all samples\n    mean_probs = np.mean(probs_samples, axis=0)\n    \n    # Calculate the entropy of the average prediction\n    entropy_mean = -np.sum(mean_probs * np.log(mean_probs + 1e-10), axis=1)\n    \n    # Calculate the average entropy across all samples\n    entropy_samples = -np.sum(probs_samples * np.log(probs_samples + 1e-10), axis=2)\n    mean_entropy = np.mean(entropy_samples, axis=0)\n    \n    # Mutual information = entropy of the mean - mean of entropies\n    bald_scores = entropy_mean - mean_entropy\n    \n    # Select the k samples with the highest BALD scores\n    highest_bald_indices = np.argsort(bald_scores)[::-1][:k]\n    \n    return unlabeled_pool[highest_bald_indices]"
  },
  {
    "objectID": "posts/influence-selection/index.html#diversity-based-methods",
    "href": "posts/influence-selection/index.html#diversity-based-methods",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "These methods aim to select a diverse set of examples to ensure broad coverage of the input space.\n\n\n\ndef clustering_based_sampling(unlabeled_pool, k, n_clusters=None):\n    if n_clusters is None:\n        n_clusters = k\n    \n    # Apply K-means clustering\n    kmeans = KMeans(n_clusters=n_clusters)\n    kmeans.fit(unlabeled_pool)\n    \n    # Get the cluster centers and distances to each point\n    centers = kmeans.cluster_centers_\n    distances = kmeans.transform(unlabeled_pool)  # Distance to each cluster center\n    \n    # Select one sample from each cluster (closest to the center)\n    selected_indices = []\n    for i in range(n_clusters):\n        # Get the samples in this cluster\n        cluster_samples = np.where(kmeans.labels_ == i)[0]\n        \n        # Find the sample closest to the center\n        closest_sample = cluster_samples[np.argmin(distances[cluster_samples, i])]\n        selected_indices.append(closest_sample)\n    \n    # If we need more samples than clusters, fill with the most uncertain samples\n    if k &gt; n_clusters:\n        # Implementation depends on uncertainty measure\n        pass\n    \n    return unlabeled_pool[selected_indices[:k]]\n\n\n\n\nThe core-set approach aims to select a subset of data that best represents the whole dataset:\n\ndef core_set_sampling(labeled_pool, unlabeled_pool, k):\n    # Combine labeled and unlabeled data for distance calculations\n    all_data = np.vstack((labeled_pool, unlabeled_pool))\n    \n    # Compute pairwise distances\n    distances = pairwise_distances(all_data)\n    \n    # Split distances into labeled-unlabeled and unlabeled-unlabeled\n    n_labeled = labeled_pool.shape[0]\n    dist_labeled_unlabeled = distances[:n_labeled, n_labeled:]\n    \n    # For each unlabeled sample, find the minimum distance to any labeled sample\n    min_distances = np.min(dist_labeled_unlabeled, axis=0)\n    \n    # Select the k samples with the largest minimum distances\n    farthest_indices = np.argsort(min_distances)[::-1][:k]\n    \n    return unlabeled_pool[farthest_indices]"
  },
  {
    "objectID": "posts/influence-selection/index.html#expected-model-change",
    "href": "posts/influence-selection/index.html#expected-model-change",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "The Expected Model Change (EMC) method selects samples that would cause the greatest change in the model if they were labeled:\n\ndef expected_model_change(model, unlabeled_pool, k):\n    # Predict probabilities for each sample in the unlabeled pool\n    probabilities = model.predict_proba(unlabeled_pool)\n    n_classes = probabilities.shape[1]\n    \n    # Calculate expected gradient length for each sample\n    expected_changes = []\n    for i, x in enumerate(unlabeled_pool):\n        # Calculate expected gradient length across all possible labels\n        change = 0\n        for c in range(n_classes):\n            # For each possible class, calculate the gradient if this was the true label\n            x_expanded = x.reshape(1, -1)\n            # Here we would compute the gradient of the model with respect to the sample\n            # For simplicity, we use a placeholder\n            gradient = compute_gradient(model, x_expanded, c)\n            norm_gradient = np.linalg.norm(gradient)\n            \n            # Weight by the probability of this class\n            change += probabilities[i, c] * norm_gradient\n        \n        expected_changes.append(change)\n    \n    # Select the k samples with the highest expected change\n    highest_change_indices = np.argsort(expected_changes)[::-1][:k]\n    \n    return unlabeled_pool[highest_change_indices]\n\nNote: The compute_gradient function would need to be implemented based on the specific model being used."
  },
  {
    "objectID": "posts/influence-selection/index.html#expected-error-reduction",
    "href": "posts/influence-selection/index.html#expected-error-reduction",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "The Expected Error Reduction method selects samples that, when labeled, would minimally reduce the model‚Äôs expected error:\n\ndef expected_error_reduction(model, unlabeled_pool, unlabeled_pool_remaining, k):\n    # Predict probabilities for all remaining unlabeled data\n    current_probs = model.predict_proba(unlabeled_pool_remaining)\n    current_entropy = -np.sum(current_probs * np.log(current_probs + 1e-10), axis=1)\n    \n    expected_error_reductions = []\n    \n    # For each sample in the unlabeled pool we're considering\n    for i, x in enumerate(unlabeled_pool):\n        # Predict probabilities for this sample\n        probs = model.predict_proba(x.reshape(1, -1))[0]\n        \n        # Calculate the expected error reduction for each possible label\n        error_reduction = 0\n        for c in range(len(probs)):\n            # Create a hypothetical new model with this labeled sample\n            # For simplicity, we use a placeholder function\n            hypothetical_model = train_with_additional_sample(model, x, c)\n            \n            # Get new probabilities with this model\n            new_probs = hypothetical_model.predict_proba(unlabeled_pool_remaining)\n            new_entropy = -np.sum(new_probs * np.log(new_probs + 1e-10), axis=1)\n            \n            # Expected entropy reduction\n            reduction = np.sum(current_entropy - new_entropy)\n            \n            # Weight by the probability of this class\n            error_reduction += probs[c] * reduction\n        \n        expected_error_reductions.append(error_reduction)\n    \n    # Select the k samples with the highest expected error reduction\n    highest_reduction_indices = np.argsort(expected_error_reductions)[::-1][:k]\n    \n    return unlabeled_pool[highest_reduction_indices]\n\nNote: The train_with_additional_sample function would need to be implemented based on the specific model being used."
  },
  {
    "objectID": "posts/influence-selection/index.html#influence-functions",
    "href": "posts/influence-selection/index.html#influence-functions",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "Influence functions approximate the effect of adding or removing a training example without retraining the model:\n\ndef influence_function_sampling(model, unlabeled_pool, labeled_pool, k, labels):\n    influences = []\n    \n    # For each unlabeled sample\n    for x_u in unlabeled_pool:\n        # Calculate the influence of adding this sample to the training set\n        influence = calculate_influence(model, x_u, labeled_pool, labels)\n        influences.append(influence)\n    \n    # Select the k samples with the highest influence\n    highest_influence_indices = np.argsort(influences)[::-1][:k]\n    \n    return unlabeled_pool[highest_influence_indices]\n\nNote: The calculate_influence function would need to be implemented based on the specific model and influence metric being used."
  },
  {
    "objectID": "posts/influence-selection/index.html#query-by-committee",
    "href": "posts/influence-selection/index.html#query-by-committee",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "Query-by-Committee (QBC) methods train multiple models (a committee) and select samples where they disagree:\n\ndef query_by_committee(committee_models, unlabeled_pool, k):\n    # Get predictions from all committee members\n    all_predictions = []\n    for model in committee_models:\n        preds = model.predict(unlabeled_pool)\n        all_predictions.append(preds)\n    \n    # Stack predictions into a 2D array (committee members, data points)\n    all_predictions = np.stack(all_predictions)\n    \n    # Calculate disagreement (e.g., using vote entropy)\n    disagreements = []\n    for i in range(unlabeled_pool.shape[0]):\n        # Count votes for each class\n        votes = np.bincount(all_predictions[:, i])\n        # Normalize to get probabilities\n        vote_probs = votes / len(committee_models)\n        # Calculate entropy\n        entropy = -np.sum(vote_probs * np.log2(vote_probs + 1e-10))\n        disagreements.append(entropy)\n    \n    # Select the k samples with the highest disagreement\n    highest_disagreement_indices = np.argsort(disagreements)[::-1][:k]\n    \n    return unlabeled_pool[highest_disagreement_indices]"
  },
  {
    "objectID": "posts/influence-selection/index.html#implementation-considerations",
    "href": "posts/influence-selection/index.html#implementation-considerations",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "In practice, it‚Äôs often more efficient to select multiple samples at once. However, simply selecting the top-k samples may lead to redundancy. Consider using:\n\nGreedy Selection with Diversity: Select one sample at a time, then update the diversity metrics to avoid selecting similar samples.\n\n\ndef batch_selection_with_diversity(model, unlabeled_pool, k, lambda_diversity=0.5):\n    selected_indices = []\n    remaining_indices = list(range(len(unlabeled_pool)))\n    \n    # Calculate uncertainty scores for all samples\n    probabilities = model.predict_proba(unlabeled_pool)\n    entropies = -np.sum(probabilities * np.log(probabilities + 1e-10), axis=1)\n    \n    # Calculate distance matrix for diversity\n    distance_matrix = pairwise_distances(unlabeled_pool)\n    \n    for _ in range(k):\n        if not remaining_indices:\n            break\n        \n        scores = np.zeros(len(remaining_indices))\n        \n        # Calculate uncertainty scores\n        uncertainty_scores = entropies[remaining_indices]\n        \n        # Calculate diversity scores (if we have already selected some samples)\n        if selected_indices:\n            # For each remaining sample, calculate the minimum distance to any selected sample\n            diversity_scores = np.min(distance_matrix[remaining_indices][:, selected_indices], axis=1)\n        else:\n            diversity_scores = np.zeros(len(remaining_indices))\n        \n        # Normalize scores\n        uncertainty_scores = (uncertainty_scores - np.min(uncertainty_scores)) / (np.max(uncertainty_scores) - np.min(uncertainty_scores) + 1e-10)\n        if selected_indices:\n            diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-10)\n        \n        # Combine scores\n        scores = (1 - lambda_diversity) * uncertainty_scores + lambda_diversity * diversity_scores\n        \n        # Select the sample with the highest score\n        best_idx = np.argmax(scores)\n        selected_idx = remaining_indices[best_idx]\n        \n        # Add to selected and remove from remaining\n        selected_indices.append(selected_idx)\n        remaining_indices.remove(selected_idx)\n    \n    return unlabeled_pool[selected_indices]\n\n\nSubmodular Function Maximization: Use a submodular function to ensure diversity in the selected batch.\n\n\n\n\nActive learning can inadvertently reinforce class imbalance. Consider:\n\nStratified Sampling: Ensure representation from all classes.\nHybrid Approaches: Combine uncertainty-based and density-based methods.\nDiversity Constraints: Explicitly enforce diversity in feature space.\n\n\n\n\nSome methods (like expected error reduction) can be computationally expensive. Consider:\n\nSubsample the Unlabeled Pool: Only consider a random subset for selection.\nPre-compute Embeddings: Use a fixed feature extractor to pre-compute embeddings.\nApproximate Methods: Use approximations for expensive operations."
  },
  {
    "objectID": "posts/influence-selection/index.html#evaluation-metrics",
    "href": "posts/influence-selection/index.html#evaluation-metrics",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "Plot model performance vs.¬†number of labeled samples:\n\ndef plot_learning_curve(model_factory, X_train, y_train, X_test, y_test, \n                        active_learning_strategy, initial_size=10, \n                        batch_size=10, n_iterations=20):\n    # Initialize with a small labeled set\n    labeled_indices = np.random.choice(len(X_train), initial_size, replace=False)\n    unlabeled_indices = np.setdiff1d(np.arange(len(X_train)), labeled_indices)\n    \n    performance = []\n    \n    for i in range(n_iterations):\n        # Create a fresh model\n        model = model_factory()\n        \n        # Train on the currently labeled data\n        model.fit(X_train[labeled_indices], y_train[labeled_indices])\n        \n        # Evaluate on the test set\n        score = model.score(X_test, y_test)\n        performance.append((len(labeled_indices), score))\n        \n        # Select the next batch of samples\n        if len(unlabeled_indices) &gt; 0:\n            # Use the specified active learning strategy\n            selected_indices = active_learning_strategy(\n                model, X_train[unlabeled_indices], batch_size\n            )\n            \n            # Map back to original indices\n            selected_original_indices = unlabeled_indices[selected_indices]\n            \n            # Update labeled and unlabeled indices\n            labeled_indices = np.append(labeled_indices, selected_original_indices)\n            unlabeled_indices = np.setdiff1d(unlabeled_indices, selected_original_indices)\n    \n    # Plot the learning curve\n    counts, scores = zip(*performance)\n    plt.figure(figsize=(10, 6))\n    plt.plot(counts, scores, 'o-')\n    plt.xlabel('Number of labeled samples')\n    plt.ylabel('Model accuracy')\n    plt.title('Active Learning Performance')\n    plt.grid(True)\n    \n    return performance\n\n\n\n\nAlways compare your active learning strategy with random sampling as a baseline.\n\n\n\nCalculate how many annotations you saved compared to using the entire dataset."
  },
  {
    "objectID": "posts/influence-selection/index.html#practical-examples",
    "href": "posts/influence-selection/index.html#practical-examples",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "import numpy as np\nfrom sklearn.datasets import fetch_openml\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\n\n# Load data\nmnist = fetch_openml('mnist_784', version=1, cache=True)\nX, y = mnist['data'], mnist['target']\n\n# Split into train and test\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\n# Initially, only a small portion is labeled\ninitial_size = 100\nlabeled_indices = np.random.choice(len(X_train), initial_size, replace=False)\nunlabeled_indices = np.setdiff1d(np.arange(len(X_train)), labeled_indices)\n\n# Tracking performance\nactive_learning_performance = []\nrandom_sampling_performance = []\n\n# Active learning loop\nfor i in range(10):  # 10 iterations\n    # Train a model on the currently labeled data\n    model = RandomForestClassifier(n_estimators=50, random_state=42)\n    model.fit(X_train.iloc[labeled_indices], y_train.iloc[labeled_indices])\n    \n    # Evaluate on the test set\n    y_pred = model.predict(X_test)\n    accuracy = accuracy_score(y_test, y_pred)\n    active_learning_performance.append((len(labeled_indices), accuracy))\n    \n    print(f\"Iteration {i+1}: {len(labeled_indices)} labeled samples, \"\n          f\"accuracy: {accuracy:.4f}\")\n    \n    # Select 100 new samples using entropy sampling\n    if len(unlabeled_indices) &gt; 0:\n        # Predict probabilities for each unlabeled sample\n        probs = model.predict_proba(X_train.iloc[unlabeled_indices])\n        \n        # Calculate entropy\n        entropies = -np.sum(probs * np.log(probs + 1e-10), axis=1)\n        \n        # Select samples with the highest entropy\n        top_indices = np.argsort(entropies)[::-1][:100]\n        \n        # Update labeled and unlabeled indices\n        selected_indices = unlabeled_indices[top_indices]\n        labeled_indices = np.append(labeled_indices, selected_indices)\n        unlabeled_indices = np.setdiff1d(unlabeled_indices, selected_indices)\n\n# Plot learning curve\ncounts, scores = zip(*active_learning_performance)\nplt.figure(figsize=(10, 6))\nplt.plot(counts, scores, 'o-', label='Active Learning')\nplt.xlabel('Number of labeled samples')\nplt.ylabel('Model accuracy')\nplt.title('Active Learning Performance')\nplt.grid(True)\nplt.legend()\nplt.show()\n\nIteration 1: 100 labeled samples, accuracy: 0.6755\nIteration 2: 200 labeled samples, accuracy: 0.7300\nIteration 3: 300 labeled samples, accuracy: 0.7716\nIteration 4: 400 labeled samples, accuracy: 0.8097\nIteration 5: 500 labeled samples, accuracy: 0.8359\nIteration 6: 600 labeled samples, accuracy: 0.8366\nIteration 7: 700 labeled samples, accuracy: 0.8494\nIteration 8: 800 labeled samples, accuracy: 0.8509\nIteration 9: 900 labeled samples, accuracy: 0.8678\nIteration 10: 1000 labeled samples, accuracy: 0.8758\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import VotingClassifier\nfrom sklearn.datasets import fetch_20newsgroups\n\n# Load data\ncategories = ['alt.atheism', 'soc.religion.christian', 'comp.graphics', 'sci.med']\ntwenty_train = fetch_20newsgroups(subset='train', categories=categories, shuffle=True, random_state=42)\ntwenty_test = fetch_20newsgroups(subset='test', categories=categories, shuffle=True, random_state=42)\n\n# Feature extraction\nvectorizer = TfidfVectorizer(stop_words='english')\nX_train = vectorizer.fit_transform(twenty_train.data)\nX_test = vectorizer.transform(twenty_test.data)\ny_train = twenty_train.target\ny_test = twenty_test.target\n\n# Initially, only a small portion is labeled\ninitial_size = 20\nlabeled_indices = np.random.choice(len(X_train.toarray()), initial_size, replace=False)\nunlabeled_indices = np.setdiff1d(np.arange(len(X_train.toarray())), labeled_indices)\n\n# Create a committee of models\nmodels = [\n    ('nb', MultinomialNB()),\n    ('svm', SVC(kernel='linear', probability=True)),\n    ('svm2', SVC(kernel='rbf', probability=True))\n]\n\n# Active learning loop\nfor i in range(10):  # 10 iterations\n    # Train each model on the currently labeled data\n    committee_models = []\n    for name, model in models:\n        model.fit(X_train[labeled_indices], y_train[labeled_indices])\n        committee_models.append(model)\n    \n    # Evaluate using the VotingClassifier\n    voting_clf = VotingClassifier(estimators=models, voting='soft')\n    voting_clf.fit(X_train[labeled_indices], y_train[labeled_indices])\n    \n    accuracy = voting_clf.score(X_test, y_test)\n    print(f\"Iteration {i+1}: {len(labeled_indices)} labeled samples, \"\n          f\"accuracy: {accuracy:.4f}\")\n    \n    # Select 10 new samples using Query-by-Committee\n    if len(unlabeled_indices) &gt; 0:\n        # Get predictions from all committee members\n        all_predictions = []\n        for model in committee_models:\n            preds = model.predict(X_train[unlabeled_indices])\n            all_predictions.append(preds)\n        \n        # Calculate vote entropy\n        vote_entropies = []\n        all_predictions = np.array(all_predictions)\n        for i in range(len(unlabeled_indices)):\n            # Count votes for each class\n            votes = np.bincount(all_predictions[:, i], minlength=len(categories))\n            # Normalize to get probabilities\n            vote_probs = votes / len(committee_models)\n            # Calculate entropy\n            entropy = -np.sum(vote_probs * np.log2(vote_probs + 1e-10))\n            vote_entropies.append(entropy)\n        \n        # Select samples with the highest vote entropy\n        top_indices = np.argsort(vote_entropies)[::-1][:10]\n        \n        # Update labeled and unlabeled indices\n        selected_indices = unlabeled_indices[top_indices]\n        labeled_indices = np.append(labeled_indices, selected_indices)\n        unlabeled_indices = np.setdiff1d(unlabeled_indices, selected_indices)\n\nIteration 1: 20 labeled samples, accuracy: 0.2124\nIteration 2: 30 labeled samples, accuracy: 0.2310\nIteration 3: 40 labeled samples, accuracy: 0.3668\nIteration 4: 50 labeled samples, accuracy: 0.2983\nIteration 5: 60 labeled samples, accuracy: 0.4627\nIteration 6: 70 labeled samples, accuracy: 0.6312\nIteration 7: 80 labeled samples, accuracy: 0.6864\nIteration 8: 90 labeled samples, accuracy: 0.6125\nIteration 9: 100 labeled samples, accuracy: 0.7597\nIteration 10: 110 labeled samples, accuracy: 0.7870"
  },
  {
    "objectID": "posts/influence-selection/index.html#advanced-topics",
    "href": "posts/influence-selection/index.html#advanced-topics",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "Combining transfer learning with active learning can be powerful:\n\nUse pre-trained models as feature extractors.\nApply active learning on the feature space.\nFine-tune the model on the selected samples.\n\n\n\n\nSpecial considerations for deep learning models:\n\nUncertainty Estimation: Use dropout or ensemble methods for better uncertainty estimation.\nBatch Normalization: Be careful with batch normalization layers when retraining.\nData Augmentation: Apply data augmentation to increase the effective size of the labeled pool.\n\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.utils.data import DataLoader, Subset\nimport torchvision.transforms as transforms\nimport torchvision.datasets as datasets\n\n# Define a simple CNN\nclass SimpleCNN(nn.Module):\n    def __init__(self):\n        super(SimpleCNN, self).__init__()\n        self.conv1 = nn.Conv2d(1, 32, 3, 1)\n        self.conv2 = nn.Conv2d(32, 64, 3, 1)\n        self.dropout1 = nn.Dropout2d(0.25)\n        self.dropout2 = nn.Dropout2d(0.5)\n        self.fc1 = nn.Linear(9216, 128)\n        self.fc2 = nn.Linear(128, 10)\n\n    def forward(self, x, dropout=True):\n        x = self.conv1(x)\n        x = F.relu(x)\n        x = self.conv2(x)\n        x = F.relu(x)\n        x = F.max_pool2d(x, 2)\n        if dropout:\n            x = self.dropout1(x)\n        x = torch.flatten(x, 1)\n        x = self.fc1(x)\n        x = F.relu(x)\n        if dropout:\n            x = self.dropout2(x)\n        x = self.fc2(x)\n        return x\n\n# MC Dropout for uncertainty estimation\ndef mc_dropout_uncertainty(model, data_loader, n_samples=10):\n    model.eval()\n    all_probs = []\n    \n    with torch.no_grad():\n        for _ in range(n_samples):\n            batch_probs = []\n            for data, _ in data_loader:\n                output = model(data, dropout=True)\n                probs = F.softmax(output, dim=1)\n                batch_probs.append(probs)\n            \n            # Concatenate batch probabilities\n            all_probs.append(torch.cat(batch_probs))\n    \n    # Stack along a new dimension\n    all_probs = torch.stack(all_probs)\n    \n    # Calculate the mean probabilities\n    mean_probs = torch.mean(all_probs, dim=0)\n    \n    # Calculate entropy of the mean prediction\n    entropy = -torch.sum(mean_probs * torch.log(mean_probs + 1e-10), dim=1)\n    \n    return entropy.numpy()\n\n\n\n\nLeverage both labeled and unlabeled data during training:\n\nSelf-Training: Use model predictions on unlabeled data as pseudo-labels.\nCo-Training: Train multiple models and use their predictions to teach each other.\nConsistency Regularization: Enforce consistent predictions across different perturbations.\n\n\ndef semi_supervised_active_learning(labeled_X, labeled_y, unlabeled_X, model, confidence_threshold=0.95):\n    # Train model on labeled data\n    model.fit(labeled_X, labeled_y)\n    \n    # Predict on unlabeled data\n    probabilities = model.predict_proba(unlabeled_X)\n    max_probs = np.max(probabilities, axis=1)\n    \n    # Get high confidence predictions\n    confident_indices = np.where(max_probs &gt;= confidence_threshold)[0]\n    \n    # Get pseudo-labels for confident predictions\n    pseudo_labels = model.predict(unlabeled_X[confident_indices])\n    \n    # Train on combined dataset\n    combined_X = np.vstack([labeled_X, unlabeled_X[confident_indices]])\n    combined_y = np.concatenate([labeled_y, pseudo_labels])\n    \n    model.fit(combined_X, combined_y)\n    \n    return model, confident_indices\n\n\n\n\nWhen labeled data from the target domain is scarce, active learning can help select the most informative samples:\n\nDomain Discrepancy Measures: Select samples that minimize domain discrepancy.\nAdversarial Selection: Select samples that the domain discriminator is most uncertain about.\nFeature Space Alignment: Select samples that help align feature spaces between domains.\n\n\n\n\n\nAnnotation Interface Design: Make the annotation process intuitive and efficient.\nCognitive Load Management: Group similar samples to reduce cognitive switching.\nExplanations: Provide model explanations to help annotators understand the current model‚Äôs decisions.\nQuality Control: Incorporate mechanisms to detect and correct annotation errors."
  },
  {
    "objectID": "posts/influence-selection/index.html#conclusion",
    "href": "posts/influence-selection/index.html#conclusion",
    "title": "Active Learning Influence Selection: A Comprehensive Guide",
    "section": "",
    "text": "Active learning provides a powerful framework for efficiently building machine learning models with limited labeled data. By selecting the most informative samples for annotation, active learning can significantly reduce the labeling effort while maintaining high model performance.\nThe key to successful active learning is choosing the right influence selection strategy for your specific problem and data characteristics. Consider the following when designing your active learning pipeline:\n\nData Characteristics: Dense vs.¬†sparse data, balanced vs.¬†imbalanced classes, feature distribution.\nModel Type: Linear models, tree-based models, deep learning models.\nComputational Resources: Available memory and processing power.\nAnnotation Budget: Number of samples that can be labeled.\nTask Complexity: Classification vs.¬†regression, number of classes, difficulty of the task.\n\nBy carefully considering these factors and implementing the appropriate influence selection methods, you can build high-performance models with minimal annotation effort."
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html",
    "href": "posts/data-visualization-tutorial/index.html",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "This guide compares three popular Python data visualization libraries: Matplotlib, Seaborn, and Altair (Vega-Altair). Each library has its own strengths, weaknesses, and ideal use cases. This comparison will help you choose the right tool for your specific visualization needs.\n\n\n\n\n\n\n\n\n\n\n\nFeature\nMatplotlib\nSeaborn\nAltair\n\n\n\n\nRelease Year\n2003\n2013\n2016\n\n\nFoundation\nStandalone\nBuilt on Matplotlib\nBased on Vega-Lite\n\n\nPhilosophy\nImperative\nStatistical\nDeclarative\n\n\nAbstraction Level\nLow\nMedium\nHigh\n\n\nLearning Curve\nSteep\nModerate\nGentle\n\n\nCode Verbosity\nHigh\nMedium\nLow\n\n\nCustomization\nExtensive\nGood\nLimited\n\n\nStatistical Integration\nManual\nBuilt-in\nGood\n\n\nInteractive Features\nLimited\nLimited\nExcellent\n\n\nPerformance with Large Data\nGood\nModerate\nLimited\n\n\nCommunity & Resources\nExtensive\nGood\nGrowing\n\n\n\n\n\n\nMatplotlib is the foundational plotting library in Python‚Äôs data visualization ecosystem.\n\n\n\nFine-grained control: Almost every aspect of a visualization can be customized\nVersatility: Can create virtually any type of static plot\nMaturity: Extensive documentation and community support\nEcosystem integration: Many libraries integrate with or build upon Matplotlib\nPerformance: Handles large datasets well\n\n\n\n\n\nVerbose syntax: Requires many lines of code for complex visualizations\nSteep learning curve: Many functions and parameters to learn\nDefault aesthetics: Basic default styling (though this has improved)\nLimited interactivity: Primarily designed for static plots\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Sample data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\n# Create figure and axis\nfig, ax = plt.subplots(figsize=(8, 4))\n\n# Plot data\nax.plot(x, y, label='Sine Wave')\n\n# Add grid, legend, title and labels\nax.grid(True)\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\nax.set_title('Simple Sine Wave Plot')\nax.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nYou need complete control over every aspect of your visualization\nYou‚Äôre creating complex, publication-quality figures\nYou‚Äôre working with specialized plot types not available in higher-level libraries\nYou need to integrate with many other Python libraries\nYou‚Äôre working with large datasets\n\n\n\n\n\nSeaborn is a statistical visualization library built on top of Matplotlib.\n\n\n\nAesthetic defaults: Beautiful out-of-the-box styling\nStatistical integration: Built-in support for statistical visualizations\nDataset awareness: Works well with pandas DataFrames\nSimplicity: Fewer lines of code than Matplotlib for common plots\nHigh-level functions: Specialized plots like lmplot, catplot, etc.\n\n\n\n\n\nLimited customization: Some advanced customizations require falling back to Matplotlib\nPerformance: Can be slower with very large datasets\nRestricted scope: Focused on statistical visualization, not general-purpose plotting\n\n\n\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create sample data\nx = np.linspace(0, 10, 100)\ny = np.sin(x) + np.random.normal(0, 0.2, size=len(x))\ndata = pd.DataFrame({'x': x, 'y': y})\n\n# Set the aesthetic style\nsns.set_theme(style=\"whitegrid\")\n\n# Create the plot\nplt.figure(figsize=(8, 4))\nsns.lineplot(data=data, x='x', y='y', label='Noisy Sine Wave')\nsns.regplot(data=data, x='x', y='y', scatter=False, label='Regression Line')\n\n# Add title and labels\nplt.title('Seaborn Line Plot with Regression')\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nYou want attractive visualizations with minimal code\nYou‚Äôre performing statistical analysis\nYou‚Äôre working with pandas DataFrames\nYou‚Äôre creating common statistical plots (distributions, relationships, categorical plots)\nYou want the power of Matplotlib with a simpler interface\n\n\n\n\n\nAltair is a declarative statistical visualization library based on Vega-Lite.\n\n\n\nDeclarative approach: Focus on what to visualize, not how to draw it\nConcise syntax: Very readable, clear code\nLayered grammar of graphics: Intuitive composition of plots\nInteractive visualizations: Built-in support for interactive features\nJSON output: Visualizations can be saved as JSON specifications\n\n\n\n\n\nPerformance limitations: Not ideal for very large datasets (&gt;5000 points)\nLimited customization: Less fine-grained control than Matplotlib\nLearning curve: Different paradigm from traditional plotting libraries\nBrowser dependency: Uses JavaScript rendering for advanced features\n\n\n\n\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\n# Create sample data\nx = np.linspace(0, 10, 100)\ny = np.sin(x) + np.random.normal(0, 0.2, size=len(x))\ndata = pd.DataFrame({'x': x, 'y': y})\n\n# Create a simple scatter plot with interactive tooltips\nchart = alt.Chart(data).mark_circle().encode(\n    x='x',\n    y='y',\n    tooltip=['x', 'y']\n).properties(\n    width=600,\n    height=300,\n    title='Interactive Altair Scatter Plot'\n).interactive()\n\n# Add a regression line\nregression = alt.Chart(data).transform_regression(\n    'x', 'y'\n).mark_line(color='red').encode(\n    x='x',\n    y='y'\n)\n\n# Combine the plots\nfinal_chart = chart + regression\n\n# Display the chart\nfinal_chart\n\n\n\n\n\n\n\n\n\n\n\nYou want interactive visualizations\nYou prefer a declarative approach to visualization\nYou‚Äôre working with small to medium-sized datasets\nYou want to publish visualizations on the web\nYou appreciate a consistent grammar of graphics\n\n\n\n\n\n\n\nMatplotlib:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.random.randn(100)\ny = np.random.randn(100)\n\nplt.figure(figsize=(8, 6))\nplt.scatter(x, y, alpha=0.7)\nplt.title('Matplotlib Scatter Plot')\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nSeaborn:\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'x': np.random.randn(100),\n    'y': np.random.randn(100)\n})\n\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(8, 6))\nsns.scatterplot(data=data, x='x', y='y', alpha=0.7)\nplt.title('Seaborn Scatter Plot')\nplt.show()\n\n\n\n\n\n\n\n\nAltair:\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\ndata = pd.DataFrame({\n    'x': np.random.randn(100),\n    'y': np.random.randn(100)\n})\n\nalt.Chart(data).mark_circle(opacity=0.7).encode(\n    x='x',\n    y='y'\n).properties(\n    width=500,\n    height=400,\n    title='Altair Scatter Plot'\n)\n\n\n\n\n\n\n\n\n\n\nMatplotlib:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = np.random.randn(1000)\n\nplt.figure(figsize=(8, 6))\nplt.hist(data, bins=30, alpha=0.7, edgecolor='black')\nplt.title('Matplotlib Histogram')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\nplt.grid(True, alpha=0.3)\nplt.show()\n\n\n\n\n\n\n\n\nSeaborn:\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = np.random.randn(1000)\n\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(8, 6))\nsns.histplot(data=data, bins=30, kde=True)\nplt.title('Seaborn Histogram with KDE')\nplt.show()\n\n\n\n\n\n\n\n\nAltair:\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\ndata = pd.DataFrame({'value': np.random.randn(1000)})\n\nalt.Chart(data).mark_bar().encode(\n    alt.X('value', bin=alt.Bin(maxbins=30)),\n    y='count()'\n).properties(\n    width=500,\n    height=400,\n    title='Altair Histogram'\n)\n\n\n\n\n\n\n\n\n\n\nMatplotlib:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\n\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label='Sine')\nplt.plot(x, y2, label='Cosine')\nplt.title('Matplotlib Line Plot')\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nSeaborn:\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nx = np.linspace(0, 10, 100)\ndata = pd.DataFrame({\n    'x': np.concatenate([x, x]),\n    'y': np.concatenate([np.sin(x), np.cos(x)]),\n    'function': ['Sine']*100 + ['Cosine']*100\n})\n\nsns.set_theme(style=\"darkgrid\")\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=data, x='x', y='y', hue='function')\nplt.title('Seaborn Line Plot')\nplt.show()\n\n\n\n\n\n\n\n\nAltair:\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ndata = pd.DataFrame({\n    'x': np.concatenate([x, x]),\n    'y': np.concatenate([np.sin(x), np.cos(x)]),\n    'function': ['Sine']*100 + ['Cosine']*100\n})\n\nalt.Chart(data).mark_line().encode(\n    x='x',\n    y='y',\n    color='function'\n).properties(\n    width=600,\n    height=400,\n    title='Altair Line Plot'\n)\n\n\n\n\n\n\n\n\n\n\nMatplotlib:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = np.random.rand(10, 12)\n\nplt.figure(figsize=(10, 8))\nplt.imshow(data, cmap='viridis')\nplt.colorbar(label='Value')\nplt.title('Matplotlib Heatmap')\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.show()\n\n\n\n\n\n\n\n\nSeaborn:\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = np.random.rand(10, 12)\n\nplt.figure(figsize=(10, 8))\nsns.heatmap(data, annot=True, cmap='viridis', fmt='.2f')\nplt.title('Seaborn Heatmap')\nplt.show()\n\n\n\n\n\n\n\n\nAltair:\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\n# Create sample data\ndata = np.random.rand(10, 12)\ndf = pd.DataFrame(data)\n\n# Reshape for Altair\ndf_long = df.reset_index().melt(id_vars='index')\ndf_long.columns = ['y', 'x', 'value']\n\nalt.Chart(df_long).mark_rect().encode(\n    x='x:O',\n    y='y:O',\n    color='value:Q'\n).properties(\n    width=500,\n    height=400,\n    title='Altair Heatmap'\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou need complete control over every detail of your visualization\nYou‚Äôre creating complex, custom plots\nYour visualizations will be included in scientific publications\nYou‚Äôre working with very large datasets\nYou need to create animations or specialized chart types\n\n\n\n\n\nYou want attractive plots with minimal code\nYou‚Äôre performing statistical analysis\nYou want to create common statistical plots quickly\nYou need to visualize relationships between variables\nYou want good-looking defaults but still need some customization\n\n\n\n\n\nYou want interactive visualizations\nYou prefer a declarative approach to visualization\nYou want concise, readable code\nYou‚Äôre creating dashboards or web-based visualizations\nYou‚Äôre working with small to medium-sized datasets\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\nimport pandas as pd\n\n# Create sample data\nnp.random.seed(42)\ndata = pd.DataFrame({\n    'x': np.random.normal(0, 1, 100),\n    'y': np.random.normal(0, 1, 100),\n    'category': np.random.choice(['A', 'B', 'C'], 100)\n})\n\n# Create a figure with Matplotlib\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Use Seaborn for the main plot\nsns.scatterplot(data=data, x='x', y='y', hue='category', ax=ax)\n\n# Add Matplotlib customizations\nax.set_title('Combining Matplotlib and Seaborn', fontsize=16)\nax.grid(True, linestyle='--', alpha=0.7)\nax.set_xlabel('X Variable', fontsize=12)\nax.set_ylabel('Y Variable', fontsize=12)\n\n# Add annotations using Matplotlib\nax.annotate('Interesting Point', xy=(-1, 1), xytext=(-2, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\n# Create sample data with pandas\nnp.random.seed(42)\ndf = pd.DataFrame({\n    'date': pd.date_range('2023-01-01', periods=100),\n    'value': np.cumsum(np.random.randn(100)),\n    'category': np.random.choice(['Group A', 'Group B'], 100)\n})\n\n# Use pandas to prepare the data\ndf['month'] = df['date'].dt.month\nmonthly_avg = df.groupby(['month', 'category'])['value'].mean().reset_index()\n\n# Create the Altair visualization\nchart = alt.Chart(monthly_avg).mark_line(point=True).encode(\n    x='month:O',\n    y='value:Q',\n    color='category:N',\n    tooltip=['month', 'value', 'category']\n).properties(\n    width=600,\n    height=400,\n    title='Monthly Averages by Category'\n).interactive()\n\nchart\n\n\n\n\n\n\n\n\n\n\n\nFor libraries like Matplotlib, Seaborn, and Altair, performance can vary widely depending on the size of your dataset and the complexity of your visualization. Here‚Äôs a general overview:\n\n\n\nAll three libraries perform well\nAltair might have slightly more overhead due to its JSON specification generation\n\n\n\n\n\nMatplotlib and Seaborn continue to perform well\nAltair starts to slow down but remains usable\n\n\n\n\n\nMatplotlib performs best for large static visualizations\nSeaborn becomes slower as it adds statistical computations\nAltair significantly slows down and may require data aggregation\n\n\n\n\n\nMatplotlib: Use plot() instead of scatter() for line plots, or try hexbin() for density plots\nSeaborn: Use sample() or aggregation methods before plotting\nAltair: Use transform_sample() or pre-aggregate your data\n\n\n\n\n\nThe Python visualization ecosystem offers tools for every need, from low-level control to high-level abstraction:\n\nMatplotlib provides ultimate flexibility and control but requires more code and knowledge\nSeaborn offers a perfect middle ground with statistical integration and clean defaults\nAltair delivers a concise, declarative approach with built-in interactivity\n\nRather than picking just one library, consider becoming familiar with all three and selecting the right tool for each visualization task. Many data scientists use a combination of these libraries, leveraging the strengths of each one as needed.\nFor those just starting, Seaborn provides a gentle entry point with attractive results for common visualization needs. As your skills advance, you can incorporate Matplotlib for customization and Altair for interactive visualizations."
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html#quick-reference-comparison",
    "href": "posts/data-visualization-tutorial/index.html#quick-reference-comparison",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "Feature\nMatplotlib\nSeaborn\nAltair\n\n\n\n\nRelease Year\n2003\n2013\n2016\n\n\nFoundation\nStandalone\nBuilt on Matplotlib\nBased on Vega-Lite\n\n\nPhilosophy\nImperative\nStatistical\nDeclarative\n\n\nAbstraction Level\nLow\nMedium\nHigh\n\n\nLearning Curve\nSteep\nModerate\nGentle\n\n\nCode Verbosity\nHigh\nMedium\nLow\n\n\nCustomization\nExtensive\nGood\nLimited\n\n\nStatistical Integration\nManual\nBuilt-in\nGood\n\n\nInteractive Features\nLimited\nLimited\nExcellent\n\n\nPerformance with Large Data\nGood\nModerate\nLimited\n\n\nCommunity & Resources\nExtensive\nGood\nGrowing"
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html#matplotlib",
    "href": "posts/data-visualization-tutorial/index.html#matplotlib",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "Matplotlib is the foundational plotting library in Python‚Äôs data visualization ecosystem.\n\n\n\nFine-grained control: Almost every aspect of a visualization can be customized\nVersatility: Can create virtually any type of static plot\nMaturity: Extensive documentation and community support\nEcosystem integration: Many libraries integrate with or build upon Matplotlib\nPerformance: Handles large datasets well\n\n\n\n\n\nVerbose syntax: Requires many lines of code for complex visualizations\nSteep learning curve: Many functions and parameters to learn\nDefault aesthetics: Basic default styling (though this has improved)\nLimited interactivity: Primarily designed for static plots\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Sample data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\n# Create figure and axis\nfig, ax = plt.subplots(figsize=(8, 4))\n\n# Plot data\nax.plot(x, y, label='Sine Wave')\n\n# Add grid, legend, title and labels\nax.grid(True)\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\nax.set_title('Simple Sine Wave Plot')\nax.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nYou need complete control over every aspect of your visualization\nYou‚Äôre creating complex, publication-quality figures\nYou‚Äôre working with specialized plot types not available in higher-level libraries\nYou need to integrate with many other Python libraries\nYou‚Äôre working with large datasets"
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html#seaborn",
    "href": "posts/data-visualization-tutorial/index.html#seaborn",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "Seaborn is a statistical visualization library built on top of Matplotlib.\n\n\n\nAesthetic defaults: Beautiful out-of-the-box styling\nStatistical integration: Built-in support for statistical visualizations\nDataset awareness: Works well with pandas DataFrames\nSimplicity: Fewer lines of code than Matplotlib for common plots\nHigh-level functions: Specialized plots like lmplot, catplot, etc.\n\n\n\n\n\nLimited customization: Some advanced customizations require falling back to Matplotlib\nPerformance: Can be slower with very large datasets\nRestricted scope: Focused on statistical visualization, not general-purpose plotting\n\n\n\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# Create sample data\nx = np.linspace(0, 10, 100)\ny = np.sin(x) + np.random.normal(0, 0.2, size=len(x))\ndata = pd.DataFrame({'x': x, 'y': y})\n\n# Set the aesthetic style\nsns.set_theme(style=\"whitegrid\")\n\n# Create the plot\nplt.figure(figsize=(8, 4))\nsns.lineplot(data=data, x='x', y='y', label='Noisy Sine Wave')\nsns.regplot(data=data, x='x', y='y', scatter=False, label='Regression Line')\n\n# Add title and labels\nplt.title('Seaborn Line Plot with Regression')\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nYou want attractive visualizations with minimal code\nYou‚Äôre performing statistical analysis\nYou‚Äôre working with pandas DataFrames\nYou‚Äôre creating common statistical plots (distributions, relationships, categorical plots)\nYou want the power of Matplotlib with a simpler interface"
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html#altair-vega-altair",
    "href": "posts/data-visualization-tutorial/index.html#altair-vega-altair",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "Altair is a declarative statistical visualization library based on Vega-Lite.\n\n\n\nDeclarative approach: Focus on what to visualize, not how to draw it\nConcise syntax: Very readable, clear code\nLayered grammar of graphics: Intuitive composition of plots\nInteractive visualizations: Built-in support for interactive features\nJSON output: Visualizations can be saved as JSON specifications\n\n\n\n\n\nPerformance limitations: Not ideal for very large datasets (&gt;5000 points)\nLimited customization: Less fine-grained control than Matplotlib\nLearning curve: Different paradigm from traditional plotting libraries\nBrowser dependency: Uses JavaScript rendering for advanced features\n\n\n\n\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\n# Create sample data\nx = np.linspace(0, 10, 100)\ny = np.sin(x) + np.random.normal(0, 0.2, size=len(x))\ndata = pd.DataFrame({'x': x, 'y': y})\n\n# Create a simple scatter plot with interactive tooltips\nchart = alt.Chart(data).mark_circle().encode(\n    x='x',\n    y='y',\n    tooltip=['x', 'y']\n).properties(\n    width=600,\n    height=300,\n    title='Interactive Altair Scatter Plot'\n).interactive()\n\n# Add a regression line\nregression = alt.Chart(data).transform_regression(\n    'x', 'y'\n).mark_line(color='red').encode(\n    x='x',\n    y='y'\n)\n\n# Combine the plots\nfinal_chart = chart + regression\n\n# Display the chart\nfinal_chart\n\n\n\n\n\n\n\n\n\n\n\nYou want interactive visualizations\nYou prefer a declarative approach to visualization\nYou‚Äôre working with small to medium-sized datasets\nYou want to publish visualizations on the web\nYou appreciate a consistent grammar of graphics"
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html#common-visualization-types-comparison",
    "href": "posts/data-visualization-tutorial/index.html#common-visualization-types-comparison",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "Matplotlib:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.random.randn(100)\ny = np.random.randn(100)\n\nplt.figure(figsize=(8, 6))\nplt.scatter(x, y, alpha=0.7)\nplt.title('Matplotlib Scatter Plot')\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nSeaborn:\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'x': np.random.randn(100),\n    'y': np.random.randn(100)\n})\n\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(8, 6))\nsns.scatterplot(data=data, x='x', y='y', alpha=0.7)\nplt.title('Seaborn Scatter Plot')\nplt.show()\n\n\n\n\n\n\n\n\nAltair:\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\ndata = pd.DataFrame({\n    'x': np.random.randn(100),\n    'y': np.random.randn(100)\n})\n\nalt.Chart(data).mark_circle(opacity=0.7).encode(\n    x='x',\n    y='y'\n).properties(\n    width=500,\n    height=400,\n    title='Altair Scatter Plot'\n)\n\n\n\n\n\n\n\n\n\n\nMatplotlib:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = np.random.randn(1000)\n\nplt.figure(figsize=(8, 6))\nplt.hist(data, bins=30, alpha=0.7, edgecolor='black')\nplt.title('Matplotlib Histogram')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\nplt.grid(True, alpha=0.3)\nplt.show()\n\n\n\n\n\n\n\n\nSeaborn:\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = np.random.randn(1000)\n\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(8, 6))\nsns.histplot(data=data, bins=30, kde=True)\nplt.title('Seaborn Histogram with KDE')\nplt.show()\n\n\n\n\n\n\n\n\nAltair:\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\ndata = pd.DataFrame({'value': np.random.randn(1000)})\n\nalt.Chart(data).mark_bar().encode(\n    alt.X('value', bin=alt.Bin(maxbins=30)),\n    y='count()'\n).properties(\n    width=500,\n    height=400,\n    title='Altair Histogram'\n)\n\n\n\n\n\n\n\n\n\n\nMatplotlib:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\n\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label='Sine')\nplt.plot(x, y2, label='Cosine')\nplt.title('Matplotlib Line Plot')\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nSeaborn:\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nx = np.linspace(0, 10, 100)\ndata = pd.DataFrame({\n    'x': np.concatenate([x, x]),\n    'y': np.concatenate([np.sin(x), np.cos(x)]),\n    'function': ['Sine']*100 + ['Cosine']*100\n})\n\nsns.set_theme(style=\"darkgrid\")\nplt.figure(figsize=(10, 6))\nsns.lineplot(data=data, x='x', y='y', hue='function')\nplt.title('Seaborn Line Plot')\nplt.show()\n\n\n\n\n\n\n\n\nAltair:\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ndata = pd.DataFrame({\n    'x': np.concatenate([x, x]),\n    'y': np.concatenate([np.sin(x), np.cos(x)]),\n    'function': ['Sine']*100 + ['Cosine']*100\n})\n\nalt.Chart(data).mark_line().encode(\n    x='x',\n    y='y',\n    color='function'\n).properties(\n    width=600,\n    height=400,\n    title='Altair Line Plot'\n)\n\n\n\n\n\n\n\n\n\n\nMatplotlib:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = np.random.rand(10, 12)\n\nplt.figure(figsize=(10, 8))\nplt.imshow(data, cmap='viridis')\nplt.colorbar(label='Value')\nplt.title('Matplotlib Heatmap')\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.show()\n\n\n\n\n\n\n\n\nSeaborn:\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = np.random.rand(10, 12)\n\nplt.figure(figsize=(10, 8))\nsns.heatmap(data, annot=True, cmap='viridis', fmt='.2f')\nplt.title('Seaborn Heatmap')\nplt.show()\n\n\n\n\n\n\n\n\nAltair:\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\n# Create sample data\ndata = np.random.rand(10, 12)\ndf = pd.DataFrame(data)\n\n# Reshape for Altair\ndf_long = df.reset_index().melt(id_vars='index')\ndf_long.columns = ['y', 'x', 'value']\n\nalt.Chart(df_long).mark_rect().encode(\n    x='x:O',\n    y='y:O',\n    color='value:Q'\n).properties(\n    width=500,\n    height=400,\n    title='Altair Heatmap'\n)"
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html#decision-framework-for-choosing-a-library",
    "href": "posts/data-visualization-tutorial/index.html#decision-framework-for-choosing-a-library",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "You need complete control over every detail of your visualization\nYou‚Äôre creating complex, custom plots\nYour visualizations will be included in scientific publications\nYou‚Äôre working with very large datasets\nYou need to create animations or specialized chart types\n\n\n\n\n\nYou want attractive plots with minimal code\nYou‚Äôre performing statistical analysis\nYou want to create common statistical plots quickly\nYou need to visualize relationships between variables\nYou want good-looking defaults but still need some customization\n\n\n\n\n\nYou want interactive visualizations\nYou prefer a declarative approach to visualization\nYou want concise, readable code\nYou‚Äôre creating dashboards or web-based visualizations\nYou‚Äôre working with small to medium-sized datasets"
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html#integration-examples",
    "href": "posts/data-visualization-tutorial/index.html#integration-examples",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\nimport pandas as pd\n\n# Create sample data\nnp.random.seed(42)\ndata = pd.DataFrame({\n    'x': np.random.normal(0, 1, 100),\n    'y': np.random.normal(0, 1, 100),\n    'category': np.random.choice(['A', 'B', 'C'], 100)\n})\n\n# Create a figure with Matplotlib\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Use Seaborn for the main plot\nsns.scatterplot(data=data, x='x', y='y', hue='category', ax=ax)\n\n# Add Matplotlib customizations\nax.set_title('Combining Matplotlib and Seaborn', fontsize=16)\nax.grid(True, linestyle='--', alpha=0.7)\nax.set_xlabel('X Variable', fontsize=12)\nax.set_ylabel('Y Variable', fontsize=12)\n\n# Add annotations using Matplotlib\nax.annotate('Interesting Point', xy=(-1, 1), xytext=(-2, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nimport altair as alt\nimport pandas as pd\nimport numpy as np\n\n# Create sample data with pandas\nnp.random.seed(42)\ndf = pd.DataFrame({\n    'date': pd.date_range('2023-01-01', periods=100),\n    'value': np.cumsum(np.random.randn(100)),\n    'category': np.random.choice(['Group A', 'Group B'], 100)\n})\n\n# Use pandas to prepare the data\ndf['month'] = df['date'].dt.month\nmonthly_avg = df.groupby(['month', 'category'])['value'].mean().reset_index()\n\n# Create the Altair visualization\nchart = alt.Chart(monthly_avg).mark_line(point=True).encode(\n    x='month:O',\n    y='value:Q',\n    color='category:N',\n    tooltip=['month', 'value', 'category']\n).properties(\n    width=600,\n    height=400,\n    title='Monthly Averages by Category'\n).interactive()\n\nchart"
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html#performance-comparison",
    "href": "posts/data-visualization-tutorial/index.html#performance-comparison",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "For libraries like Matplotlib, Seaborn, and Altair, performance can vary widely depending on the size of your dataset and the complexity of your visualization. Here‚Äôs a general overview:\n\n\n\nAll three libraries perform well\nAltair might have slightly more overhead due to its JSON specification generation\n\n\n\n\n\nMatplotlib and Seaborn continue to perform well\nAltair starts to slow down but remains usable\n\n\n\n\n\nMatplotlib performs best for large static visualizations\nSeaborn becomes slower as it adds statistical computations\nAltair significantly slows down and may require data aggregation\n\n\n\n\n\nMatplotlib: Use plot() instead of scatter() for line plots, or try hexbin() for density plots\nSeaborn: Use sample() or aggregation methods before plotting\nAltair: Use transform_sample() or pre-aggregate your data"
  },
  {
    "objectID": "posts/data-visualization-tutorial/index.html#conclusion",
    "href": "posts/data-visualization-tutorial/index.html#conclusion",
    "title": "Python Data Visualization: Matplotlib vs Seaborn vs Altair",
    "section": "",
    "text": "The Python visualization ecosystem offers tools for every need, from low-level control to high-level abstraction:\n\nMatplotlib provides ultimate flexibility and control but requires more code and knowledge\nSeaborn offers a perfect middle ground with statistical integration and clean defaults\nAltair delivers a concise, declarative approach with built-in interactivity\n\nRather than picking just one library, consider becoming familiar with all three and selecting the right tool for each visualization task. Many data scientists use a combination of these libraries, leveraging the strengths of each one as needed.\nFor those just starting, Seaborn provides a gentle entry point with attractive results for common visualization needs. As your skills advance, you can incorporate Matplotlib for customization and Altair for interactive visualizations."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My posts",
    "section": "",
    "text": "Active Learning Influence Selection: A Comprehensive Guide\n\n\n\ncode\n\nresearch\n\n\n\n\n\n\n\nKrishnatheja Vanka\n\n\nApr 19, 2025\n\n\n\n\n\n\n\n\n\n\n\nPython Data Visualization: Matplotlib vs Seaborn vs Altair\n\n\n\ncode\n\ntutorial\n\n\n\n\n\n\n\nKrishnatheja Vanka\n\n\nApr 12, 2025\n\n\n\n\n\n\n\n\n\n\n\nFrom Pandas to Polars\n\n\n\ncode\n\ntutorial\n\nadvanced\n\n\n\n\n\n\n\nKrishnatheja Vanka\n\n\nApr 5, 2025\n\n\n\n\n\n\n\n\n\n\n\nPyTorch Lightning: A Comprehensive Guide\n\n\n\ncode\n\ntutorial\n\nadvanced\n\n\n\n\n\n\n\nKrishnatheja Vanka\n\n\nMar 29, 2025\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\nKrishnatheja Vanka\n\n\nMar 22, 2025\n\n\n\n\n\n\nNo matching items"
  }
]