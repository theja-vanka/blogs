<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Krishnatheja Vanka">
<meta name="dcterms.date" content="2025-07-05">

<title>The Mathematics Behind Convolutional Kolmogorov-Arnold Networks – Krishnatheja Vanka’s Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-234273d1456647dabc34a594ac50e507.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-7925e9b88044967f2c1678a0f336ecb9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Krishnatheja Vanka’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/theja-vanka"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-right">
      <h1 class="title">The Mathematics Behind Convolutional Kolmogorov-Arnold Networks</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">research</div>
                <div class="quarto-category">advanced</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-right">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Krishnatheja Vanka </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 5, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-mathematics-behind-convolutional-kolmogorov-arnold-networks" id="toc-the-mathematics-behind-convolutional-kolmogorov-arnold-networks" class="nav-link active" data-scroll-target="#the-mathematics-behind-convolutional-kolmogorov-arnold-networks">The Mathematics Behind Convolutional Kolmogorov-Arnold Networks</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#the-kolmogorov-arnold-representation-theorem" id="toc-the-kolmogorov-arnold-representation-theorem" class="nav-link" data-scroll-target="#the-kolmogorov-arnold-representation-theorem">The Kolmogorov-Arnold Representation Theorem</a>
  <ul class="collapse">
  <li><a href="#theoretical-foundation" id="toc-theoretical-foundation" class="nav-link" data-scroll-target="#theoretical-foundation">Theoretical Foundation</a></li>
  <li><a href="#implications-for-neural-networks" id="toc-implications-for-neural-networks" class="nav-link" data-scroll-target="#implications-for-neural-networks">Implications for Neural Networks</a></li>
  </ul></li>
  <li><a href="#from-kans-to-convolutional-kans" id="toc-from-kans-to-convolutional-kans" class="nav-link" data-scroll-target="#from-kans-to-convolutional-kans">From KANs to Convolutional KANs</a>
  <ul class="collapse">
  <li><a href="#standard-kan-architecture" id="toc-standard-kan-architecture" class="nav-link" data-scroll-target="#standard-kan-architecture">Standard KAN Architecture</a></li>
  <li><a href="#convolutional-extension" id="toc-convolutional-extension" class="nav-link" data-scroll-target="#convolutional-extension">Convolutional Extension</a></li>
  </ul></li>
  <li><a href="#mathematical-formulation-of-ckans" id="toc-mathematical-formulation-of-ckans" class="nav-link" data-scroll-target="#mathematical-formulation-of-ckans">Mathematical Formulation of CKANs</a>
  <ul class="collapse">
  <li><a href="#convolutional-kan-layer" id="toc-convolutional-kan-layer" class="nav-link" data-scroll-target="#convolutional-kan-layer">1. Convolutional KAN Layer</a></li>
  <li><a href="#univariate-function-parameterization" id="toc-univariate-function-parameterization" class="nav-link" data-scroll-target="#univariate-function-parameterization">2. Univariate Function Parameterization</a></li>
  <li><a href="#shared-function-approach" id="toc-shared-function-approach" class="nav-link" data-scroll-target="#shared-function-approach">3. Shared Function Approach</a></li>
  </ul></li>
  <li><a href="#activation-functions-in-ckans" id="toc-activation-functions-in-ckans" class="nav-link" data-scroll-target="#activation-functions-in-ckans">Activation Functions in CKANs</a>
  <ul class="collapse">
  <li><a href="#learnable-activation-functions" id="toc-learnable-activation-functions" class="nav-link" data-scroll-target="#learnable-activation-functions">Learnable Activation Functions</a></li>
  </ul></li>
  <li><a href="#training-dynamics-and-optimization" id="toc-training-dynamics-and-optimization" class="nav-link" data-scroll-target="#training-dynamics-and-optimization">Training Dynamics and Optimization</a>
  <ul class="collapse">
  <li><a href="#gradient-computation" id="toc-gradient-computation" class="nav-link" data-scroll-target="#gradient-computation">Gradient Computation</a></li>
  <li><a href="#regularization-techniques" id="toc-regularization-techniques" class="nav-link" data-scroll-target="#regularization-techniques">Regularization Techniques</a></li>
  </ul></li>
  <li><a href="#computational-complexity-analysis" id="toc-computational-complexity-analysis" class="nav-link" data-scroll-target="#computational-complexity-analysis">Computational Complexity Analysis</a>
  <ul class="collapse">
  <li><a href="#parameter-count" id="toc-parameter-count" class="nav-link" data-scroll-target="#parameter-count">Parameter Count</a></li>
  <li><a href="#computational-complexity" id="toc-computational-complexity" class="nav-link" data-scroll-target="#computational-complexity">Computational Complexity</a></li>
  </ul></li>
  <li><a href="#architectural-variations" id="toc-architectural-variations" class="nav-link" data-scroll-target="#architectural-variations">Architectural Variations</a>
  <ul class="collapse">
  <li><a href="#depthwise-separable-ckans" id="toc-depthwise-separable-ckans" class="nav-link" data-scroll-target="#depthwise-separable-ckans">1. Depthwise Separable CKANs</a></li>
  <li><a href="#dilated-ckans" id="toc-dilated-ckans" class="nav-link" data-scroll-target="#dilated-ckans">2. Dilated CKANs</a></li>
  <li><a href="#residual-ckans" id="toc-residual-ckans" class="nav-link" data-scroll-target="#residual-ckans">3. Residual CKANs</a></li>
  </ul></li>
  <li><a href="#approximation-properties" id="toc-approximation-properties" class="nav-link" data-scroll-target="#approximation-properties">Approximation Properties</a>
  <ul class="collapse">
  <li><a href="#universal-approximation" id="toc-universal-approximation" class="nav-link" data-scroll-target="#universal-approximation">Universal Approximation</a></li>
  <li><a href="#convergence-analysis" id="toc-convergence-analysis" class="nav-link" data-scroll-target="#convergence-analysis">Convergence Analysis</a></li>
  </ul></li>
  <li><a href="#practical-implementation-considerations" id="toc-practical-implementation-considerations" class="nav-link" data-scroll-target="#practical-implementation-considerations">Practical Implementation Considerations</a>
  <ul class="collapse">
  <li><a href="#numerical-stability" id="toc-numerical-stability" class="nav-link" data-scroll-target="#numerical-stability">Numerical Stability</a></li>
  <li><a href="#memory-optimization" id="toc-memory-optimization" class="nav-link" data-scroll-target="#memory-optimization">Memory Optimization</a></li>
  </ul></li>
  <li><a href="#comparison-with-traditional-cnns" id="toc-comparison-with-traditional-cnns" class="nav-link" data-scroll-target="#comparison-with-traditional-cnns">Comparison with Traditional CNNs</a>
  <ul class="collapse">
  <li><a href="#expressivity" id="toc-expressivity" class="nav-link" data-scroll-target="#expressivity">Expressivity</a></li>
  <li><a href="#interpretability" id="toc-interpretability" class="nav-link" data-scroll-target="#interpretability">Interpretability</a></li>
  <li><a href="#computational-trade-offs" id="toc-computational-trade-offs" class="nav-link" data-scroll-target="#computational-trade-offs">Computational Trade-offs</a></li>
  </ul></li>
  <li><a href="#future-directions-and-extensions" id="toc-future-directions-and-extensions" class="nav-link" data-scroll-target="#future-directions-and-extensions">Future Directions and Extensions</a>
  <ul class="collapse">
  <li><a href="#theoretical-advances" id="toc-theoretical-advances" class="nav-link" data-scroll-target="#theoretical-advances">Theoretical Advances</a></li>
  <li><a href="#practical-improvements" id="toc-practical-improvements" class="nav-link" data-scroll-target="#practical-improvements">Practical Improvements</a></li>
  <li><a href="#applications" id="toc-applications" class="nav-link" data-scroll-target="#applications">Applications</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-right" id="quarto-document-content">





<section id="the-mathematics-behind-convolutional-kolmogorov-arnold-networks" class="level1">
<h1>The Mathematics Behind Convolutional Kolmogorov-Arnold Networks</h1>
<p><img src="ckan-math.png" class="img-fluid"></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Convolutional Kolmogorov-Arnold Networks (CKANs) represent a revolutionary approach to neural network architecture that combines the theoretical foundations of the Kolmogorov-Arnold representation theorem with the practical advantages of convolutional operations. Unlike traditional Convolutional Neural Networks (CNNs) that rely on fixed linear transformations followed by nonlinear activations, CKANs replace these components with learnable univariate functions, offering a more flexible and theoretically grounded approach to function approximation.</p>
</section>
<section id="the-kolmogorov-arnold-representation-theorem" class="level2">
<h2 class="anchored" data-anchor-id="the-kolmogorov-arnold-representation-theorem">The Kolmogorov-Arnold Representation Theorem</h2>
<section id="theoretical-foundation" class="level3">
<h3 class="anchored" data-anchor-id="theoretical-foundation">Theoretical Foundation</h3>
<p>The Kolmogorov-Arnold representation theorem, proved by Andrey Kolmogorov in 1957 and later refined by Vladimir Arnold, states that any multivariate continuous function can be represented as a superposition of continuous functions of a single variable.</p>
<p><strong>Theorem (Kolmogorov-Arnold)</strong>: For any continuous function <span class="math inline">\(f: [0,1]^n \to \mathbb{R}\)</span>, there exist continuous functions <span class="math inline">\(\phi_{q,p}: [0,1] \to \mathbb{R}\)</span> and <span class="math inline">\(\Phi_q: \mathbb{R} \to \mathbb{R}\)</span> such that:</p>
<p><span class="math display">\[
f(x_1, x_2, \ldots, x_n) = \sum_{q=0}^{2n} \Phi_q\left(\sum_{p=1}^{n} \phi_{q,p}(x_p)\right)
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(q\)</span> ranges from <span class="math inline">\(0\)</span> to <span class="math inline">\(2n\)</span></li>
<li><span class="math inline">\(p\)</span> ranges from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span></li>
<li>The functions <span class="math inline">\(\phi_{q,p}\)</span> are universal (independent of <span class="math inline">\(f\)</span>)</li>
<li>Only the outer functions <span class="math inline">\(\Phi_q\)</span> depend on the specific function <span class="math inline">\(f\)</span></li>
</ul>
</section>
<section id="implications-for-neural-networks" class="level3">
<h3 class="anchored" data-anchor-id="implications-for-neural-networks">Implications for Neural Networks</h3>
<p>This theorem suggests that instead of using traditional linear combinations followed by fixed activation functions, we can construct networks using compositions of univariate functions. This forms the theoretical backbone of Kolmogorov-Arnold Networks (KANs).</p>
</section>
</section>
<section id="from-kans-to-convolutional-kans" class="level2">
<h2 class="anchored" data-anchor-id="from-kans-to-convolutional-kans">From KANs to Convolutional KANs</h2>
<section id="standard-kan-architecture" class="level3">
<h3 class="anchored" data-anchor-id="standard-kan-architecture">Standard KAN Architecture</h3>
<p>A standard KAN layer transforms input <span class="math inline">\(\mathbf{x} \in \mathbb{R}^{n_{in}}\)</span> to output <span class="math inline">\(\mathbf{y} \in \mathbb{R}^{n_{out}}\)</span> using:</p>
<p><span class="math display">\[
y_j = \sum_{i=1}^{n_{in}} \phi_{i,j}(x_i)
\]</span></p>
<p>where <span class="math inline">\(\phi_{i,j}: \mathbb{R} \to \mathbb{R}\)</span> are learnable univariate functions, typically parameterized using splines or other basis functions.</p>
</section>
<section id="convolutional-extension" class="level3">
<h3 class="anchored" data-anchor-id="convolutional-extension">Convolutional Extension</h3>
<p>The challenge in extending KANs to convolutional architectures lies in maintaining the univariate nature of the learnable functions while incorporating spatial locality and translation invariance. CKANs achieve this through several key innovations:</p>
</section>
</section>
<section id="mathematical-formulation-of-ckans" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-formulation-of-ckans">Mathematical Formulation of CKANs</h2>
<section id="convolutional-kan-layer" class="level3">
<h3 class="anchored" data-anchor-id="convolutional-kan-layer">1. Convolutional KAN Layer</h3>
<p>For a CKAN layer with input feature map <span class="math inline">\(\mathbf{X} \in \mathbb{R}^{H \times W \times C_{in}}\)</span> and output <span class="math inline">\(\mathbf{Y} \in \mathbb{R}^{H' \times W' \times C_{out}}\)</span>, the convolution operation is defined as:</p>
<p><span class="math display">\[
Y_{i,j,k} = \sum_{c=1}^{C_{in}} \sum_{u=0}^{K-1} \sum_{v=0}^{K-1} \phi_{c,k,u,v}(X_{i+u,j+v,c})
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\((i,j)\)</span> are spatial coordinates in the output feature map</li>
<li><span class="math inline">\(k\)</span> is the output channel index</li>
<li><span class="math inline">\(c\)</span> is the input channel index</li>
<li><span class="math inline">\(K\)</span> is the kernel size</li>
<li><span class="math inline">\(\phi_{c,k,u,v}\)</span> are learnable univariate functions specific to input channel <span class="math inline">\(c\)</span>, output channel <span class="math inline">\(k\)</span>, and kernel position <span class="math inline">\((u,v)\)</span></li>
</ul>
</section>
<section id="univariate-function-parameterization" class="level3">
<h3 class="anchored" data-anchor-id="univariate-function-parameterization">2. Univariate Function Parameterization</h3>
<p>The univariate functions <span class="math inline">\(\phi\)</span> are typically parameterized using B-splines or other basis functions. For B-splines of degree <span class="math inline">\(d\)</span> with <span class="math inline">\(n\)</span> control points:</p>
<p><span class="math display">\[
\phi(x) = \sum_{i=0}^{n-1} c_i B_i^d(x)
\]</span></p>
<p>where <span class="math inline">\(c_i\)</span> are learnable coefficients and <span class="math inline">\(B_i^d(x)\)</span> are B-spline basis functions defined recursively:</p>
<p><span class="math display">\[
B_i^0(x) = \begin{cases} 1 &amp; \text{if } t_i \leq x &lt; t_{i+1} \\ 0 &amp; \text{otherwise} \end{cases}
\]</span></p>
<p><span class="math display">\[
B_i^d(x) = \frac{x - t_i}{t_{i+d} - t_i} B_i^{d-1}(x) + \frac{t_{i+d+1} - x}{t_{i+d+1} - t_{i+1}} B_{i+1}^{d-1}(x)
\]</span></p>
</section>
<section id="shared-function-approach" class="level3">
<h3 class="anchored" data-anchor-id="shared-function-approach">3. Shared Function Approach</h3>
<p>To reduce the number of parameters, CKANs often employ parameter sharing strategies:</p>
<section id="spatial-sharing" class="level4">
<h4 class="anchored" data-anchor-id="spatial-sharing">Spatial Sharing</h4>
<p>Functions are shared across spatial locations: <span class="math display">\[
\phi_{c,k}(x) \text{ for all positions } (u,v)
\]</span></p>
</section>
<section id="channel-grouping" class="level4">
<h4 class="anchored" data-anchor-id="channel-grouping">Channel Grouping</h4>
<p>Functions are shared within channel groups: <span class="math display">\[
\phi_{g,k}(x) \text{ where } g = \lfloor c/G \rfloor \text{ for group size } G
\]</span></p>
</section>
</section>
</section>
<section id="activation-functions-in-ckans" class="level2">
<h2 class="anchored" data-anchor-id="activation-functions-in-ckans">Activation Functions in CKANs</h2>
<section id="learnable-activation-functions" class="level3">
<h3 class="anchored" data-anchor-id="learnable-activation-functions">Learnable Activation Functions</h3>
<p>Unlike traditional CNNs with fixed activation functions (ReLU, sigmoid, etc.), CKANs use learnable activation functions. These can be viewed as univariate functions applied element-wise:</p>
<p><span class="math display">\[
\text{Activation}(x) = \psi(x)
\]</span></p>
<p>where <span class="math inline">\(\psi\)</span> is a learnable univariate function, often parameterized as:</p>
<p><span class="math display">\[
\psi(x) = \text{SiLU}(x) + \sum_{i=0}^{n-1} a_i B_i^d(x)
\]</span></p>
<p>The SiLU (Sigmoid Linear Unit) provides a smooth base function, while the spline terms allow for fine-tuning.</p>
</section>
</section>
<section id="training-dynamics-and-optimization" class="level2">
<h2 class="anchored" data-anchor-id="training-dynamics-and-optimization">Training Dynamics and Optimization</h2>
<section id="gradient-computation" class="level3">
<h3 class="anchored" data-anchor-id="gradient-computation">Gradient Computation</h3>
<p>The gradient of the loss function with respect to the spline coefficients involves the derivative of B-spline basis functions:</p>
<p><span class="math display">\[
\frac{\partial L}{\partial c_i} = \frac{\partial L}{\partial \phi} \cdot B_i^d(x)
\]</span></p>
<p>For the derivative of the function itself: <span class="math display">\[
\frac{\partial L}{\partial x} = \frac{\partial L}{\partial \phi} \cdot \sum_{i=0}^{n-1} c_i \frac{dB_i^d(x)}{dx}
\]</span></p>
</section>
<section id="regularization-techniques" class="level3">
<h3 class="anchored" data-anchor-id="regularization-techniques">Regularization Techniques</h3>
<p>CKANs typically employ several regularization techniques:</p>
<section id="smoothness-regularization" class="level4">
<h4 class="anchored" data-anchor-id="smoothness-regularization">Smoothness Regularization</h4>
<p><span class="math display">\[
R_{\text{smooth}} = \sum_{i,j} \int \left(\frac{d^2\phi_{i,j}(x)}{dx^2}\right)^2 dx
\]</span></p>
</section>
<section id="sparsity-regularization" class="level4">
<h4 class="anchored" data-anchor-id="sparsity-regularization">Sparsity Regularization</h4>
<p><span class="math display">\[
R_{\text{sparse}} = \sum_{i,j} \int |\phi_{i,j}(x)| dx
\]</span></p>
</section>
<section id="total-variation-regularization" class="level4">
<h4 class="anchored" data-anchor-id="total-variation-regularization">Total Variation Regularization</h4>
<p><span class="math display">\[
R_{\text{TV}} = \sum_{i,j} \int \left|\frac{d\phi_{i,j}(x)}{dx}\right| dx
\]</span></p>
</section>
</section>
</section>
<section id="computational-complexity-analysis" class="level2">
<h2 class="anchored" data-anchor-id="computational-complexity-analysis">Computational Complexity Analysis</h2>
<section id="parameter-count" class="level3">
<h3 class="anchored" data-anchor-id="parameter-count">Parameter Count</h3>
<p>For a CKAN layer with:</p>
<ul>
<li>Input channels: <span class="math inline">\(C_{in}\)</span></li>
<li>Output channels: <span class="math inline">\(C_{out}\)</span></li>
<li>Kernel size: <span class="math inline">\(K \times K\)</span></li>
<li>Spline degree: <span class="math inline">\(d\)</span></li>
<li>Control points per spline: <span class="math inline">\(n\)</span></li>
</ul>
<p>The parameter count is: <span class="math display">\[
\text{Parameters} = C_{in} \times C_{out} \times K^2 \times n
\]</span></p>
<p>Compare this to traditional CNN: <span class="math display">\[
\text{Parameters}_{\text{CNN}} = C_{in} \times C_{out} \times K^2
\]</span></p>
</section>
<section id="computational-complexity" class="level3">
<h3 class="anchored" data-anchor-id="computational-complexity">Computational Complexity</h3>
<p>The forward pass complexity for a single CKAN layer is: <span class="math display">\[
O(H \times W \times C_{out} \times C_{in} \times K^2 \times n)
\]</span></p>
<p>where <span class="math inline">\(H \times W\)</span> is the spatial dimension of the output feature map.</p>
</section>
</section>
<section id="architectural-variations" class="level2">
<h2 class="anchored" data-anchor-id="architectural-variations">Architectural Variations</h2>
<section id="depthwise-separable-ckans" class="level3">
<h3 class="anchored" data-anchor-id="depthwise-separable-ckans">1. Depthwise Separable CKANs</h3>
<p>Inspired by depthwise separable convolutions, this variant separates the operation into:</p>
<p><strong>Depthwise Convolution</strong>: <span class="math display">\[
Y_{i,j,c} = \sum_{u=0}^{K-1} \sum_{v=0}^{K-1} \phi_{c,u,v}(X_{i+u,j+v,c})
\]</span></p>
<p><strong>Pointwise Convolution</strong>: <span class="math display">\[
Z_{i,j,k} = \sum_{c=1}^{C_{in}} \psi_{c,k}(Y_{i,j,c})
\]</span></p>
</section>
<section id="dilated-ckans" class="level3">
<h3 class="anchored" data-anchor-id="dilated-ckans">2. Dilated CKANs</h3>
<p>Incorporating dilation for larger receptive fields: <span class="math display">\[
Y_{i,j,k} = \sum_{c=1}^{C_{in}} \sum_{u=0}^{K-1} \sum_{v=0}^{K-1} \phi_{c,k,u,v}(X_{i+d \cdot u,j+d \cdot v,c})
\]</span></p>
<p>where <span class="math inline">\(d\)</span> is the dilation factor.</p>
</section>
<section id="residual-ckans" class="level3">
<h3 class="anchored" data-anchor-id="residual-ckans">3. Residual CKANs</h3>
<p>Combining residual connections with CKAN layers: <span class="math display">\[
Y = \text{CKAN}(X) + \alpha \cdot X
\]</span></p>
<p>where <span class="math inline">\(\alpha\)</span> is a learnable scaling factor.</p>
</section>
</section>
<section id="approximation-properties" class="level2">
<h2 class="anchored" data-anchor-id="approximation-properties">Approximation Properties</h2>
<section id="universal-approximation" class="level3">
<h3 class="anchored" data-anchor-id="universal-approximation">Universal Approximation</h3>
<p>CKANs inherit the universal approximation properties of KANs. For any continuous function <span class="math inline">\(f: \mathbb{R}^n \to \mathbb{R}\)</span> and any <span class="math inline">\(\epsilon &gt; 0\)</span>, there exists a CKAN that approximates <span class="math inline">\(f\)</span> within <span class="math inline">\(\epsilon\)</span> accuracy.</p>
</section>
<section id="convergence-analysis" class="level3">
<h3 class="anchored" data-anchor-id="convergence-analysis">Convergence Analysis</h3>
<p>The convergence rate of CKANs depends on several factors:</p>
<ol type="1">
<li><strong>Smoothness of target function</strong>: Smoother functions converge faster</li>
<li><strong>Spline degree</strong>: Higher degree splines provide better approximation but may overfit</li>
<li><strong>Number of control points</strong>: More control points increase expressivity but computational cost</li>
</ol>
<p>The approximation error for a function <span class="math inline">\(f\)</span> with <span class="math inline">\(s\)</span>-th order smoothness is bounded by: <span class="math display">\[
\|f - \text{CKAN}(f)\|_\infty \leq C \cdot h^s
\]</span></p>
<p>where <span class="math inline">\(h\)</span> is the spacing between spline knots and <span class="math inline">\(C\)</span> is a constant depending on <span class="math inline">\(f\)</span>.</p>
</section>
</section>
<section id="practical-implementation-considerations" class="level2">
<h2 class="anchored" data-anchor-id="practical-implementation-considerations">Practical Implementation Considerations</h2>
<section id="numerical-stability" class="level3">
<h3 class="anchored" data-anchor-id="numerical-stability">Numerical Stability</h3>
<p>CKANs require careful attention to numerical stability:</p>
<ol type="1">
<li><strong>Spline knot placement</strong>: Uniform or adaptive knot placement strategies</li>
<li><strong>Coefficient initialization</strong>: Proper initialization of spline coefficients</li>
<li><strong>Gradient clipping</strong>: Preventing gradient explosion during backpropagation</li>
</ol>
</section>
<section id="memory-optimization" class="level3">
<h3 class="anchored" data-anchor-id="memory-optimization">Memory Optimization</h3>
<p>Several techniques can reduce memory usage:</p>
<ol type="1">
<li><strong>Lazy evaluation</strong>: Computing spline values on-demand</li>
<li><strong>Coefficient sharing</strong>: Sharing coefficients across similar functions</li>
<li><strong>Quantization</strong>: Using lower precision for spline coefficients</li>
</ol>
</section>
</section>
<section id="comparison-with-traditional-cnns" class="level2">
<h2 class="anchored" data-anchor-id="comparison-with-traditional-cnns">Comparison with Traditional CNNs</h2>
<section id="expressivity" class="level3">
<h3 class="anchored" data-anchor-id="expressivity">Expressivity</h3>
<p>CKANs offer superior expressivity due to:</p>
<ul>
<li>Learnable activation functions</li>
<li>Non-linear transformations in each connection</li>
<li>Adaptive function shapes based on data</li>
</ul>
</section>
<section id="interpretability" class="level3">
<h3 class="anchored" data-anchor-id="interpretability">Interpretability</h3>
<p>The univariate nature of CKAN functions provides better interpretability:</p>
<ul>
<li>Each function can be visualized as a 1D curve</li>
<li>Function shapes reveal learned patterns</li>
<li>Easier to understand feature transformations</li>
</ul>
</section>
<section id="computational-trade-offs" class="level3">
<h3 class="anchored" data-anchor-id="computational-trade-offs">Computational Trade-offs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Better function approximation with fewer layers</li>
<li>Interpretable learned functions</li>
<li>Theoretical guarantees</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Higher computational cost per layer</li>
<li>More parameters to optimize</li>
<li>Longer training times</li>
</ul>
</section>
</section>
<section id="future-directions-and-extensions" class="level2">
<h2 class="anchored" data-anchor-id="future-directions-and-extensions">Future Directions and Extensions</h2>
<section id="theoretical-advances" class="level3">
<h3 class="anchored" data-anchor-id="theoretical-advances">Theoretical Advances</h3>
<ol type="1">
<li><strong>Convergence guarantees</strong>: Developing stronger theoretical guarantees for CKAN convergence</li>
<li><strong>Optimal architectures</strong>: Finding optimal CKAN architectures for specific tasks</li>
<li><strong>Generalization bounds</strong>: Establishing generalization bounds for CKANs</li>
</ol>
</section>
<section id="practical-improvements" class="level3">
<h3 class="anchored" data-anchor-id="practical-improvements">Practical Improvements</h3>
<ol type="1">
<li><strong>Efficient implementations</strong>: Developing more efficient CUDA kernels for CKAN operations</li>
<li><strong>Automated architecture search</strong>: Using neural architecture search for CKAN design</li>
<li><strong>Hardware acceleration</strong>: Designing specialized hardware for CKAN computations</li>
</ol>
</section>
<section id="applications" class="level3">
<h3 class="anchored" data-anchor-id="applications">Applications</h3>
<ol type="1">
<li><strong>Computer vision</strong>: Image classification, object detection, segmentation</li>
<li><strong>Scientific computing</strong>: Solving partial differential equations</li>
<li><strong>Signal processing</strong>: Audio and video processing applications</li>
</ol>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Convolutional Kolmogorov-Arnold Networks represent a significant advancement in neural network architectures, combining solid theoretical foundations with practical convolutional operations. While computationally more expensive than traditional CNNs, CKANs offer superior expressivity, interpretability, and theoretical guarantees. As the field continues to evolve, we can expect further optimizations and novel applications of this powerful architecture.</p>
<p>The mathematics behind CKANs reveals a rich interplay between approximation theory, spline functions, and deep learning, opening new avenues for both theoretical understanding and practical applications in machine learning.</p>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© 2025 Krishnatheja Vanka</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>